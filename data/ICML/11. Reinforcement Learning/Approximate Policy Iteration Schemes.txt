Approximate Policy Iteration Schemes: A Comparison

Bruno Scherrer
Inria, Villers-leÌ€s-Nancy, F-54600, France
UniversiteÌ de Lorraine, LORIA, UMR 7503, VandÅ“uvre-leÌ€s-Nancy, F-54506, France

Abstract
We consider the infinite-horizon discounted optimal control problem formalized by Markov Decision Processes. We focus on several approximate variations of the Policy Iteration algorithm:
Approximate Policy Iteration (API) (Bertsekas
& Tsitsiklis, 1996), Conservative Policy Iteration (CPI) (Kakade & Langford, 2002), a natural adaptation of the Policy Search by Dynamic
Programming algorithm (Bagnell et al., 2003) to
the infinite-horizon case (PSDPâˆ ), and the recently proposed Non-Stationary Policy Iteration
(NSPI(m)) (Scherrer & Lesner, 2012). For all algorithms, we describe performance bounds with
respect the per-iteration error , and make a comparison by paying a particular attention to the
concentrability constants involved, the number of
iterations and the memory required. Our analysis
highlights the following points: 1) The performance guarantee of CPI can be arbitrarily better
than that of API, but this comes at the cost of a
relativeâ€”exponential in 1 â€”increase of the number of iterations. 2) PSDPâˆ enjoys the best of
both worlds: its performance guarantee is similar to that of CPI, but within a number of iterations similar to that of API. 3) Contrary to
API that requires a constant memory, the memory needed by CPI and PSDPâˆ is proportional
to their number of iterations, which may be problematic when the discount factor Î³ is close to
1 or the approximation error  is close to 0; we
show that the NSPI(m) algorithm allows to make
an overall trade-off between memory and performance. Simulations with these schemes confirm
our analysis.

Proceedings of the 31 st International Conference on Machine
Learning, Beijing, China, 2014. JMLR: W&CP volume 32. Copyright 2014 by the author(s).

BRUNO . SCHERRER @ INRIA . FR

1. Introduction
We consider an infinite-horizon discounted Markov Decision Process (MDP) (Puterman, 1994; Bertsekas & Tsitsiklis, 1996) (S, A, P, r, Î³), where S is a possibly infinite state space, A is a finite action space, P (ds0 |s, a),
for all (s, a), is a probability kernel on S, r : S â†’
[âˆ’Rmax , Rmax ] is a reward function bounded by Rmax , and
Î³ âˆˆ (0, 1) is a discount factor. A stationary deterministic policy Ï€ : S â†’ A maps states to actions. We write
PÏ€ (ds0 |s) = P (ds0 |s, Ï€(s)) for the stochastic kernel associated to policy Ï€. The value vÏ€ of a policy Ï€ is a function
mapping states to the expected discounted sum of rewards
received when following Ï€ from these states: for all s âˆˆ S,

"âˆ
#

X

t
vÏ€ (s) = E
Î³ r(st )s0 = s, st+1 âˆ¼ PÏ€ (Â·|st ) .

t=0

The value vÏ€ is clearly bounded by Vmax = Rmax /(1 âˆ’ Î³).
It is well-known that vÏ€ can be characterized as the unique
fixed point of the linear Bellman operator associated to a
policy Ï€: TÏ€ : v 7â†’ r + Î³PÏ€ v. Similarly, the Bellman optimality operator T : v 7â†’ maxÏ€ TÏ€ v has as unique fixed
point the optimal value vâˆ— = maxÏ€ vÏ€ . A policy Ï€ is
greedy w.r.t. a value function v if TÏ€ v = T v, the set of
such greedy policies is written Gv. Finally, a policy Ï€âˆ— is
optimal, with value vÏ€âˆ— = vâˆ— , iff Ï€âˆ— âˆˆ Gvâˆ— , or equivalently
TÏ€âˆ— vâˆ— = vâˆ— .
The goal of this paper is to study and compare several
approximate Policy Iteration schemes. In the literature,
such schemes can be seen as implementing an approximate
greedy operator, G , that takes as input a distribution Î½ and
a function v : S â†’ R and returns a policy Ï€ that is (, Î½)approximately greedy with respect to v in the sense that:
Î½(T v âˆ’ TÏ€ v) = Î½(max
TÏ€0 v âˆ’ TÏ€ v) â‰¤ .
0
Ï€

(1)

where for all x, Î½x denotes Esâˆ¼Î½ [x(s)]. In practice, this approximation of the greedy operator can be achieved through
a `p -regression of the so-called Q-functionâ€”the stateaction value functionâ€”(a direct regression is suggested
by Kakade & Langford (2002), a fixed-point LSTD approach is used by Lagoudakis & Parr (2003b)) or through a

Approximate Policy Iteration Schemes: A Comparison

(cost-sensitive) classification problem (Lagoudakis & Parr,
2003a; Lazaric et al., 2010). With this operator in hand, we
shall describe several Policy Iteration schemes in Section 2.
Then Section 3 will provide a detailed comparative analysis of their performance guarantees, time complexities, and
memory requirements. Section 4 will go on by providing
experiments that will illustrate their behavior, and confirm
our analysis. Finally, Section 5 will conclude and present
future work.

2. Algorithms
API We begin by describing the standard Approximate
Policy Iteration (API) (Bertsekas & Tsitsiklis, 1996). At
each iteration k, the algorithm switches to the policy that
is approximately greedy with respect to the value of the
previous policy for some distribution Î½:
Ï€k+1 â† Gk+1 (Î½, vÏ€k ).

(2)

If there is no error (k = 0) and Î½ assigns a positive weights
to every state, it can easily be seen that this algorithm generates the same sequence of policies as exact Policy Iterations since from Equation (1) the policies are exactly
greedy.
CPI/CPI(Î±)/API(Î±) We now turn to the description of
Conservative Policy Iteration (CPI) proposed by (Kakade
& Langford, 2002). At iteration k, CPI (described in Equation (3)) uses the distribution dÏ€k ,Î½ = (1 âˆ’ Î³)Î½(I âˆ’
Î³PÏ€k )âˆ’1 â€”the discounted cumulative occupancy measure
induced by Ï€k when starting from Î½â€”for calling the approximate greedy operator, and uses a stepsize Î±k to generate a stochastic mixture of all the policies that are returned
by the successive calls to the approximate greedy operator,
which explains the adjective â€œconservativeâ€:
Ï€k+1 â† (1 âˆ’ Î±k+1 )Ï€k + Î±k+1 Gk+1 (dÏ€k ,Î½ , vÏ€k ) (3)
The stepsize Î±k+1 can be chosen in such a way that the
above step leads to an improvement of the expected value
of the policy given that the process is initialized according
to the distribution Î½ (Kakade & Langford, 2002). The original article also describes a criterion for deciding whether
to stop or to continue. Though the adaptive stepsize and the
stopping condition allows to derive a nice analysis, they are
in practice conservative: the stepsize Î±k should be implemented with a line-search mechanism, or be fixed to some
small value Î±. We will refer to this latter variation of CPI
as CPI(Î±).
It is natural to also consider the algorithm API(Î±) (mentioned by Lagoudakis & Parr (2003a)), a variation of API
that is conservative like CPI(Î±) in the sense that it mixes
the new policy with the previous ones with weights Î± and

1âˆ’Î±, but that directly uses the distribution Î½ in the approximate greedy step:
Ï€k+1 â† (1 âˆ’ Î±)Ï€k + Î±Gk+1 (Î½, vÏ€k )

(4)

Because it uses Î½ instead of dÏ€k ,Î½ , API(Î±) is simpler to
implement than CPI(Î±)1 .
PSDPâˆ We are now going to describe an algorithm that
has a flavour similar to APIâ€”in the sense that at each step
it does a full step towards a new deterministic policyâ€”
but also has a conservative flavour like CPIâ€”in the sense
that the policies considered evolve more and more slowly.
This algorithm is a natural variation of the Policy Search
by Dynamic Programming algorithm (PSDP) of Bagnell
et al. (2003), originally proposed to tackle finite-horizon
problems, to the infinite-horizon case; we thus refer to it as
PSDPâˆ . To the best of our knowledge however, this variation has never been used in an infinite-horizon context.
The algorithm is based on finite-horizon non-stationary
policies. Given a sequence of stationary deterministic policies (Ï€k ) that the algorithm will generate, we will write
Ïƒk = Ï€k Ï€kâˆ’1 . . . Ï€1 the k-horizon policy that makes the
first action according to Ï€k , then the second action according to Ï€kâˆ’1 , etc. Its value is vÏƒk = TÏ€k TÏ€kâˆ’1 . . . TÏ€1 r.
We will write âˆ… the â€œemptyâ€ non-stationary policy. Note
that vâˆ… = r and that any infinite-horizon policy that begins
with Ïƒk = Ï€k Ï€kâˆ’1 . . . Ï€1 , which we will (somewhat abusively) denote â€œÏƒk . . . â€ has a value vÏƒk ... â‰¥ vÏƒk âˆ’ Î³ k Vmax .
Starting from Ïƒ0 = âˆ…, the algorithm implicitely builds a
sequence of non-stationary policies (Ïƒk ) by iteratively concatenating the policies that are returned by the approximate
greedy operator:
Ï€k+1 â† Gk+1 (Î½, vÏƒk )

(5)

While the standard PSDP algorithm of Bagnell et al. (2003)
considers a horizon T and makes T iterations, the algorithm we consider here has an indefinite number of iterations. The algorithm can be stopped at any step k. The
theory that we are about to describe suggests that one may
return any policy that starts by the non-stationary policy Ïƒk .
Since Ïƒk is an approximately good finite-horizon policy,
and as we consider an infinite-horizon problem, a natural
output that one may want to use in practice is the infinitehorizon policy that loops over Ïƒk , that we shall denote
(Ïƒk )âˆ .
1
In practice, controlling the greedy step with respect to dÏ€k ,Î½
requires to generate samples from this very distribution. As explained by Kakade & Langford (2002), one such sample can be
done by running one trajectory starting from Î½ and following Ï€k ,
stopping at each step with probability 1 âˆ’ Î³. In particular, one
1
sample from dÏ€k ,Î½ requires on average 1âˆ’Î³
samples from the
underlying MDP. With this respect, API(Î±) is much simpler to
implement.

Approximate Policy Iteration Schemes: A Comparison

From a practical point of view, PSDPâˆ and CPI need to
store all the (stationary deterministic) policies generated
from the start. The memory required by the algorithmic
scheme is thus proportional to the number of iterations,
which may be prohibitive. The aim of the next paragraph,
that presents the last algorithm of this article, is to describe
a solution to this potential memory issue.
NSPI(m) We originally devised the algorithmic scheme
of Equation (5) (PSDPâˆ ) as a simplified variation of the
Non-Stationary PI algorithm with a growing period algorithm (NSPI-growing) (Scherrer & Lesner, 2012)2 . With
respect to Equation (5), the only difference of NSPIgrowing resides in the fact that the approximate greedy
step is done with respect to the value v(Ïƒk )âˆ of the policy
that loops infinitely over Ïƒk (formally the algorithm does
Ï€k+1 â† Gk+1 (Î½, v(Ïƒk )âˆ )) instead of the value vÏƒk of only
the first k steps here. Following the intuition that when
k is big, these two values will be close to each other, we
ended up considering PSDPâˆ because it is simpler. NSPIgrowing suffers from the same memory drawback as CPI
and PSDPâˆ . Interestingly, the work of Scherrer & Lesner
(2012) contains another algorithm, Non-Stationary PI with
a fixed period (NSPI(m)), that has a parameter that directly
controls the number of policies stored in memory.
Similarly to PSDPâˆ , NSPI(m) is based on non-stationary
policies. It takes as an input a parameter m. It requires a set of m initial deterministic stationary policies Ï€mâˆ’1 , Ï€mâˆ’2 , . . . , Ï€0 and iteratively generates new
policies Ï€1 , Ï€2 , . . . . For any k â‰¥ 0, we shall denote Ïƒkm the m-horizon non-stationary policy that runs
in reverse order the last m policies, which one may
write formally: Ïƒkm = Ï€k Ï€kâˆ’1 . . . Ï€kâˆ’m+1 . Also, we
shall denote (Ïƒkm )âˆ the m-periodic infinite-horizon nonstationary policy that loops over Ïƒkm . Starting from Ïƒ0m =
Ï€0 Ï€1 . . . Ï€mâˆ’1 , the algorithm iterates as follows:
Ï€k+1 â† Gk+1 (Î½, v(Ïƒkm )âˆ )

(6)

Each iteration requires to compute an approximate greedy
policy Ï€k+1 with respect to the value v(Ïƒkm )âˆ of (Ïƒkm )âˆ ,
that is the fixed point of the compound operator3 :
âˆ€v, Tk,m v = TÏ€k TÏ€kâˆ’1 . . . TÏ€kâˆ’m+1 v.
When one goes from iterations k to k + 1, the process consists in adding Ï€k+1 at the front of the (m âˆ’ 1)-horizon
policy Ï€k Ï€kâˆ’1 . . . Ï€kâˆ’m+2 , thus forming a new m-horizon
2

We later realized that it was in fact a very natural variation of
PSDP. To â€give Caesar his due and God hisâ€, we kept as the main
reference the older work and gave the name PSDPâˆ .
3
Implementing this algorithm in practice can trivially be done
through cost-sensitive classification in a way similar to Lazaric
et al. (2010). It could also be done with a straight-forward extension of LSTD(Î») to non-stationary policies.

m
policy Ïƒk+1
. Doing so, we forget about the oldest policy
Ï€kâˆ’m+1 of Ïƒkm and keep a constant memory of size m. At
any step k, the algorithm can be stopped, and the output
is the policy Ï€k,m = (Ïƒkm )âˆ that loops on Ïƒkm . It is easy
to see that NSPI(m) reduces to API when m = 1. Furthermore, if we assume that the reward function is positive, add
â€œstop actionsâ€ in every state of the model that lead to a terminal absorbing state with a null reward, and initialize with
an infinite sequence of policies that only take this â€œstop actionâ€, then NSPI(m) with m = âˆ reduces to PSDPâˆ .

3. Analysis
For all considered algorithms, we are going to describe
bounds on the expected loss Esâˆ¼Âµ [vÏ€âˆ— (s) âˆ’ vÏ€ (s)] =
Âµ(vÏ€âˆ— âˆ’ vÏ€ ) of using the (possibly stochastic or nonstationary) policy Ï€ ouput by the algorithms instead of the
optimal policy Ï€âˆ— from some initial distribution Âµ of interest as a function of an upper bound  on all errors (k ).
In order to derive these theoretical guarantees, we will first
need to introduce a few concentrability coefficients that relate the distribution Âµ with which one wants to have a guarantee, and the distribution Î½ used by the algorithms4 .
Definition 1. Let c(1), c(2), . . . be the smallest coefficients
in [1, âˆ) âˆª {âˆ} such that for all i and all sets of deterministic stationary policies Ï€1 , Ï€2 , . . . , Ï€i , ÂµPÏ€1 PÏ€2 . . . PÏ€i â‰¤
c(i)Î½. For all m, k, we define the following coefficients in
[1, âˆ) âˆª {âˆ}:
C (1,k) = (1 âˆ’ Î³)

âˆ
X

Î³ i c(i + k),

i=0

C (2,m,k) = (1 âˆ’ Î³)(1 âˆ’ Î³ m )

âˆ X
âˆ
X

Î³ i+jm c(i + jm + k).

i=0 j=0

Similarly, let cÏ€âˆ— (1), cÏ€âˆ— (2), . . . be the smallest coefficients
in [1, âˆ) âˆª {âˆ} such that for all i, Âµ(PÏ€âˆ— )i â‰¤ cÏ€âˆ— (i)Î½. We
define:
âˆ
X
CÏ€(1)
=
(1
âˆ’
Î³)
Î³ i cÏ€âˆ— (i).
âˆ—
i=0

Finally let CÏ€âˆ— be the smallest coefficient in [1, âˆ) âˆª {âˆ}
such that dÏ€âˆ— ,Âµ = (1 âˆ’ Î³)Âµ(I âˆ’ Î³PÏ€âˆ— )âˆ’1 â‰¤ CÏ€âˆ— Î½.
With these notations in hand, our first contribution is to
provide a thorough comparison of all the algorithms. This
is done in Table 1. For each algorithm, we describe some
performance bounds and the required number of iterations
and memory. To make things clear, we only display the dependence with respect to the concentrability constants, the
4

The expected loss corresponds to some weighted `1 -norm of
the loss vÏ€âˆ— âˆ’ vÏ€ . Relaxing the goal to controlling the weighted
`p -norm for some p â‰¥ 2 allows to introduce some finer coefficients (Farahmand et al., 2010; Scherrer et al., 2012). Due to lack
of space, we do not consider this here.

Approximate Policy Iteration Schemes: A Comparison

Algorithm

Performance Bound
(2,1,0)

PSDPâˆ (Eq. (5))

C
C (1,0)
C (1,0)
C (1,0)
C (1,0)
CÏ€âˆ—
CÏ€âˆ—

(' NSPI(âˆ))

C Ï€âˆ—

API (Eq. (2))
(= NSPI(1))

API(Î±) (Eq. (4)
CPI(Î±)
CPI (Eq. (3))

(1)

C (2,m,0)
C

NSPI(m) (Eq. (6))

(1,0)

m
(2,m,m)
(1)
CÏ€âˆ— + Î³ m C1âˆ’Î³ m
C (2,m,0)
CÏ€âˆ— + Î³ m m(1âˆ’Î³
m)

1
(1âˆ’Î³)2
1
(1âˆ’Î³)2
1
(1âˆ’Î³)2
1
(1âˆ’Î³)3
1
(1âˆ’Î³)3
1
(1âˆ’Î³)2
1
(1âˆ’Î³)2
1
1âˆ’Î³
1
(1âˆ’Î³)(1âˆ’Î³ m )
1
(1âˆ’Î³)2 (1âˆ’Î³ m )
1
1âˆ’Î³
1
(1âˆ’Î³)2


 log


 log

 log

1


1
1
1âˆ’Î³ log 

1

1


1



 log

Memory

1




 log

# Iter.

1


1
1âˆ’Î³
1
1âˆ’Î³
1
1âˆ’Î³
1
1âˆ’Î³

1
1
Î±(1âˆ’Î³) log 
1
1
Î±(1âˆ’Î³) log 
1
1 1
1âˆ’Î³  log 
Î³
2
1
1
1âˆ’Î³ log 
1
1
1âˆ’Î³ log 
1
log 
log 1
m
log 1
log 1

Reference
(Lazaric et al., 2010)

(Kakade & Langford, 2002)

Table 1. Upper bounds on the performance guarantees for the algorithms. Except when references are given, the bounds are to our
knowledge new. A comparison of API and CPI based on the two known bounds was done by Ghavamzadeh & Lazaric (2012). The first
bound of NSPI(m) can be seen as an adaptation of that provided by Scherrer & Lesner (2012) for the more restrictive `âˆ -norm setting.

C (2,1,0)
C (2,m,0)
CÏ€âˆ—

(1)

C Ï€âˆ—

C (1,0)

C (1,m)

C (2,m,m)

Figure 1. Hierarchy of the concentrability constants. A constant A is better than a constant Bâ€”see the text for detailsâ€”if A
is a parent of B on the above graph. The best constant is CÏ€âˆ— .

discount factor Î³, the quality  of the approximate greedy
operator, andâ€”if applicableâ€”the main parameters Î±/m of
the algorithms. For API(Î±), CPI(Î±), CPI and PSDPâˆ , the
required memory matches the number of iterations. All but
two bounds are to our knowledge original. The derivation
of the new results are given in Appendix A.
Our second contribution, that is complementary with the
comparative list of bounds, is that we can show that there
exists a hierarchy among the constants that appear in all the
bounds of Table 1. In the directed graph of Figure 1, a constant B is a descendent of A if and only if the implication
{B < âˆ â‡’ A < âˆ} holds5 . The â€œif and only ifâ€ is important here: it means that if A is a parent of B, and B is
not a parent of A, then there exists an MDP for which A
5

Dotted arrows are used to underline the fact that the comparison of coefficients is restricted to the case where the parameter m
is finite.

is finite while B is infinite; in other words, an algorithm
that has a guarantee with respect to A has a guarantee that
can be arbitrarily better than that with constant B. Thus,
the overall best concentrability constant is CÏ€âˆ— , while the
worst are C (2,1,0) and C (2,m,0) . To make the picture complete, we should add that for any MDP and any distribution
Âµ, it is possible to find an input distribution Î½ for the algorithm (recall that the concentrability coefficients depend on
Î½ and Âµ) such that CÏ€âˆ— is finite, though it is not the case for
(1)
CÏ€âˆ— (and as a consequence all the other coefficients). The
derivation of this order relations is done in Appendix B.
The standard API algorithm has guarantees expressed in
terms of C (2,1,0) and C (1,0) only. Since CPIâ€™s analysis can
be done with respect to CÏ€âˆ— , it has a performance guarantee that can be arbitrarily better than that of API, though the
opposite is not true. This, however, comes at the cost of an
exponential increase of time complexity since CPI
 may require a number of iterations that scales inO 12 , while the
guarantee of API only requires O log 1 iterations. When
the analysis of CPI is relaxed so that the performance guarantee is expressed in terms of the (worse) coefficient C (1,0)
(obtained
 also for API), we can slightly improve the rateâ€”
to OÌƒ 1 â€”, though it is still exponentially slower than that
of API. This second result for CPI was proved with a technique that was also used for CPI(Î±) and API(Î±). We conjecture that it can be improved for CPI(Î±), that should be
as good as CPI when Î± is sufficiently small.
PSDPâˆ enjoys two guarantees that have a fast rate like
those of API. One bound has a better dependency with re1
spect to 1âˆ’Î³
, but is expressed in terms of the worse coeffi(1)

cient CÏ€âˆ— . The second guarantee is almost as good as that

Approximate Policy Iteration Schemes: A Comparison

of CPI since it only contains an extra log 1 term, but it has
the nice property that it holds quickly with respect to : in
time O(log 1 ) instead of O( 12 ), that is exponentially faster.
PSDPâˆ is thus theoretically better than both CPI (as good
but faster) and API (better and as fast).
Now, from a practical point of view, PSDPâˆ and CPI need
to store all the policies generated from the start. The memory required by these algorithms is thus proportional to the
number of iterations. Even if PSDPâˆ may require much
fewer iterations than CPI, the corresponding memory requirement may still be prohibitive in situations where  is
small or Î³ is close to 1. We explained that NSPI(m) can be
seen as making a bridge between API and PSDPâˆ . Since
(i) both have a nice time complexity, (ii) API has the best
memory requirement, and (iii) NSPI(m) has the best performance guarantee, NSPI(m) is a good candidate for making a standard performance/memory trade-off. If the first
two bounds of NSPI(m) in Table 1 extends those of API,
the other two are made of two terms: the left terms are identical to those obtained for PSDPâˆ , while the two possible
right terms are new, but are controlled by Î³ m , which can
thus be made arbitrarily small by increasing the memory
parameter m. Our analysis thus confirms our intuition that
NSPI(m) allows to make a performance/memory trade-off
in between API (small memory) and PSDPâˆ (best performance). In other words, as soon as memory becomes a
constraint, NSPI(m) is the natural alternative to PSDPâˆ .

4. Experiments
In this section, we present some experiments in order to illustrate the empirical behavior of the different algorithms
discussed in the paper. We considered the standard API as
a baseline. CPI, as it is described by Kakade & Langford
(2002), is very slow (in one sample experiment on a 100
state problem, it made very slow progress and took several
millions of iterations before it stopped) and we did not evaluate it further. Instead, we considered two variations: CPI+
that is identical to CPI except that it chooses the step Î±k
at each iteration by doing a line-search towards the policy
output by the greedy operator6 , and CPI(Î±) with Î± = 0.1,
that makes â€œrelatively but not too smallâ€ steps at each iteration. To assess the utility for CPI to use the distribution
dÎ½,Ï€ for the approximate greedy step, we also considered
API(Î±) with Î± = 0.1, the variation of API described in
Equation (4) that makes small steps, and that only differs
from CPI(Î±) by the fact that the approximate greedy step
uses the distribution Î½ instead of dÏ€k ,Î½ . In addition to these
algorithms, we considered PSDPâˆ and NSPI(m) for the
values m âˆˆ {5, 10, 30}.
6
We implemented a crude line-search mechanism, that looks
on the set 2i Î± where Î± is the minimal step estimated by CPI to
ensure improvement.

In order to assess their quality, we consider finite problems
where the exact value function can be computed. More
precisely, we consider Garnet problems first introduced by
Archibald et al. (1995), which are a class of randomly
constructed finite MDPs. They do not correspond to any
specific application, but remain representative of the kind
of MDP that might be encountered in practice. In brief,
we consider Garnet problems with |S| âˆˆ {50, 100, 200},
|A| âˆˆ {2, 5, 10} and branching factors in {1, 2, 10}. The
greedy step used by all algorithms is approximated by an
exact greedy operator applied to a noisy orthogonal projection on a linear space of dimension |S|
10 with respect to
the quadratic norm weighted by Î½ or dÎ½,Ï€ (for CPI+ and
CPI(Î±)) where Î½ is uniform.
For each of these 33 = 27 parameter instances, we generated 30 i.i.d. Garnet MDPs (Mi )1â‰¤iâ‰¤30 . For each such
MDP Mi , we ran API, API(0.1), CPI+, CPI(0.1), NSPI(m)
for m âˆˆ {5, 10, 30} and PSDPâˆ 30 times. For each run j
and algorithm, we compute for all iterations k âˆˆ (1, 100)
the performance, i.e. the loss Lj,k = Âµ(vÏ€âˆ— âˆ’ vÏ€k ) with
respect to the optimal policy. Figure 2 displays statistics
about these random variables. For each algorithm, we display a learning curve with confidence regions that account
for the variability across runs and problems. The supplementary material contains statistics that are respectively
conditioned on the values of nS , nA and b, which gives
some insight on the influence of these parameters.
From these experiments and statistics, we can make a series of observations. The standard API scheme is much
more variable than the other algorithms and tends to provide the worst performance on average. CPI+ and CPI(Î±)
display about the same asymptotic performance on average.
If CPI(Î±) has slightly less variability, it is much slower than
CPI+, that always converges in very few iterations (most of
the time less than 10, and always less than 20). API(Î±)â€”
the naive conservative variation of API that is also simpler than CPI(Î±)â€”is empirically close to CPI(Î±), while being on average slightly worse. CPI+, CPI(Î±) and PSDPâˆ
have a similar average performance, but the variability of
PSDPâˆ is significantly smaller. PSDPâˆ is the algorithm
that overall gives the best results. NSPI(m) does indeed
provide a bridge between API and PSDPâˆ . By increasing m, the behavior gets closer to that of PSDPâˆ . With
m = 30, NSPI(m) is overall better than API(Î±), CPI+, and
CPI(Î±), and close to PSDPâˆ . The above relative observations are stable with respect to the number of states nS
and actions nA . Interestingly, the differences between the
algorithms tend to vanish when the dynamics of the problem gets more and more stochastic (when the branching
factor increases). This complies with our analysis based
on concentrability coefficients: there are all finite when the
dynamics mixes a lot, and their relative difference are the
biggest in deterministic instances.

Approximate Policy Iteration Schemes: A Comparison
API

API(0.1)

0.1
80

100

0.0
0

Â¹(vÂ¼ Â¤Â¡vÂ¼k )

0.1
20

NSPI(5)

40
60
Iterations

80

100

0.0
0

Â¹(vÂ¼ Â¤Â¡vÂ¼k )

0.5

Â¹(vÂ¼ Â¤Â¡vÂ¼k )

0.6

0.5

Â¹(vÂ¼ Â¤Â¡vÂ¼k )

0.6
0.4

0.3
0.1
80

100

0.0
0

80

100

40
60
Iterations

20

80

100

80

100

80

100

0.5

0.4
0.3

0.2

0.0
0

40
60
Iterations

0.6

0.1
20

0.0
0

PSDP1

0.3

0.2

0.1
40
60
Iterations

40
60
Iterations

0.4

0.3

0.2

20

20

NSPI(30)

0.5

0.4

0.2

0.1

NSPI(10)

0.6

0.0
0

0.3

0.2

Â¹(vÂ¼ Â¤Â¡vÂ¼k )

40
60
Iterations

0.4

0.3

0.2

0.1
20

0.5

0.4

0.3

0.2

0.6

0.5

0.4

0.3

CPI(0.1)

0.6

0.5

Â¹(vÂ¼ Â¤Â¡vÂ¼k )

Â¹(vÂ¼ Â¤Â¡vÂ¼k )

0.5

0.4

0.0
0

CPI+ (line search)

0.6

Â¹(vÂ¼ Â¤Â¡vÂ¼k )

0.6

0.2

0.1
20

40
60
Iterations

80

100

0.0
0

20

40
60
Iterations

Figure 2. Statistics for all instances. The MDPs (Mi )1â‰¤iâ‰¤30 are i.i.d. with the same distribution as M1 . Conditioned on some
MDP Mi and some algorithm, the error measures at all iteration k are i.i.d. with the same distribution as L1,k . The central line of
the learning curves gives the empirical estimate of the overall average error (E[L1,k ])k . The three grey regions (from dark to light
grey) are estimates of respectively the variability (across MDPs) of the average error (Std[E[L1,k |M1 ]])k , the average (across MDPs)
of the standard deviation of the error (E[Std[L1,k |M1 ]])k , and the variability (across MDPs) of the standard deviation of the error
(Std[Std[L1,k |M1 ]])k . For ease of comparison, all curves are displayed with the same x and y range.

5. Discussion, Summary and Future Work
We have considered several variations of the Policy Iteration schemes for infinite-horizon problems: API, CPI,
NSPI(m), API(Î±) and PSDPâˆ 7 . We have in particular
explained the factâ€”to our knowledge so far unknownâ€”
that the recently introduced NSPI(m) algorithm generalizes
API (that is obtained when m=1) and PSDPâˆ (that is very
similar when m = âˆ). Figure 1 synthesized the theoretical
guarantees about these algorithms. Most of the bounds are
to our knowledge new.
One of the first important message of our work is that
what is usually hidden in the constants of the performance
bounds does matter. The constants involved in the bounds
for API, CPI, PSDPâˆ and for the main (left) terms of
NSPI(m) can be sorted from the worst to the best as fol(1)
lows: C (2,1,0) , C (1,0) , CÏ€âˆ— , CÏ€âˆ— . A detailed hierarchy of
all constants was depicted in Figure 1. This is to our knowledge the first time that such an in-depth comparison of
the bounds is done, and our hierarchy of constants has interesting implications that go beyond the Policy Iteration
schemes we have been focusing on in this paper. As a
matter of fact, several other dynamic programming algorithms, namely AVI (Munos, 2007), Î»PI (Scherrer, 2013),
AMPI (Scherrer et al., 2012), come with guarantees involv7

We recall that to our knowledge, the use of PSDPâˆ (PSDP
in an infinite-horizon context) is not documented in the literature.

ing the worst constant C (2,1,0) , which suggests that they
should not be competitive with the best algorithms we have
described here.
At the purely technical level, several of our bounds come
in pair; this is due to the fact that we have introduced a new
proof technique. This led to a new bound for API, that improves the state of the art in the sense that it involves the
constant C (1,0) instead of C (2,1,0) . It also enabled us to derive new bounds for CPI (and its natural algorithmic variant
CPI(Î±)) that is worse in terms of guarantee but has a better
time complexity (OÌƒ( 1 ) instead of O( 12 )). We believe this
new technique may be helpful in the future for the analysis
of other MDP algorithms.
Let us sum up the main insights of our analysis. 1) The
guarantee for CPI can be arbitrarily stronger than that of
API/API(Î±), because it is expressed with respect to the best
concentrability constant CÏ€âˆ— , but this comes at the cost of
a relativeâ€”exponential in 1 â€”increase of the number of iterations. 2) PSDPâˆ enjoys the best of both worlds: its
performance guarantee is similar to that of CPI, but within
a number of iterations similar to that of API. 3) Contrary to
API that requires a constant memory, the memory needed
by CPI and PSDPâˆ is proportional to their number of iterations, which may be problematic in particular when the
discount factor Î³ is close to 1 or the approximation error 
is close to 0; we showed that the NSPI(m) algorithm allows
to make an overall trade-off between memory and perfor-

Approximate Policy Iteration Schemes: A Comparison

mance.
The main assumption of this work is that all algorithms
have at disposal an -approximate greedy operator. It may
be unreasonable to compare all algorithms on this basis,
since the underlying optimization problems may have different complexities: for instance, methods like CPI look in
a space of stochastic policies while API moves in a space of
deterministic policies. Digging and understanding in more
depth what is potentially hidden in the term â€”as we have
done here for the concentrability constantsâ€”constitutes a
very natural research direction.
Last but not least, we have run numerical experiments that
support our worst-case analysis. On simulations on about
800 Garnet MDPs with various characteristics, CPI(Î±),
CPI+ (CPI with a crude line-search mechanism), PSDPâˆ
and NSPI(m) were shown to always perform significantly
better than the standard API. CPI+, CPI(Î±) and PSDPâˆ
performed similarly on average, but PSDPâˆ showed much
less variability and is thus the best algorithm in terms of
overall performance. Finally, NSPI(m) allows to make a
bridge between API and PSDPâˆ , reaching an overall performance close to that of PSDPâˆ with a controlled memory. Implementing other instances of these algorithmic
schemes, running and analyzing experiments on bigger domains constitutes interesting future work.

Âµ(vÏ€âˆ— âˆ’ vÏƒk ) â‰¤

kâˆ’1
X

Âµ(Î³PÏ€âˆ— )i ekâˆ’i + Î³ k Vmax

i=0

â‰¤

k
C Ï€âˆ— X
i + Î³ k Vmax
1 âˆ’ Î³ i=1

and the other bound is obtained by using the fact that
Pk
vÏƒk ... â‰¥ vÏƒk âˆ’ Î³ k Vmax , i=1 i â‰¤ k, and considering
l 2Vmax m
log

.
the number of iterations k =
1âˆ’Î³
API/NSPI(m): API is identical to NSPI(1), and its
bounds are particular cases of the first two bounds for
NSPI(m), so we only consider NSPI(m). By following
the proof technique of Scherrer & Lesner (2012), writing Î“k,m = (Î³PÏ€k )(Î³PÏ€kâˆ’1 ) Â· Â· Â· (Î³PÏ€kâˆ’m+1 ) and ek+1 =
maxÏ€0 TÏ€0 vÏ€k,m âˆ’ TÏ€k+1 vÏ€k,m , one can show that:
vÏ€âˆ— âˆ’ vÏ€k,m â‰¤

kâˆ’1
X

(Î³PÏ€âˆ— )i (I âˆ’ Î“kâˆ’i,m )âˆ’1 ekâˆ’i + Î³ k Vmax .

i=0

Multiplying both sides by Âµ (and observing that ek â‰¥ 0)
and the fact that Î½ej â‰¤ j â‰¤ , we obtain:

A. Proofs for Table 1
PSDPâˆ :

Starting back in Equation (7) and using the definition of
CÏ€âˆ— (in particular the fact that for all i, Âµ(Î³PÏ€âˆ— )i â‰¤
CÏ€âˆ—
1
âˆ—
1âˆ’Î³ dÏ€ ,Âµ â‰¤ 1âˆ’Î³ Î½) and the fact that Î½ej â‰¤ j , we get:

Âµ(vÏ€âˆ— âˆ’ vÏ€k )

For all k, we have

vÏ€âˆ— âˆ’ vÏƒk = TÏ€âˆ— vÏ€âˆ— âˆ’ TÏ€âˆ— vÏƒkâˆ’1 + TÏ€âˆ— vÏƒkâˆ’1 âˆ’ TÏ€k vÏƒkâˆ’1

â‰¤

kâˆ’1
X

Âµ(Î³PÏ€âˆ— )i (I âˆ’ Î“kâˆ’i,m )âˆ’1 ekâˆ’i + Î³ k Vmax (8)

i=0

â‰¤ Î³PÏ€âˆ— (vÏ€ âˆ’ vÏƒkâˆ’1 ) + ek
â‰¤

where we defined ek = maxÏ€0 TÏ€0 vÏƒkâˆ’1 âˆ’ TÏ€k vÏƒkâˆ’1 . As
PÏ€âˆ— is non negative, we deduce by induction:
vÏ€âˆ— âˆ’ vÏƒk â‰¤

kâˆ’1
X

kâˆ’1
X
i=0

â‰¤

(Î³PÏ€âˆ— )i ekâˆ’i + Î³ k Vmax .

ï£«
ï£¶
âˆ
X
ï£­
Î³ i+jm c(i + jm)kâˆ’i ï£¸ + Î³ k Vmax

(9)

j=0

kâˆ’1
âˆ
XX

Î³ i+jm c(i + jm) + Î³ k Vmax ,

(10)

i=0 j=0

i=0

By multiplying both sides by Âµ, using the definition of the
coefficients cÏ€âˆ— (i) and the fact that Î½ej â‰¤ j â‰¤ , we get:
kâˆ’1
X

Âµ(vÏ€âˆ— âˆ’ vÏƒk ) â‰¤

Âµ(Î³PÏ€âˆ— )i ekâˆ’i + Î³ k Vmax

(7)

l 2Vmax m
log

.
which leads to the first bound by taking k â‰¥
1âˆ’Î³
Starting back on Equation (9), assuming for simplicity that
âˆ’k = 0 for all k â‰¥ 0, we get:
Âµ(vÏ€âˆ— âˆ’ vÏ€k ) âˆ’ Î³ k Vmax

i=0
kâˆ’1
X

â‰¤

â‰¤

Î³ i cÏ€âˆ— (i)kâˆ’i + Î³ k Vmax

l=0

i=0
kâˆ’1
X

â‰¤

â‰¤

Î³ i cÏ€âˆ— (i)  + Î³ k Vmax .

h=0 j=0

d X e mâˆ’1
âˆ
XX
l=0

(1)

The bound with respect to CÏ€âˆ— is obtained by using
the fact
m
l
that vÏƒk ... â‰¥ vÏƒk âˆ’ Î³ Vmax and taking k â‰¥

Î³ h+(l+j)m c(h + (l + j)m)kâˆ’hâˆ’lm

kâˆ’1
m

!

i=0

k

kâˆ’1
dX
âˆ
m e mâˆ’1
XX

log 2Vmax

1âˆ’Î³

.

â‰¤

kâˆ’1
dX
âˆ
m e mâˆ’1
XX

l=0

Î³ h+jm c(h + jm)

h=0 j=0

max
kâˆ’(l+1)m+1â‰¤pâ‰¤kâˆ’lm

h=0 j=l

Î³ h+jm c(h + jm)

max
kâˆ’(l+1)m+1â‰¤pâ‰¤kâˆ’lm

p

p

Approximate Policy Iteration Schemes: A Comparison

=

mâˆ’1
âˆ
XX

Î³

h+jm

! d kâˆ’1
m e
X
c(h + jm)

h=0 j=0

l=0

max
lâˆ’(l+1)m+1â‰¤pâ‰¤kâˆ’lm

p

ing a MDP on N where Ï€âˆ— induces a deterministic transition
from state i to state i + 1.
(1)

â‰¤

âˆ
X

Î³ i c(i)

!

i=0

(1)

CÏ€âˆ— â†’ C (1,0) : (i) We have CÏ€âˆ— â‰¤ C (1,0) because for

kâˆ’1
,
m

(11)

leads
to the second bound by taking k =
l which
m
log 2Vmax

. Last but not least, starting back on Equa1âˆ’Î³
tion (8), and using the fact that (I âˆ’ Î“kâˆ’i,m )âˆ’1 = I +
Î“kâˆ’i,m (I âˆ’ Î“kâˆ’i,m )âˆ’1 we see that:
k

Âµ(vÏ€âˆ— âˆ’ vÏ€k ) âˆ’ Î³ Vmax â‰¤

kâˆ’1
X

(1)

all i, cÏ€âˆ— (i) â‰¤ c(i). (ii) It is easy to obtain CÏ€âˆ— < âˆ and
(1)
C (1,0) = âˆ since CÏ€âˆ— only depends on one policy while
(1)
CÏ€âˆ— depends on all policies.
C (1,0) â†’ C (2,m,0) and C (1,m) â†’ C (2,m,m) : (i)
1
(2,m,m)
holds because
C (1,m) â‰¤ 1âˆ’Î³
mC
âˆ

i

Âµ(Î³PÏ€âˆ— ) ekâˆ’i +

âˆ

i=0

+

kâˆ’1
X

=

Âµ(Î³PÏ€âˆ— )i Î“kâˆ’i,m (I âˆ’ Î“kâˆ’i,m )âˆ’1 ekâˆ’i .

i=0

The first term of the r.h.s. can be bounded exactly as for
PSDPâˆ . For the second term, we have:
kâˆ’1
X

Âµ(Î³PÏ€âˆ— )i Î“kâˆ’i,m (I âˆ’ Î“kâˆ’i,m )âˆ’1 ekâˆ’i

i=0

â‰¤

kâˆ’1
âˆ
XX

Î³

i+jm

c(i + jm)kâˆ’i

i=0 j=1

= Î³m

kâˆ’1
âˆ
XX

Î³ i+jm c(i + (j + 1)m)kâˆ’i ,

âˆ

X i
X X i+jm
C (1,m)
=
Î³ c(i + m) â‰¤
Î³
c(i + (j + 1)m)
1âˆ’Î³
i=0
i=0 j=0
1
C (2,m,m) .
(1 âˆ’ Î³)(1 âˆ’ Î³ m )

(ii) One may have C (1,m) < âˆ and C (2,m,m) = âˆ when
c(i) = Î˜( i21Î³ i ), since the generic term of C (1,m) is Î˜( i12 )
(the sum converges) while that of C (2,m,m) is Î˜( 1i ) (the
sum diverges). The reasoning is similar for the other relation.
C (1,m) â†’ C (1,0) and C (2,m,m) â†’ C (2,m,0) : We here
assume that m < âˆ. (i) We have C (1,m) â‰¤ Î³1m C (1,0) and
C (2,m,m) â‰¤ Î³1m C (2,m,0) . (ii) It suffices that c(j) = âˆ for
some j < m to have C (2,m,0) = âˆ while C (2,m,m) < âˆ,
or to have C (1,0) = âˆ while C (1,m) < âˆ.

i=0 j=0

and we follow the same lines as above (from Equation (9)
to Equations (10) and (11)) to conclude.
CPI, CPI(Î±), API(Î±): Conservative steps are addressed
by a tedious generalization of the proof for API by Munos
(2003). Due to lack of space, the proof is deferred to the
Supplementary Material.

B. Proofs for Figure 1
We here provide details on the order relation for the concentrability coefficients.
(1)

C (2,1,0)
â†” C (2,m,0) : (i) We clearly have C (2,m,0) â‰¤
1âˆ’Î³ m (2,1,0)
. (ii) C (2,m,0) can be rewritten as follows:
1âˆ’Î³ C
C (2,m,0) = (1 âˆ’ Î³)(1 âˆ’ Î³ m )
Then, using the fact that 1 +

â‰¥

â‰¥
Î³ i Âµ(PÏ€âˆ— )i

mâˆ’1
X

mâˆ’1
X
i=0

Î³ i cÏ€âˆ— (i)Î½ = CÏ€(1)
Î½
âˆ—

i=0

and CÏ€âˆ— is the smallest coefficient C satisfying dÏ€âˆ— ,Âµ â‰¤
(1)
CÎ½. (ii) We may have CÏ€âˆ— < âˆ and CÏ€âˆ— = âˆ by design-

m



Î³ i c(i).


â‰¥ max 1, mi , we have

Î³ i c(i) +

âˆ
X
i i
Î³ c(i)
m
i=m

Î³ i c(i) +

âˆ
m X i+1 i
Î³ c(i)
m + 1 i=m m

i=0

=
â‰¤ (1 âˆ’ Î³)

mâˆ’1
X
i=0

i=0
âˆ
X

i

i
m



âˆ
X
1 âˆ’ Î³ (2,m,0)
i
C
â‰¥
max
1,
Î³ i c(i)
1 âˆ’ Î³m
m
i=0

(1)

dÏ€âˆ— ,Âµ = (1 âˆ’ Î³)Âµ(I âˆ’ Î³PÏ€âˆ— )âˆ’1 = (1 âˆ’ Î³)


1+

i=0

CÏ€âˆ— â†’ CÏ€âˆ— : (i) We have CÏ€âˆ— â‰¤ CÏ€âˆ— because
âˆ
X

âˆ 
X

=

m
Î³ c(i) +
m+1
i

C

(2,1,0)

âˆ’

mâˆ’1
X

!
i

Î³ c(i)

i=0

mâˆ’1
m
1 X i
C (2,1,0) +
Î³ c(i).
m+1
m + 1 i=0

Thus, when m is finite, C (2,m,0) < âˆ â‡’ C (2,1,0) < âˆ.

Approximate Policy Iteration Schemes: A Comparison

References
Archibald, T., McKinnon, K., and Thomas, L. On the Generation of Markov Decision Processes. Journal of the
Operational Research Society, 46:354â€“361, 1995.
Bagnell, J.A., Kakade, S.M., Ng, A., and Schneider, J. Policy search by dynamic programming. In NIPS, 2003.
Bertsekas, D.P. and Tsitsiklis, J.N. Neuro-Dynamic Programming. Athena Scientific, 1996.
Farahmand, A.M., Munos, R., and SzepesvaÌri, Cs. Error
propagation for approximate policy and value iteration
(extended version). In NIPS, 2010.
Ghavamzadeh, M. and Lazaric, A. Conservative and
Greedy Approaches to Classification-based Policy Iteration. In AAAI, 2012.
Kakade, Sham and Langford, John. Approximately optimal
approximate reinforcement learning. In ICML, 2002.
Lagoudakis, M. and Parr, R. Reinforcement Learning as
Classification: Leveraging Modern Classifiers. In ICML,
2003a.
Lagoudakis, M.G. and Parr, R. Least-squares policy iteration. Journal of Machine Learning Research (JMLR), 4:
1107â€“1149, 2003b.
Lazaric, A., Ghavamzadeh, M., and Munos, R. Analysis
of a Classification-based Policy Iteration Algorithm. In
ICML, 2010.
Munos, R. Error Bounds for Approximate Policy Iteration.
In ICML, 2003.
Munos, R. Performance Bounds in Lp norm for Approximate Value Iteration. SIAM J. Control and Optimization,
2007.
Puterman, M. Markov Decision Processes. Wiley, New
York, 1994.
Scherrer, B. Performance Bounds for Lambda Policy Iteration and Application to the Game of Tetris. Journal of
Machine Learning Research, 14:1175â€“1221, 2013.
Scherrer, B. and Lesner, B. On the Use of Non-Stationary
Policies for Stationary Infinite-Horizon Markov Decision Processes. In NIPS, 2012.
Scherrer, Bruno, Ghavamzadeh, Mohammad, Gabillon,
Victor, and Geist, Matthieu. Approximate Modified Policy Iteration. In ICML, 2012.

