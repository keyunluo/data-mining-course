Bias in Natural Actor-Critic Algorithms

Philip S. Thomas
School of Computer Science, University of Massachusetts, Amherst, MA 01002 USA

Abstract
We show that several popular discounted reward
natural actor-critics, including the popular NACLSTD and eNAC algorithms, do not generate unbiased estimates of the natural policy gradient as
claimed. We derive the first unbiased discounted
reward natural actor-critics using batch and iterative approaches to gradient estimation. We argue
that the bias makes the existing algorithms more
appropriate for the average reward setting. We
also show that, when Sarsa(Î») is guaranteed to
converge to an optimal policy, the objective function used by natural actor-critics has only global
optima, so policy gradient methods are guaranteed to converge to globally optimal policies as
well.

1. Introduction
Natural actor-critics are an increasingly popular class
of algorithms for finding locally optimal policies for
continuous-action Markov decision processes (MDPs). We
show that the existing discounted natural actor-critic algorithms (Degris et al., 2012; Peters & Schaal, 2006; 2008)
do not produce unbiased estimates of the natural policy
gradient as sometimes purported (Peters & Schaal, 2006;
2008), since they are missing a Î³ t term. Some algorithms
do not claim to follow unbiased estimates of the natural
policy gradient (Degris et al., 2012), however they are still
missing the term, which results in additional bias.
Although the missing term is just a Î³ t , we argue that it
has significant ramifications, beyond voiding some convergence guarantees. We prove that, for a set of Markov
decision processes, these biased discounted reward natural actor-critics are actually unbiased average reward natural actor-critics. We derive the first unbiased discountedreward natural actor-critics, but we argue that our unbiased algorithms are not practical, and only support their
Proceedings of the 31 st International Conference on Machine
Learning, Beijing, China, 2014. JMLR: W&CP volume 32. Copyright 2014 by the author(s).

PTHOMAS @ CS . UMASS . EDU

use when maximization of the discounted-reward objective
is imperative. The goal of this paper is to raise awareness
about what the algorithms that are in use are actually doing,
not to present a superior method.
We also address a common misconception about policy
gradient algorithmsâ€”that they are inferior to algorithms
like Sarsa(Î») because they are local methods that can become stuck at arbitrarily bad locally optimal policies. We
prove that, in all of the settings where Sarsa(Î») is guaranteed to reach a globally optimal policy, the average and
discounted-reward objective functions have only global optima, and hence policy gradient methods also converge to
globally optimal policies.

2. Problem
We are interested in the problem of finding locally optimal
policies for Markov decision processes (MDPs). An MDP
is a tuple, (S, A, P, R, d0 , Î³). S and A denote the sets of
possible states and actions, which may be countable (discrete), or uncountable (continuous).1 P is called the trana
0
sition function, where Pss
0 = Pr(st+1 =s |st =s, at =a),
0
0
where t âˆˆ N denotes the time step, s, s âˆˆ S and a âˆˆ A.
Ras is the expected value of the scalar reward, rt , when action a is taken in state s, i.e., Ras = E[rt |st = s, at = a].
We assume that rt âˆˆ [âˆ’rmax , rmax ] for some uniformly
bounding constant rmax . The initial state distribution is
d0 , where d0 (s) = Pr(s0 =s), and Î³ âˆˆ [0, 1] is a discount
factor. A parameterized policy, Ï€, is a distribution over actions given a state and parameter vector Î¸ âˆˆ Rn . That is,
Ï€(s, a, Î¸) = Pr(at =a|st =s, Î¸). We assume that, for all s,
a, and Î¸, Ï€(s, a, Î¸) is differentiable with respect to Î¸.
The state value function, V Î¸ , when using policy parameters Î¸, is a function that gives the expected sum
of discounted reward (or expected discounted return)
that would be accrued from a state, s, when following the policy with parameters Î¸. That is, V Î¸ (s) =
1
We abuse notation by writing summations and probabilities
over S and A. If these sets are continuous, the summations and
probabilities should be replaced with integrals and probability
densities. We also treat st and at as random variables or observed
values depending on context.

Bias in Natural Actor-Critic Algorithms

Pâˆž
E[ t=0 Î³ t rt |s0 =s, Î¸]. Similarly,
the state-action value
Pâˆž
function is QÎ¸ (s, a) = E[ t=0 Î³ t rt |s0 =s, a0 =a, Î¸]. The
discounted state distribution, dÎ¸ , gives the probability of
each state when using policy parameters Î¸, with a disÎ¸
count applied
Pâˆž tot states that occur at later times: d (s) =
(1 âˆ’ Î³) t=0 Î³ Pr(st =s|s0 , Î¸). The objective function,
J : Rn â†’ R, gives the expected discounted return
for using the
Pâˆžprovided policy parameters for one episode:
J(Î¸) = E[ t=0 Î³ t rt |Î¸], where an episode is one sequence
of states, actions, and rewards, starting from a state sampled from d0 and following the dynamics specified by P
and R.
We call an MDP episodic if there is one or more state in
which the process terminates, and, for all policies, every
episode reaches a terminal state within some finite time,
T . To model episodic MDPs in a unified manner with nonepisodic MDPs, we assume that there is only one admissible action in terminal states, and it causes a transition to
an absorbing state with zero reward, which we call a postterminal absorbing state. This absorbing state also has
only one admissible action, which causes a self-transition
with zero reward. We allow Î³ = 1 only when the MDP is
episodic.2
If S and A are discrete, then the goal is to find a policy parameter vector that maximizes J. If S or A is continuous,
we search for locally optimal policy parameters, Î¸âˆ— , that is,
parameters satisfying âˆ‡J(Î¸âˆ— ) = 0.

3. Policy Gradient
Gradient ascent algorithms for maximizing J are called
policy gradient algorithms. Their basic update is Î¸t+1 =
Î¸t + Î±t âˆ‡J(Î¸t ), where {Î±t } is a scalar step size schedule.
Policy gradient methods may also use unbiased estimates
of the gradient, making them stochastic gradient ascent
algorithms. Gradient ascent is guaranteed to converge to
a local maximum
Pâˆž if J continuously
Pâˆž differentiable, âˆ‡J is
Lipschitz, t=0 Î±t = âˆž, and t=0 Î±t2 < âˆž (Bertsekas
& Tsitsiklis, 2000). We assume that these constraints are
satisfied.
The policy gradient, âˆ‡J(Î¸), is the direction âˆ†Î¸ that maximizes J(Î¸+âˆ†Î¸) subject to kâˆ†Î¸k2 = 2 , for infinitesimally
small , where kÂ·k denotes the Euclidean (L2 ) norm. Amari
(1998) suggested that Riemannian distance may be a more
appropriate metric than Euclidean distance for parameter
space. He calls the direction satisfying this modified constraint the natural gradient. Kakade (2002) suggested the
application of natural gradients to policy gradients to get
the natural policy gradient. Bagnell & Schneider (2003)
2
If Î³ = 1, we modify the sum in the definition of dÎ¸ to sum to
T rather than âˆž.

then derived a proper Reimannian distance metric,3 based
on Amari and Kakadeâ€™s work, and showed that the natural
policy gradient is covariant. Bhatnagar et al. (2009) built on
this foundation to create several provably convergent policy gradient and natural policy gradient algorithms for the
average reward setting.
Let f$ (s, a) = $| Ïˆsa be a linear function approximator
with weight vector $ = [w| , v | ]| , where |w| = |Î¸|, and
âˆ‚
log Ï€(s, a, Î¸))| , Ï†(s)| ]| , for arfeature vector Ïˆsa = [( âˆ‚Î¸
bitrary uniformly bounded Ï†. If

 âˆ‚f$ (s, a)
= 0,
dÎ¸ (s)Ï€(s, a, Î¸) QÎ¸ (s, a) âˆ’ f$ (s, a)
âˆ‚$
s,a
(1)
e
then the natural policy gradient is âˆ‡J(Î¸)
= w (Kakade,
2002).4
X

4. Finding w
To find w that satisfy (1), Sutton et al. (2000), working in
the |v| = 0 setting, suggest letting f$ : S Ã— A â†’ R be an
approximation to QÎ¸ with parameter vector $ = w. They
claim that learning f$ by following Ï€(s, Â·, Î¸) and updating
âˆ‚
$ by a rule such as âˆ†$t âˆ âˆ‚$
[QÌ‚Î¸ (st , at ) âˆ’ f$ (st , at )]2 ,
Î¸
where QÌ‚ (s, a) is some unbiased estimate of QÎ¸ (s, a), will
result in satisfactory w. However, this is only true for
the average reward setting or the discounted setting when
Î³ = 1 because, in the discounted setting, dÎ¸ in (1) is
the discounted weighting of states encountered, whereas
the states observed when merely following Ï€(s, Â·, Î¸) come
from the undiscounted state distribution.
Peters & Schaal (2006; 2008) observed that the scheme
proposed by Sutton et al. (2000) is a forward TD(1) algorithm. Because forward and backward TD(Î») are approximately equivalent, they suggest using least squares temporal difference (LSTD), a backwards TD(Î») method, to
approximate QÎ¸ with f$ , where Î» = 1. They call the
resulting algorithms the natural actor-critic using LSTD
(NAC-LSTD) and the episodic natural actor-critic (eNAC).
Because the scheme proposed by Sutton et al., and thus
TD(1), does not incorporate the Î³ t weighting in the discounted state distribution, this results in w that do not sat3

Recent work has proposed the use of a different metric that
accounts not only for how the distribution over actions (the policy) changes as the parameters change, but also for how the state
distribution changes as the parameters change (Morimura et al.,
2009).
4
Notice that if |Ï†(s)| = 0, we can drop v from Equation (1) to
get the exact constraint specified by Sutton et al. (2000). Equation
P
(s,a)
(1) follows immediately since a Ï€(s, a, Î¸)v | Ï†(s) âˆ‚f$âˆ‚$
=0
|
for all s, Î¸, Ï†, and $. We include the baseline, v Ï†(s), since it
can reduce the variance of gradient estimates (Sutton et al., 2000).
Also, for simplicity later, we assume that Ï†(s) = 0 for the postterminal absorbing state.

Bias in Natural Actor-Critic Algorithms

isfy (1), and thus bias in the natural policy gradient estimates. Natural actor-critic algorithms that do not include
the Î³ t term continue to be published (Degris et al., 2012).
One solution would be to convert the discounted MDP into
an equivalent undiscounted MDP (Bertsekas & Tsitsiklis,
1996). To do this, each observed trajectory must be truncated after each transition with probability 1 âˆ’ Î³. Notice that NAC-LSTD is not biased when Î³ = 1, because
then the discounted and undiscounted state distributions are
identical.5 So, after the trajectories are truncated, the existing NAC-LSTD algorithm could be used with Î³ = 1 to
find a policy for the original MDP. However, this approach
may discard significant amounts of data when truncating
episodes. Instead, we propose the use of all of the observed
data with proper discounting in order to produce unbiased
gradient estimates.
We present a new objective function, H, and prove that
the local minima of this objective give w satisfying (1). We
then provide the stochastic gradient descent updates for this
objective. When using policy parameters Î¸, the discounting
from the discounted state distribution can be shifted into
the objective function in order to properly satisfy (1). We
select a w that is a component of a local minimum for the
objective function H:
H($) =

âˆž X
X

Pr (st = s|Î¸)

t=0 s
 t

X

Ï€(s, a, Î¸)Ã—

a


2
Î³
QÎ¸ (s, a) âˆ’ f$ (s, a)
(2)
2
 t
âˆž
2 
X
Î³
Î¸
Es,a
QÌ‚ (s, a) âˆ’ f$ (s, a)
,
=
2
t=0
where Ã— denotes scalar-scalar multiplication split across
two lines. This objective function is always finite because
either Î³ < 1 or the MDP is episodic. If the MDP is
episodic, it must enter the post-terminal absorbing state
within a finite number of steps. In this state, Ïˆs,a = 0,
and QÎ¸ (s, a) = 0 for all Ï€ and the one admissible a,
2
P
so a Ï€(s, a, Î¸)Î³ t QÎ¸ (s, a) âˆ’ f$ (s, a) = 0 for all $.
Hence, if the MDP is episodic, only a finite number of
terms in the infinite sum will be non-zero.
We propose performing stochastic gradient descent on H
âˆ‚
to obtain a local minimum where âˆ‚$
H($) = 0:
0=

âˆž
XX
s

t=0

Î³ t Pr(st = s|Î¸)

X

Ï€(s, a, Î¸)Ã—

a

 Î¸
 âˆ‚f$ (s, a)
Q (s, a) âˆ’ f$ (s, a)
.
âˆ‚$
5

It is unclear whether eNAC would be unbiased in this situation, as described in Section 6.

By the definition of dÎ¸ , this is equivalent to (1). Hence,
when gradient descent on H has converged, the resulting w
component of $ satisfies (1). Notice that the expectation in
(2) is over the observed probabilities of states and actions at
time t when using Î¸. Hence, we can update $ via stochastic
gradient descent:
$ â†$ + Î·t Ã—
(3)
âˆž
i âˆ‚f (s , a )
Xh 
$ t t
Î³ t QÌ‚Î¸ (st , at ) âˆ’ f$ (st , at )
,
âˆ‚$
t=0
where QÌ‚Î¸ is an unbiased estimate of QÎ¸ and {Î·t } is a
step size schedule that satisfies the typical decay constraints. The substitution of QÌ‚Î¸ for QÎ¸ does not influence convergence (Bertsekas & Tsitsiklis, 2000). Because
âˆ‚f$ (s, a)/âˆ‚$ is zero for terminal states and the postterminal absorbing state, the above update need only be
performed for the pre-terminal states. With |v| = 0, this
differs from the method proposed by Sutton et al. (2000)
only by the sum over time and the Î³ t term.

5. Algorithms and Convergence
A simple algorithm to find w would be to execute episodes
and then perform the update
Pâˆž inÏ„ (3) using the Monte Carlo
return, QÌ‚Î¸ (st , at ) =
Ï„ =0 Î³ rt+Ï„ , as the unbiased estimate of QÎ¸ (st , at ). This is a forward TD(1) algorithm,
with an additional discount applied to updates based on
the time at which they occur. However, this algorithm requires that entire trajectories be stored in memory. To overcome this, we can derive the equivalent backwards update
by following Sutton and Bartoâ€™s derivation of backwards
TD(Î») (Sutton & Barto, 1998).
The resulting on-policy backwards algorithm for estimating QÎ¸ for a fixed policy parameter vector Î¸ is:
âˆ‚f$ (st , at )
âˆ‚$
Î´t =rt + Î³f$ (st+1 , at+1 ) âˆ’ f$ (st , at )

et+1 =Î³Î»et + Î³ t

$t+1 =$t + Î·t Î´t et+1 ,
where Î» is a decay parameter for eligibility traces as in
TD(Î») and st , at , and rt come from using policy parameter
vector Î¸. Although the backwards and forward algorithms
are only approximately equivalent (Sutton & Barto, 1998),
their convergence guarantees are the same (Bertsekas &
Tsitsiklis, 1996). Hence, if Î» = 1 and Î·t is decayed appropriately, the modified backwards TD(Î») algorithm above
will produce w satisfying (1). The only difference between
this algorithm and Sarsa(Î») is the Î³ t in the equation for
et+1 .
One can then reproduce the work of Bradtke & Barto
(1996) to create LSTD in this new setting, which approximates V Î¸ in a least squares manner. This can be extended

Bias in Natural Actor-Critic Algorithms

following the work of Lagoudakis & Parr (2001) to create
LSQ, which approximates QÎ¸ in a least squares manner.
The resulting LSQ algorithm in NAC-LSTD changes only
by the introduction of a Î³ t term: zt+1 = Î»zt + Î³ t Ï†Ì‚t .6
To create an episodic algorithm, we convert (1) into a
system of linear equations using the assumption that all
episodes terminate within T steps. We rewrite (1) by replacing the infinite sum in dÎ¸ with a finite one because
âˆ‚f$ (s, a)/âˆ‚$ is zero for absorbing states:
0=

T
XX
s

Pr(st = s)

Ï€(s, a, Î¸)Î³ t Ã—

a

t=0
Î¸

X

|



Q (s, a) âˆ’ $ Ïˆsa Ïˆsa = 0.
This
can be written as A$ = b, where b =
P P
T
Pr(st =s)Ï€(s, a, Î¸)Î³ t QÎ¸ (s, a)Ïˆsa and A =
s,a
P Pt=0
T
t
|
t=0 Pr(st =s)Ï€(s, a, Î¸)Î³ Ïˆsa Ïˆsa . We can then
s,a
generate unbiased estimates of A and b from sample trajectories. As the number of observed trajectories grows, our
estimates of A and b converge to their true values, giving
an unbiased estimate of the natural gradient. The resulting
episodic natural actor-critic algorithm is presented in Algorithm 1. Notice that this is different from eNAC (Peters &
Schaal, 2008), so we call it eNAC2.
For both algorithms presented, the user must select either T YPE 1 or T YPE 2 updates. In the former, which emulates the update scheme proposed by Peters & Schaal
(2008), the policy is updated when the gradient estimate
has converged, while in the latter, which emulates the
two-timescale update scheme proposed by Bhatnagar et al.
(2009), the policy is updated after a constant number of
time steps. The user must also select f (t) = Î³ t to get
the unbiased algorithm or f (t) = 1 to get the biased algorithm. The unbiased algorithms are only truly unbiased
when Î» = 1, Î² = 0 (if Î² is present), and  â†’ 0 (T YPE 1) or
k â†’ âˆž (T YPE 2), in which case they compute and ascend
the exact natural policy gradient.
NAC-LSTD and eNAC2 have computational complexity
proportional to |$|2 per time step just to update statistics, and |$|3 to compute the natural policy gradient estimate for policy improvement steps. The complexity of policy improvement steps can be improved to |$|2 using the
Sherman-Morrison formula to maintain estimates of Aâˆ’1
directly. It can be further improved to linear by using the
modified Sarsa(Î») algorithm in place of LSTD to find w
satisfying (1). We call the resulting algorithm the Natural
Actor-Critic using Sarsa(Î»), or NAC-S. Notice that some
mean zero terms can be removed from the Sarsa(Î») update
and the resulting algorithm, provided in Algorithm 2, can
be viewed as the discounted reward and eligibility trace extensions of the Natural-Gradient Actor-Critic with Advan6

This equation uses the notation of Peters & Schaal (2008).

Algorithm 1 episodic Natural Actor Critic 2â€”eNAC2
1: Input: Parameterized policy Ï€(s, a, Î¸) with initial parameters Î¸, basis functions Ï†(s) for the state-value estimation,
update frequency parameter k, discount parameter Î³, decay
constant Î², step size schedule {Î·t }, and maximum episode
duration T .
2: A â† 0;
3: b â† 0; Ï„ â† 0
4: for ep = 0, 1, 2, . . . do
5:
Run an episode and remember the trajectory,
6:
{st , at , st+1 , rt }, where t âˆˆ [0, T âˆ’ 1].
7:
Update Statistics:
P
8:
A â† A + Tt=0 f (t)Ïˆst at Ïˆs|t at
P
PT
9:
b â† b + t=0 f (t)Ïˆst at TtÌ‚=t Î³ tÌ‚âˆ’t rtÌ‚
|
| |
10:
[wep
, vep
] = (A| A)âˆ’1 A| b
11:
Update Actor (Natural Policy Gradient):

12:
if T YPE 1, ep âˆ’ k â‰¥ 0, and ](wep , wepâˆ’k ) â‰¤  or

13:
T YPE 2 and (ep + 1) mod k = 0 then
wep
14:
Î¸ â† Î¸ + Î·Ï„ ||wep
||2
15:
Ï„ = Ï„ + 1; A â† Î²A; b â† Î²b

tage Parameters (Bhatnagar et al., 2009).7 NAC-S can also
be viewed as INAC (Degris et al., 2012) or NTD (Morimura
et al., 2005) corrected to include the Î³ t term and with the
option of computing exact gradient estimates or using twotimescales.
Notice that in all algorithms presented in this paper, the
natural gradient is normalized. This normalization is optional. It may void convergence guarantees and it often
makes it difficult to achieve empirical convergence. However, in practice we find it easier to find fixed step sizes
that work on difficult problems when using normalized updates to Î¸. Amari (1998) defined the natural gradient as
only a direction and even discarded scaling constants in his
derivation of a closed form for the natural gradient.
Peters & Schaal (2008) claim that the natural actor-critics
compute and ascend the natural gradient of J, and thus
will converge to a locally optimal policy, at which point
âˆ‡J(Î¸) = 0, assuming the step size schedules are properly
decayed and that the natural actor-criticâ€™s estimates of the
natural gradient are unbiased. As stated previously, when
Î» = 1, Î² = 0 (if Î² is present), and  â†’ 0 (T YPE 1) or
k â†’ âˆž (T YPE 2), the natural gradient estimates will be exact. In practice, large k or small  and small fixed step sizes
usually result in convergence.
Policy gradient approaches are typically purported to have
one significant drawback: whereas Q-based methods converge to globally optimal policies for problems with discrete states and actions, policy gradient algorithms can become stuck in arbitrarily bad local optima (e.g., (Peters &
7

To get Bhatnagarâ€™s algorithm, select T YPE 2 updates with
k = 1, f (t) = 1, and replace the discounted TD error with the
average reward TD error.

Bias in Natural Actor-Critic Algorithms

Algorithm 2 Natural Actor Critic using Sarsa(Î»)â€”NAC-S(Î»)
1: Input: Parameterized policy Ï€(s, a, Î¸) with initial parameters Î¸, basis functions Ï†(s) for the state-value estimation,
update frequency parameter k, discount parameter Î³, eligibility decay rate Î», and step size schedules {Î±tw }, {Î±tv } and
{Î·t }.
2: w0 â† 0; v0 â† 0; count â† 0
3: for episode = 0, 1, 2, . . . do
4: Draw initial state s0 âˆ¼ d0 (Â·)
v
5: ew
âˆ’1 = 0; eâˆ’1 = 0; Ï„1 = 0; Ï„2 = 0
6: for t = 0, 1, 2, . . . do
7:
at âˆ¼ Ï€(st , Â·, Î¸); st+1 âˆ¼ P(st , at , Â·);
8:
rt â† Rastt ; count â† count + 1;
9:
Update Critic (Sarsa):
10:
Î´t = rt + Î³vt| Ï†(st+1 ) âˆ’ vt| Ï†(st )
w
âˆ‚
11:
ew
t = Î³Î»etâˆ’1 + f (t)[ âˆ‚Î¸ log Ï€(st , at , Î¸)]
v
v
12:
et = Î³Î»etâˆ’1 + f (t)Ï†(st )
w
âˆ‚
[Î´t âˆ’wt| [ âˆ‚Î¸
13:
wt+1 = wt +Î±tâˆ’Ï„
log Ï€(st , at , Î¸)]]ew
t
1
v
14:
vt+1 = vt + Î±tâˆ’Ï„1 Î´t evt
15:
Update Actor (Natural Policy Gradient):

16:
if T YPE 1, t âˆ’ k â‰¥ 0, and ](wt , wtâˆ’k ) â‰¤  or

17:
T YPE 2 and (count mod k = 0) then
wt+1
18:
Î¸ â† Î¸ + Î·Ï„2 ||wt+1
; Ï„1 = t; Ï„2 = Ï„2 + 1
||2
19:
if st+1 terminal then break out of loop over t

Bagnell, 2010; Peters, 2010)). We argue that with assumptions similar to those required by Q-learning and Sarsa,
ascending the policy gradient results in convergence to a
globally optimal policy as well.8
First, we assume that S and A are countable and that every
state-action pair is observed infinitely often. Second, we
assume that for all Î¸, all states s, and all actions a and aÌ‚,
where a 6= aÌ‚, there is a direction dÎ¸ of change to Î¸ that
causes the probability of a in state s to increase while that
of aÌ‚ decreases, while all other action probabilities remain
unchanged. These two assumptions are satisfied by policy
parameterizations such as tabular Gibbs softmax action selection (Sutton & Barto, 1998).
We argue that at all suboptimal Î¸, the policy gradient will
be non-zero. For any policy that is not globally optimal,
there exists a reachable state for which increasing the probability of a specific action a while decreasing the probability of aÌ‚ would increase J (see Section 4.2 of Sutton and
Bartoâ€™s book (Sutton & Barto, 1998)). By our first assumption, this state-action pair is reached by the policy, and by
our second assumption, there is a direction, dÎ¸, of change
to Î¸ that can make exactly this change. So, the directional
derivative of J at Î¸ in the direction dÎ¸ is non-zero and therefore the gradient of J at Î¸ must also be non-zero. Hence, Î¸
cannot be a local optimum.
Policy gradient is typically applied to problems with con8

Notice that this applies to all algorithms that ascend the policy gradient or natural policy gradient with a well-behaved metric
tensor.

tinuous state or action sets, in which case the assumptions
above cannot be satisfied, so convergence to only a local
optimum can be guaranteed. However, the above argument
suggests that, in practice and on continuous problems, local optima can be avoided by increasing exploration and
the representational power of the policy parameterization.
However, if one desires a specific low-dimensional policy parameterization, such as a proportional-derivative controller with limited exploration, then increasing the exploration and representational power of the policy may not be
an acceptable option, in which case local optima may be
unavoidable.

6. Analysis of Biased Algorithms
In this section we analyze how the bias changes performance. Recall that, without the correct discounting, w are
the weights that minimize the squared error in the QÎ¸ estimate, with states sampled from actual episodes. With the
proper discounting, states that are visited at later times factor less into w. Because w will be the change to the policy parameters, this means that in the biased algorithms the
change to the policy parameters considers states that are
visited at later times just as much as states that are visited
earlier. This suggests that the biased algorithms may be
optimizing a different objective function similar to
X
Â¯ = (1 âˆ’ Î³)
J(Î¸)
dÂ¯Î¸ (s)V Î¸ (s),
(4)
s

where dÂ¯Î¸ is the stationary distribution of the Markov chain
induced by the policy Ï€. More formally, we assume
dÂ¯Î¸ (s) = limtâ†’âˆž Pr(st = s|s0 , Î¸) exists and is independent of s0 for all policies.
Notice that JÂ¯ is not interesting for episodic MDPs since,
for all policies, dÂ¯Î¸ (s) is non-zero for only the post-terminal
absorbing state. So, henceforth, our discussion is limited
to the non-episodic setting. For
Pcomparison, we can write
J in the same form: J(Î¸) = s d0 (s)V Î¸ (s). This original objective function gives the expected discounted return
from an episode. This means that for small Î³, it barely
considers the quality of the policy at states that are visited
late in a trajectory. On the other hand, JÂ¯ considers states
based on their visitation frequency, regardless of when they
Â¯ which includes
are visited. Kakade (2001) showed that J,
Î¸
discounting in V , is the typical average reward objective
function.
To see that the biased algorithms appear to optimize something closer to this average reward objective, consider an
MDP with S = [0, 1], where s0 = 0, s = 1 is terminal,
st+1 = st +0.01, and Ras = âˆ’(aâˆ’s)2 . The optimal policy
is to select at = st . We parameterize the policy with one
parameter, such that at âˆ¼ N (Î¸, Ïƒ 2 ) for all states, where N
is a normal distribution with small constant variance, Ïƒ 2 . If

Bias in Natural Actor-Critic Algorithms
ï§=0.995

ï§=0.5
1

0.8

0.8

0.8

0.6

0.6

0.6

0.4
0.2
0
0

Action

1

Action

Action

ï§=1.0
1

0.4
0.2

0.5
State

0
0

1

QÎ¸ (s, a) and f$ (s, a). So, they select w that satisfy

Optimal
Biased
eNAC
Unbiased

0.2
0.5
State

1

0
0

0.5
State


 âˆ‚f$ (s, a)
dÂ¯Î¸ (s)Ï€(s, a, Î¸) QÎ¸ (s, a) âˆ’ f$ (s, a)
= 0.
âˆ‚$
s,a
(7)
Notice that (7) uses the discounted state-action value function while (6) uses the average reward state-action value
funciton.
X

0.4

1

Figure 1. The optimal policy (optimal), the mean action selected
by the biased NAC-LSTD, eNAC2, and INAC (biased), the mean
action selected by the unbiased NAC-LSTD, eNAC2, NAC-S, as
well as a random restart hill-climbing algorithm (unbiased), and
the mean action selected by eNAC (eNAC). Note that the mean
action is the policy parameter for each algorithm after training.

Î³ = 1, the optimal parameter, Î¸âˆ— , is Î¸âˆ— = 0.5. Both the
biased and unbiased algorithms converge to this Î¸âˆ— . However, when Î³ = 0.995 or Î³ = 0.5, the optimal Î¸âˆ— decreases
in order to receive more reward initially. We found that the
unbiased natural actor-critics properly converge to the new
optimal Î¸âˆ— , as does a simple hill-climbing algorithm that
we implemented as a control. However, the biased algorithms still converge to Î¸âˆ— â‰ˆ 0.5.9 We found that eNAC
converges to Î¸ that differ from those of all other algorithms
when Î³ 6= 1, which suggests that eNAC, but not eNAC2,
may have additional bias. These results are presented in
Figure 1.

To determine if and when the biased algorithms compute
e J(Î¸),
Â¯
âˆ‡
we must determine when a constant multiple of the
solutions to (7) satisfy (6). To do this, we solve (7) for w
and substitute a constant, k > 0, times these w into (6) to
generate a constraint that, when satisfied, results in the biased algorithms producing the same direction (but not necessarily magnitude) as the average reward natural policy
gradient. When doing so, we assume that v = 0, since it
does not influence the solutions to either equation. First, we
establish a lemma that relates the policy gradient theorem
using the average reward state distribution but discounted
reward state-action value function (left hand side of Lemma
1) to the derivative of JÂ¯ without proper application of the
chain rule:
Lemma 6.1. For all Î¸,
X
s,a

This difference raises the question of whether the biased
algorithms actually compute the natural policy gradient in
the average reward setting. In the remainder of this section,
we prove that they do whenever
X
s

V Î¸ (s)

âˆ‚ dÂ¯Î¸ (s)
= 0.
âˆ‚Î¸

âˆ‚Ï€(s, a, Î¸) Î¸
Q (s, a)
dÂ¯Î¸ (s)
âˆ‚Î¸
=(1 âˆ’ Î³)

s

Î¸

âˆ‚V
.
dÂ¯Î¸ (s)
âˆ‚Î¸

Proof.
(5)

This can happen, for example, if the distribution over states
Â¯Î¸
does not depend on the policy, in which case âˆ‚ dâˆ‚Î¸(s) = 0.
Â¯ =
The typical P
objective for average reward learning is J(Î¸)
âˆž
1
limnâ†’âˆž n t=0 E[rt |Î¸], which is equivalent to the definition in (4) (Kakade,P2001). The state-action value funcâˆž
Â¯
tion is QÌ„Î¸ (s, a) = t=0 E[rt âˆ’ J(Î¸)|s
0 = s, a0 = a, Î¸].
Kakade (2002) stated that the natural gradient of JÂ¯ is
e J(Î¸)
Â¯ = w if
âˆ‡

 âˆ‚f$ (s, a)
= 0.
dÂ¯Î¸ (s)Ï€(s, a, Î¸) QÌ„Î¸ (s, a) âˆ’ f$ (s, a)
âˆ‚$
s,a
(6)
Thus, the unbiased average reward natural policy gradient
is given by w satisfying (6). The biased algorithms sample
states, s, from dÂ¯Î¸ and actions, a, from Ï€(s, Â·, Î¸) and perform gradient descent on the squared difference between

âˆ‚V Î¸ (s)
âˆ‚ X
=
Ï€(s, a, Î¸)QÎ¸ (s, a)
âˆ‚Î¸
âˆ‚Î¸ a
"
X âˆ‚Ï€(s, a, Î¸) Î¸
=
Q (s, a)+
âˆ‚Î¸
a
!#
X a
âˆ‚
a
Î¸ 0
Ï€(s, a, Î¸)
Rs +
Pss0 Î³V (s )
âˆ‚Î¸
s0
"
X âˆ‚Ï€(s, a, Î¸) Î¸
=
Q (s, a)+
âˆ‚Î¸
a
#
X a
âˆ‚ Î¸ 0
Ï€(s, a, Î¸)
Pss0 Î³ V (s ) .
âˆ‚Î¸
0

X

9

X

We used random restarts for all methods and observed no local optima.

s

Solving for

P

a

âˆ‚Ï€(s,a,Î¸) Î¸
Q (s, a)
âˆ‚Î¸

X âˆ‚Ï€(s, a, Î¸)
a

=

âˆ‚Î¸

yields

QÎ¸ (s, a)

Î¸ 0
X
X
âˆ‚V Î¸ (s)
a âˆ‚V (s )
âˆ’Î³
Ï€(s, a, Î¸)
Pss
.
0
âˆ‚Î¸
âˆ‚Î¸
0
a
s

Bias in Natural Actor-Critic Algorithms

Summing both sides over all states weighted by dÂ¯Î¸ gives

We have shown that when (5) holds, the biased algorithms
compute the average reward natural policy gradient.

X Î¸ âˆ‚Ï€(s, a, Î¸) Î¸
dÂ¯ (s)
Q (s, a)
âˆ‚Î¸
s,a
!
X Î¸ âˆ‚V Î¸ (s)
âˆ’
=
dÂ¯ (s)
âˆ‚Î¸
s
Î³

X

dÂ¯Î¸ (s)

X

s

=

X
s

Î³

X

Î¸

a
0
Pss

s0

a

0

âˆ‚V (s )
âˆ‚Î¸

Î¸

V (s)
dÂ¯Î¸ (s)
âˆ’
âˆ‚Î¸

X
s

Ï€(s, a, Î¸)

7. Discussion and Conclusion

Î¸

âˆ‚V (s)
dÂ¯Î¸ (s)
= (1 âˆ’ Î³)
âˆ‚Î¸

X
s

Î¸

âˆ‚V (s)
dÂ¯Î¸ (s)
.
âˆ‚Î¸


Solving (7) for w, which gives the direction of the biased
algorithms, we get
!âˆ’1
X
X
Î¸
|
w=
dÂ¯ (s)
Ï€(s, a, Î¸)Ïˆsa Ïˆ
Ã—
sa

s

a

!
X

dÂ¯Î¸ (s)

X

s

Î¸

Ï€(s, a, Î¸)Q (s, a)Ïˆsa

.

a

Substituting k times this w into (6) for w and canceling
the product of the Fisher information matrix and its inverse
gives
X X
0=
dÂ¯Î¸
Ï€(s, a, Î¸)QÌ„Î¸ (s, a)Ïˆsa âˆ’
s

k

a

X

Â¯Î¸

d

X

s

Ï€(s, a, Î¸)QÎ¸ (s, a)Ïˆsa

a

X
Â¯
âˆ‚V Î¸ (s)
âˆ‚ J(Î¸)
âˆ’ k(1 âˆ’ Î³)
,
dÂ¯Î¸ (s)
=
âˆ‚Î¸
âˆ‚Î¸
s
by substitution of the policy gradient theorem (Sutton et al.,
2000) and Lemma 1. Thus, when, for some k,
X
Â¯
âˆ‚ J(Î¸)
âˆ‚V Î¸ (s)
= k(1 âˆ’ Î³)
,
(8)
dÂ¯Î¸ (s)
âˆ‚Î¸
âˆ‚Î¸
s
the biased algorithms produce the direction of the unbiased
average reward natural policy gradient.

We have shown that NAC-LSTD and eNAC produce biased
estimates of the natural gradient. We argued that they, and
INAC, act more like average reward natural actor-critics
that do not properly account for how changes to Î¸ change
the expected return via dÎ¸ . We proved that in certain situations the biased algorithms produce unbiased estimates
of the natural policy gradient for the average reward setting. The bias stems from improper discounting when approximating the state-action value function using compatible function approximation. We derived the properly discounted algorithms to produce the unbiased NAC-LSTD
and eNAC2, as well as the biased and unbiased NAC-S,
a linear time complexity alternative to the squared to cubic time complexity NAC-LSTD and eNAC2. However,
the unbiased algorithms have a critical drawback that limits their practicality.
The unbiased algorithms discount their updates by Î³ t ,
which can result in poor data efficiency, particularly when
Î³ is small.10 With small Î³, the updates will decay to zero
rapidly, causing the unbiased algorithms to ignore data collected after a short burn-in period. However, in some cases,
this data inefficiency is unavoidable. Consider an MDP like
the one presented earlier, where the set of states that occur
early and those that occur later are disjoint. In this setting, the discounted reward objective mandates that data
recorded late in trajectories must be ignored. In this situation, the rapid decay of updates is a curse of the choice
of objective function. However, if the states that are visited early in a trajectory are also visited later in a trajectory,
off-policy methods may be able to take advantage of data
from late in an episode to provide meaningful updates even
for the discounted reward setting. They may also be able
to properly use data from previous policies to improve the
estimates of the natural policy gradient in a principled manner. These are possible avenues for future research.
As stated in the introduction:

If we let k = 1, we will still get a constraint that results in
the two directions being the same, although if the constraint
is not satisfied, it does not mean the two are different (since
a different k may result in (8) being satisfied). Setting k =
Â¯
1 and substituting (4) for J(Î¸),
we get:
X Î¸ âˆ‚V Î¸ (s)
X Î¸
âˆ‚
(1 âˆ’ Î³)
dÂ¯ (s)V Î¸ (s) =(1 âˆ’ Î³)
dÂ¯ (s)
âˆ‚Î¸
âˆ‚Î¸
s
s
X
s

X Î¸ âˆ‚V Î¸ (s)
âˆ‚V Î¸ (s)
âˆ‚ dÂ¯Î¸ (s) Î¸
dÂ¯Î¸ (s)
+
V (s) =
dÂ¯ (s)
âˆ‚Î¸
âˆ‚Î¸
âˆ‚Î¸
s
X
s

âˆ‚ dÂ¯Î¸ (s)
V (s)
=0.
âˆ‚Î¸
Î¸

The goal of this paper is to raise awareness about
what the algorithms that are in use are actually
doing, not to present a superior method.
Until the data efficiency of these unbiased algorithms is improved, perhaps by leveraging off-policy techniques, they
are of little practical value. We only recommend their use
when optimization of the discounted-reward objective is
10

Although the unbiased algorithms suffer from data efficiency
problems, they are still more efficient than the naÄ±Ìˆve truncation
approach discussion in Section 4, which discards data.

Bias in Natural Actor-Critic Algorithms

absolutely critical.
Another interesting extension would be to determine how
Î³ should be selected in the biased algorithms. Recall that
(4) is the average reward objective, for all Î³. This suggests that in the biased algorithms, Î³ may be selected by
the researcher. Smaller values of Î³ are known to result in
faster convergence of value function estimates (Szepesvari,
1997), however larger Î³ typically result in smoother value
functions that may be easier to approximate accurately with
few features.
Lastly, we argued that, with certain policy parameterizations, policy gradient methods converge to globally optimal
policies for discrete problems, and suggested that local optima may be avoided in continuous problems by increasing
exploration and the policyâ€™s representational power. Future
work may attempt to provide global convergence guarantees for a subset of the continuous-action setting by intelligently increasing the representational power of the policy
when it becomes stuck in a local optimum.

References
Amari, S. Natural gradient works efficiently in learning.
Neural Computation, 10:251â€“276, 1998.
Bagnell, J. A. and Schneider, J. Covariant policy search.
In Proceedings of the International Joint Conference on
Artificial Intelligence, pp. 1019â€“1024, 2003.
Bertsekas, D. P. and Tsitsiklis, J. N. Neuro-Dynamic Programming. Athena Scientific, Belmont, MA, 1996.
Bertsekas, D. P. and Tsitsiklis, J. N. Gradient convergence
in gradient methods. SIAM J. Optim., 10:627â€“642, 2000.
Bhatnagar, S., Sutton, R. S., Ghavamzadeh, M., and Lee,
M. Natural actor-critic algorithms. Automatica, 45(11):
2471â€“2482, 2009.
Bradtke, S. J. and Barto, A. G. Linear least-squares algorithms for temporal difference learning. Machine Learning, 22:33â€“57, 1996.
Degris, T., Pilarski, P. M., and Sutton, R. S. Model-free reinforcement learning with continuous action in practice.
In Proceedings of the 2012 American Control Conference, 2012.
Kakade, S. Optimizing average reward using discounted
rewards. In Proceedings of the 14th Annual Conference
on Computational Learning Theory, 2001.
Kakade, S. A natural policy gradient. In Advances in
Neural Information Processing Systems, volume 14, pp.
1531â€“1538, 2002.

Lagoudakis, M. and Parr, R. Model-free least-squares policy iteration. In Neural Information Processing Systems:
Natural and Synthetic, pp. 1547â€“1554, 2001.
Morimura, T., Uchibe, E., and Doya, K. Utilizing the natural gradient in temporal difference reinforcement learning with eligibility traces. In International Symposium
on Information Geometry and its Application, 2005.
Morimura, T., Uchibe, E., Yoshimoto, J., and Doya, K. A
generalized natural actor-critic algorithm. In Neural Information Processing Systems: Natural and Synthetic,
2009.
Peters, J. Policy gradient methods. Scholarpedia, 5(11):
3698, 2010.
Peters, J. and Bagnell, J. A. Policy gradient methods. Encyclopedia of Machine Learning, 2010.
Peters, J. and Schaal, S. Policy gradient methods for
robotics. In Proceedings of the IEEE/RSJ International
Conference on Intelligent Robots and Systems, 2006.
Peters, J. and Schaal, S. Natural actor-critic. Neurocomputing, 71:1180â€“1190, 2008.
Sutton, R. S. and Barto, A. G. Reinforcement Learning: An
Introduction. MIT Press, Cambridge, MA, 1998.
Sutton, R. S., McAllester, D., Singh, S., and Mansour, Y.
Policy gradient methods for reinforcement learning with
function approximation. In Advances in Neural Information Processing Systems 12, pp. 1057â€“1063, 2000.
Szepesvari, C. S. The asymptotic convergence-rate of Qlearning. In Advances in Neural Information Processing
Systems, volume 10, pp. 1064â€“1070, 1997.

