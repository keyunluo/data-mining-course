Low Rank Approximation using Error Correcting Coding Matrices

Shashanka Ubaru
Arya Mazumdar
Yousef Saad
University of Minnesota-Twin Cities, MN USA

Abstract
Low-rank matrix approximation is an integral
component of tools such as principal component
analysis (PCA), as well as is an important instrument used in applications like web search, text
mining and computer vision, e.g., face recognition. Recently, randomized algorithms were proposed to effectively construct low rank approximations of large matrices. In this paper, we show
how matrices from error correcting codes can be
used to find such low rank approximations.
The benefits of using these code matrices are
the following: (i) They are easy to generate and
they reduce randomness significantly. (ii) Code
matrices have low coherence and have a better
chance of preserving the geometry of an entire
subspace of vectors; (iii) Unlike Fourier transforms or Hadamard matrices, which require sampling O(k log k) columns for a rank-k approximation, the log factor is not necessary in the case
of code matrices. (iv) Under certain conditions,
the approximation errors can be better and the
singular values obtained can be more accurate,
than those obtained using Gaussian random matrices and other structured random matrices.

1. Introduction
Many scientific computations, data analysis and machine
learning applications (Halko et al., 2011; Drineas et al.,
2006) lead to large dimensional matrices which can be well
approximated by a low dimensional basis. It is more efficient to solve such computational problems by first transforming these large matrices into a low dimensional space,
while preserving the invariant subspace that captures the
essential structure of the matrix. Several algorithms have
been proposed in the literature for finding such low rank
Proceedings of the 32 nd International Conference on Machine
Learning, Lille, France, 2015. JMLR: W&CP volume 37. Copyright 2015 by the author(s).

UBARU 001@ UMN . EDU
ARYA @ UMN . EDU
SAAD @ CS . UMN . EDU

approximations of a matrix (Ye, 2005; Haeffele et al., 2014;
Papailiopoulos et al., 2013). Recently, research focussed on
developing techniques which use randomization for computing low rank approximations and matrix decompositions of such matrices. It is found that randomness provides an effective way to construct low dimensional bases
with high reliability and computational efficiency.
The randomization techniques for matrix approximations
(Halko et al., 2011; Martinsson et al., 2006; Liberty et al.,
2007) aim to compute a basis that approximately spans the
input matrix A, by sampling the matrix using Gaussian random matrices. This task is accomplished by first forming
the matrix-matrix product Y = Aâ„¦, where â„¦ is a random
matrix of smaller dimension, and then computing the orthonormal basis of Y = QR that identifies the range of the
reduced matrix Y . It can be shown that A â‰ˆ QQâˆ— A with
high probability. Recently, it has been observed that structured random matrices, like subsampled random Fourier
transform (SRFT) and Hadamard transform (SRHT) matrices can also be used in place of Gaussian random matrices
(Liberty, 2009; Woolfe et al., 2008; Tropp, 2011). This paper demonstrates how error correcting coding matrices can
be a good choice for computing low rank approximations.
The input matrices whose low rank approximation is to be
computed, usually have very large dimensions (e.g., in the
order of 106 âˆ’ 108 ). In order to form a Gaussian random
matrix which samples the input matrix in randomized algorithms, we need to generate a large number of random numbers. This could be a serious practical issue, (in terms of
time complexity and storage). This issue can be addressed
by using the structured random matrices, like SRFT and
SRHT matrices. However, for a rank-k approximation,
these matrices require sampling O(k log k) columns. Other
practical issues arise such as: the Fourier Transform matrices require handling complex numbers and the Hadamard
matrices exist only for the sizes which are in powers of 2.
These drawbacks can be overcome if the code matrices presented in this paper are used for sampling input matrices.
In digital communication, information is encoded by
adding redundancy into (predominantly binary) vectors or

Low Rank Approximation using Error Correcting Coding Matrices

codewords, that are then transmitted over a noisy channel (Cover & Thomas, 2012). These codewords are required to be far apart in terms of some distance metric for
noise-resilience. Coding schemes usually generate codewords that maintain a fixed minimum Hamming distance
between each other. It can be shown that matrices formed
by stacking up these codewords generated by certain encoding schemes have orthonormal columns when an appropriate mapping is used, (see Lemma 2 for details). The
idea is to use subsampled versions of these code matrices as
sampling matrices in the randomized algorithms for matrix
approximations. Section 5.1 shows that subsampled code
matrices have low coherence and have a better chance of
preserving the geometry of an entire subspace of vectors.
In some cases, it is possible to compute the matrix-matrix
product faster with code matrices because of their structure. Importantly, contrary to SRFT/SRHT matrices, subsampled code matrices do not require the log factor, thus
achieving the order optimal O(k) in the number of samples
with deterministic matrices, see sec. 5.2 for an explanation.

2. Preliminaries
First, we present some of the notation used and give a brief
description of error correcting coding techniques that are
used in communication systems and information theory.
2.1. Notation and Problem Formulation
Throughout the paper, k Â· k refers to the `2 norm. We use
k Â· kF for the Frobenius norm. The singular value of a matrix is denoted by Ïƒj (Â·). We use ej for the jth standard basis
vector. Given a random subset T of indices in {1, . . . , 2r }
with size n and r â‰¥ dlog2 ne, we define a restriction (samr
pling) operator ST : R2 â†’ RT given by
(ST x)(j) = xj , j âˆˆ T.
A Rademacher random variable takes values Â±1 with equal
probability. We write Îµ for a Rademacher variable.

and the minimizer is X = Ak , the best rank-k approximation to a matrix as computed with the singular value
decomposition. That is, the columns of the matrix Q in (1)
are the k-dominant left singular vectors of A.
2.2. Error Correcting Codes
In communication systems, data are transmitted from a
source (transmitter) to a destination (receiver) through
physical channels. These channels are usually noisy, causing errors in the data received. In order to facilitate the
ability to detect and correct these errors in the receiver,
error-correcting codes are used (MacWilliams & Sloane,
1977). A block of information (data) symbols are encoded
in to a binary vector1 , also called a codeword, by the encoding error-correcting code. Error-correcting coding methods
check the correctness of the codeword received. The set of
codewords corresponding to a set of data-vectors (or symbols) that can possibly be transmitted, is called the code.
Hence, a code C is a subset of F`2 , ` being an integer.
A code is said to be linear when adding two codewords of
the code coordinate-wise using modulo-2 arithmetic results
in a third codeword of the code. Usually a linear code C is
represented by the tuple [`, r], where ` represents the codeword length and r = log2 |C| is the number of information
bits that can be encoded by the code. There are ` âˆ’ r redundant bits in the codeword, which are sometimes called
parity check bits, generated from messages using an appropriate rule. It is not necessary for a codeword to have the
information bits as r of its coordinates, but the information
must be uniquely recoverable from the codeword.
It is perhaps obvious that a linear code C is a linear subspace of dimension r in the vector space F`2 . The basis of
C can be written as the rows of a matrix, which is known as
the generator matrix of the code. The size of the generator
matrix G is r Ã— `, and for any information vector m âˆˆ Fr2 ,
the corresponding codeword is found by the linear map:
c = mG.

In low rank approximation methods, we compute an orthonormal basis which approximately spans the range of
an input matrix A of size m Ã— n. That is, a matrix Q having orthonormal columns such that A â‰ˆ QQâˆ— A. The basis
matrix Q contains as few columns as possible, but it needs
to be an accurate approximation of the input matrix. So, we
seek a matrix Q with k orthonormal columns such that

Note that all the arithmetic operations above are over the
binary field F2 . To encode r bits, we must have 2r unique
codewords. Then, we may form a matrix of size 2r Ã— ` by
stacking up all codewords that are formed by the generator
matrix of a given linear coding scheme,

kA âˆ’ QQâˆ— Ak â‰¤ ,

C = |{z}
M |{z}
G .
|{z}

(1)

for a positive error tolerance . The theoretical minimum
that can be achieved with such low rank approximations
in terms of singular values is given by the Eckart-Young
theorem (Eckart & Young, 1936)
min
rank(X)â‰¤k

kA âˆ’ Xk = Ïƒk+1 ,

(2)

2r Ã—`

(3)

2r Ã—r rÃ—`

For a given tuple [`, r], different error correcting coding
schemes have different generator matrices and the resulting codes have different properties. For example, for any
1
Here, and in the rest of the text, we are considering only binary codes. Codes over larger alphabets are also quite common.

Low Rank Approximation using Error Correcting Coding Matrices

two integers t and q, a BCH code (Bose & Ray-Chaudhuri,
1960) has length ` = 2q âˆ’1 and dimension r = 2q âˆ’1âˆ’tq.
Any two codewords in this BCH code maintain a minimum (Hamming) distance of at least 2t + 1 between them.
The pairwise minimum distance is an important parameter of a code and is called just the minimum distance
of the code. As a linear code is a subspace of a vector
space, the null-space of the code is another well-defined
subspace. This is called the dual of the code. The dual
of the [2q âˆ’ 1, 2q âˆ’ 1 âˆ’ tq]-BCH code is a code with
length 2q âˆ’ 1, dimension tq and minimum distance at least
2qâˆ’1 âˆ’(tâˆ’1)2q/2 . The minimum distance of the dual code
is called the dual distance of the code.
The codeword matrix C has 2r codewords each of length `
(a 2r Ã— ` matrix), i.e., a set of 2r vectors in {0, 1}` . Given
a codeword c âˆˆ C, let us map it to a vector Ï† âˆˆ R` by
and 0 âˆ’â†’ âˆš12r . In this way, a binary
setting 1 âˆ’â†’ âˆšâˆ’1
2r
code C gives rise to a code matrix Î¦ = (Ï†1 , . . . , Ï†2r )âˆ— .
Such a mapping is called binary phase-shift keying (BPSK)
and appeared in the context of sparse-recovery (e.g., p. 66
(Mazumdar, 2011)). For codes with dual distance â‰¥ 3, this
code matrix Î¦ will have orthonormal columns (see Lemma
2 and its proof). We will use the dual BCH code matrices
for numerical experiments in this paper. As we will see,
rows of such matrices are near-orthogonal and hence preserve the geometry of the space. In the randomized techniques for matrix approximations, we can use a subsampled
and scaled version of this matrix Î¦ to sample a given input
matrix and find the active subspaces of the matrix.

by 2âˆ’r/2 such that all columns have unit norm.
Intuition The design of a subsampled code matrix is similar to the design of SRFT and SRHT matrices. The intuition for using such a design is well established in (Tropp,
2011; Halko et al., 2011). The matrix Î¦ has entries with
magnitude Â±2âˆ’r/2 and has orthonormal columns when a
coding scheme with
qdual distance of the codes is â‰¥ 3 is
r

used. The scaling 2` is used to make the energy of the
sampling matrix equal to unity, i.e., to make the rows of â„¦
unit vectors. The purpose of multiplying by D is to flatten out input vectors. We refer to (Tropp, 2011) for further
details. For a fixed unit vector x, the
Pnfirst component of
xâˆ— DSÎ¦ is given by (xâˆ— DSÎ¦)1 = j=1 xj Îµj Ï†ij , where
Ï†ij are components of the code matrix Î¦, the index i depends on the downsampler S and Îµj is the Rademacher
variable from D. This sum clearly has zero mean and since
entries of Î¦ have magnitude 2âˆ’r/2 , the variance of the sum
is 2âˆ’r . The Hoeffding inequality (Hoeffding, 1963) shows
that
r 2

P{|(xâˆ— DSÎ¦)1 | â‰¥ tÌƒ} â‰¤ 2eâˆ’2

tÌƒ /2

.

That is, the magnitude of the first component of xâˆ— DSÎ¦ is
about 2âˆ’r/2 . Similarly, the argument holds for the remaining entries. Therefore, it is unlikely that
p any one of the `
components of xâˆ— DSÎ¦ is larger than 2 log(2`)/2r , (the
failure probability is `âˆ’1 ).

4. Algorithm
3. Construction of Subsampled Code Matrix
For an input matrix A of size m Ã— n, and a target rank k,
we choose r â‰¥ dlog2 ne and ` = k + p, where p is a small
oversampling to ensure that the samples have a much better
chance of spanning the required subspace. The intuition for
oversampling is well documented in (Halko et al., 2011;
Gu, 2014). We consider an [`, r]-linear coding scheme and
form the sampling matrix as follows: we draw the sampling
test matrix say â„¦ as
r
2r
â„¦=
DSÎ¦,
(4)
`
where
â€¢ D is a random n Ã— n diagonal matrix whose entries
are independent random signs, i.e., random variables
uniformly distributed on {Â±1}.
â€¢ S is the uniformly random downsampler, an n Ã—
2r matrix whose n rows are randomly selected from
a 2r Ã— 2r identity matrix.
â€¢ Î¦ is the 2r Ã— ` code matrix, generated using an [`, r]linear coding scheme, with BPSK mapping and scaled

We use the same prototype algorithm as discussed in
(Halko et al., 2011) for the low rank approximation and decomposition of input matrix A. The subsampled code matrices given in (4), generated from a chosen coding scheme
is used as the sampling test matrix. The algorithm is as
follows:
Algorithm 1 Prototype Algorithm
Input: An m Ã— n matrix A, a target rank k and an oversampling parameter p.
Output: Rank-k factors U, Î£, and V in an approximate
SVD A â‰ˆ U Î£V âˆ— .
1. Form an n Ã— ` subsampled code matrix â„¦, as described in Section 3 and (4), using an [`, r]âˆ’linear coding scheme, where ` = k + p and r â‰¥ dlog2 ne.
2. Form the m Ã— ` sample matrix Y = Aâ„¦.
3. Form an m Ã— ` orthonormal matrix Q such that
Y = QR.
4. Form the ` Ã— n matrix B = Qâˆ— A.
Here B is the low rank approximation of input matrix A.
5. Compute the SVD of the small matrix B = UÌ‚ Î£V âˆ— .
6. Form the matrix U = QUÌ‚ .

Low Rank Approximation using Error Correcting Coding Matrices

5. Analysis
This section discusses the performance analysis of the subsampled code matrices as sampling matrices in Algorithm
1. First, we show that these matrices preserve the geometry of an entire subspace of vectors. Next, we highlight the
differences between the construction of subsampled code
matrices used here and the construction of SRHT given in
(Halko et al., 2011; Tropp, 2011). Finally, we derive the
bounds for the approximation error and the singular values
obtained from the algorithm.
Setup Let A be an m Ã— n matrix with a singular value
decomposition given by A = U Î£V âˆ— , whose low rank approximation is to be evaluated, and partition its SVD as
follows
k

A=U



nâˆ’k

n



Î£1
Î£2



V1âˆ—
V2âˆ—



k

.

(5)

nâˆ’k

Let â„¦ be the n Ã— ` test (sampling) matrix, where ` is the
number of samples. Consider the matrices
â„¦1 = V1âˆ— â„¦

and â„¦2 = V2âˆ— â„¦.

(6)

The objective of any low rank approximation algorithm is
to try and approximate the subspace which spans the top
k left singular vectors of A. The test matrix â„¦ is said to
preserve the geometry of an entire subspace of vectors, if
for any orthonormal matrix V , a matrix of the form V âˆ— â„¦ is
well conditioned (Halko et al., 2011).
5.1. Subsampled Code Matrices Preserve Geometry
Recall from section 3 the construction of the â€˜tall and thinâ€™
n Ã— ` subsampled error correcting code matrices â„¦. One
of the critical facts to show is that these matrices approximately preserve the geometry of an entire subspace of vectors. An important property of the code matrices Î¦ is that
the columns are all orthonormal, if the codes satisfy a rather
mild condition. Indeed, if the dual distance of a code is at
least three then this property is satisfied.
Another crucial advantage of the code matrices is that they
have very low coherence. Coherence is defined as the maximum inner product between any two rows. This is in particular true when the minimum distance of the code is close
to half the length. If the minimum distance of the code is
d then the code matrix generated from an [`, r]-code has
coherence equal to `âˆ’2d
2r . For example, if we consider dual
âˆš

BCH code (see sec. 2.2) the coherence is 2(tâˆ’1)2r`+1âˆ’1 .
Low coherence ensures near orthogonality of rows. This
is a desirable property in many applications such as compressed sensing and sparse recovery.

Tropp, in (Tropp, 2011) has given an extensive analysis on
how the subsampled Hadamard matrices preserves the geometry of an entire subspace of vectors. We use similar
arguments to analyze the subsampled code matrices.
The construction given in (4) ensures that the energy is
uniformly distributed due to the scaling. Multiplying by
D ensures that the input vectors are flattened out and
âˆ—
that
p no components of the form, x DSÎ¦ are larger than
r
2 log(2`)/2 . The following theorem, similar to Theorem 11.1 in (Halko et al., 2011) and Theorem 1.3 in (Tropp,
2011), shows that code matrices approximately preserve
the geometry of entire subspace of vectors.
Theorem 1 (Code matrices preserve geometry) Fix an
n Ã— k orthonormal matrix V , and draw an n Ã— ` subsampled code matrix as in (4), using an [`, r]-linear code that
has dual distance â‰¥ 3, where r â‰¥ dlog2 (n)e and ` satisfies
n â‰¥ Î±` log(`).
Then
r
r
(1 âˆ’ Î´)n
(1 + Î·)n
âˆ—
âˆ—
â‰¤ Ïƒk (V â„¦) and Ïƒ1 (V â„¦) â‰¤
`
`
with probability at least 1 âˆ’ O(`âˆ’1 ). The parameters Î±, Î´
and Î· depend on the inputs n and `.
The theorem can be proved using the following three lemmas. The first lemma shows that if a code has dual distance
â‰¥ 3, the resulting code matrix Î¦ has orthonormal columns.

Lemma 2 (Code matrix with orthonormal columns) A
code matrix Î¦, generated by a coding scheme which results
in codes that have dual distance between the codewords
â‰¥ 3, has orthonormal columns.
Proof. If a code has dual distance 3, then the corresponding code matrix (stacked up codewords as rows)
is an orthogonal array of strength 2 (Delsarte & Levenshtein, 1998). This means all the tuples of bits, i.e.,
{0, 0}, {0, 1}, {1, 0}, {1, 1}, appear with equal frequencies
in any two columns of the codeword matrix C. As a result the Hamming distance between any two columns of
C is exactly 2râˆ’1 (half the length of the column). This
means after the BPSK mapping, the inner product between
any two codewords will be zero. It is easy to see that the
columns are unit norm as well.
This fact helps us use some of the arguments given in
(Tropp, 2011). Given below is a modification of Lemma
3.4 from (Tropp, 2011) which shows that randomly sampling the rows of such a code matrix results in a wellconditioned matrix.

Low Rank Approximation using Error Correcting Coding Matrices

Lemma 3 (Row sampling) Let Î¦ be an 2r Ã— ` code
matrix (with orthonormal columns), and let M =
2r . maxj=1,...,2r keâˆ—j Î¦k2 . For a positive parameter Î±, select the sample size
n â‰¥ Î±M log(`).
Draw a random subset T from {1, . . . , 2r } by sampling n
coordinates without replacement. Then,
r
r
(1 âˆ’ Î´)n
(1 + Î·)n
â‰¤ Ïƒ` (ST Î¦) and Ïƒ1 (ST Î¦) â‰¤
2r
2r
(7)
with failure probability at most
eâˆ’Î´
`.
(1 âˆ’ Î´)(1âˆ’Î´)


Î± log(`)

eÎ·
+ `.
(1 + Î·)(1+Î·)


Î± log(`)

5.2. Logarithmic factor

where Î´ âˆˆ [0, 1) and Î· > 0.
Since n is fixed and M = ` for a code matrix (all the
entries of the matrix are Â±2âˆ’r/2 ), we get the condition
n â‰¥ Î±` log(`) in Theorem 1. The parameters Î±, Î´ and
Î· are chosen based on the inputs ` and n and the failure
probability accepted. The bounds on the singular values of
the above lemma are proved in (Tropp, 2011) using
q Mar

trix Chernoff Bounds. Since we use the scaling 2` , the
bounds on the singular values of the subsampled code matrix â„¦ will be
r
r
(1 âˆ’ Î´)n
(1 + Î·)n
â‰¤ Ïƒ` (â„¦) and Ïƒ1 (â„¦) â‰¤
. (8)
`
`
Lemma 4 (Min-Max Property) Let â„¦ be an n Ã— ` matrix
whose singular values are bounded as in (8). Let V be an
nÃ—k matrix with orthonormal columns and ` > k, we have
r
(1 âˆ’ Î´)n
â‰¤ Ïƒ` (â„¦) â‰¤ Ïƒk (V âˆ— â„¦) and
`
r
(1 + Î·)n
âˆ—
Ïƒ1 (V â„¦) â‰¤ Ïƒ1 (â„¦) â‰¤
.
(9)
`
Proof. Consider A = â„¦â„¦âˆ— and B = V âˆ— â„¦(V âˆ— â„¦)âˆ— =
V âˆ— AV . By Min-Max theorem (Golub & Van Loan, 2013),
for ` > k we have
Î»1 (B) = Î»1 (V âˆ— AV ) â‰¤ Î»1 (A)
âˆ—

Î»` (A) â‰¤ Î»k (V AV ) = Î»k (B),

Differences in the construction An important difference between the construction of subsampled code matrices given in (4) and the construction of SRHT or SRFT
given in (Halko et al., 2011; Tropp, 2011) is in the way
these matrices are subsampled. In the case of SRHT, a
Hadamard matrix of size n Ã— n is considered and ` out
of n columns are sampled at random, (n must be a power
of 2). In contrast, in the case of subsampled code matrices,
a 2r Ã— ` code matrix generated from an [`, r]-linear coding
scheme is considered, and n out of 2r rows are sampled at
random. The subsampling will not affect the distinctness
of the rows selected in the code matrix (or the coherence).
This need not be true in the case of SRHT. The importance
of the distinctness of rows is discussed next.

and
(10)

where Î»1 (.) is the largest eigenvalue of a matrix and Î»` (A)
and Î»k (B) are the smallest nonzero eigenvalues of A and
B, respectively. This completes the proof for Lemma 4 and
Theorem 1.
Theorem 1 shows that V âˆ— â„¦ is well conditioned. This
proves that the subsampled code matrix approximately preserves the geometry of an entire subspace of vectors.

For a rank-k approximation using subsampled Fourier
or Hadamard matrices, we need to sample O(k log k)
columns. This logarithmic factor emerges as a necessary
condition in the theoretical proof (given in (Tropp, 2011))
that shows that these matrices approximately preserve the
geometry of an entire subspace of input vectors. The log
factor is also necessary to tackle the worst case input matrices. The discussions in sec. 11 of (Halko et al., 2011)
and sec. 3.3 of (Tropp, 2011) give more details. In the case
of subsampled code matrices, we saw that the log factor
does not arise in the theoretical analysis given in section
5.1. The code matrices also take care of the worst case input matrices without the log factor. To see why this is true,
let us consider the worst case example for orthonormal matrix V described in Remark 11.2 of (Halko et al., 2011).
An infinite family of worst case examples of the matrix V
is as follows. For a fixed integer k, let n = k 2 . Form an
n Ã— k orthonormal matrix V by regular decimation of the
n Ã— n identity matrix. That is, V is a matrix whose jth row
has a unit entry in column (j âˆ’ 1)/k when j â‰¡ 1 (mod k)
and is zero otherwise. This type of matrix is troublesome
when DFT or Hadamard matrices are used for sampling.
Suppose that we apply â„¦ = DF Râˆ— to the matrix V âˆ— ,
where D is same as in (4), F is an n Ã— n DFT or Hadamard
matrix and R is `Ã—n matrix that samples ` coordinates from
n uniformly at random. We obtain a matrix X = V âˆ— â„¦ =
W Râˆ— , which consists of ` random columns sampled from
W = V âˆ— DF . Up to scaling and modulation of columns,
W consists of k copies of a k Ã— k DFT or Hadamard matrix
concatenated horizontally. To ensure that X is well conditioned (preserve geometry), we need Ïƒk (X) > 0. That
is, we must pick at least one copy of each of the k distinct columns of W . This is the coupon collectorâ€™s problem
(Motwani & Raghavan, 1995) in disguise and to obtain a
complete set of k columns with non-negligible probability,
we must draw at least k log(k) columns.

Low Rank Approximation using Error Correcting Coding Matrices

In the case of code matrices, we apply a subsampled code
matrix â„¦ = DSÎ¦ to the matrix V âˆ— . We obtain X =
V âˆ— â„¦ = V âˆ— DSÎ¦, which consists of k randomly selected
rows of the code matrix Î¦. That is, X consists of k distinct
codewords of length `. The code matrix has low coherence and all rows are distinct. This means X contains k
independent (near orthonormal) rows and Ïƒk (X) > 0; as a
result Theorem 1 holds and the log factor is not necessary.
Thus, for the worst case scenarios we have an O(log k) factor improvement over other structured matrices. More importantly, this shows that our construction is order optimal
with the immediate lower bound of O(k) in the number of
samples required with deterministic matrices.

partitioned as in (6). Assuming that â„¦1 is full row rank,
then Algorithm 1 must satisfy for j = 1, . . . , k:
Ïƒj

Ïƒj â‰¥ Ïƒj (Ak ) â‰¥ r
1+

kâ„¦2 k2 kâ„¦â€ 1 k2



Ïƒk+1
Ïƒj

2

(13)

where Ïƒj are the jth singular value of A and Ak is the
rank-k approximation obtained by our algorithm.
The proof for the above theorem can be seen in (Gu, 2014).
Next, we derive the approximation error bounds when the
test matrix â„¦ is the subsampled code matrix defined by
Lemma 2. The upper and lower bounds for the singular
values obtained are also derived.

5.3. Error bounds
Algorithm 1 constructs an orthonormal basis Q for the
range of Y , and the goal is to quantify how well this basis captures the action of the input matrix A. Let QQâˆ— =
PY where PY is the unique orthogonal projector with
range(PY )=range(Y ). If Y is full rank, we can express the
projector as : PY = Y (Y âˆ— Y )âˆ’1 Y âˆ— . We seek to find an
upper bound for the approximation error given by,
kA âˆ’ QQâˆ— Ak = k(I âˆ’ PY )Ak.
The deterministic bounds for the approximation error for
Algorithm 1 is given in (Halko et al., 2011) and the bounds
for the singular values are given in (Gu, 2014). We restate
the theorem 9.1 in (Halko et al., 2011) below:
Theorem 5 (Deterministic error bound) Let A be m Ã— n
matrix with singular value decomposition given by A =
U Î£V âˆ— , and fix k â‰¥ 0. Choose a test matrix â„¦ and construct the sample matrix Y = Aâ„¦. Partition Î£ as in (5),
and define â„¦1 and â„¦2 via (6). Assuming that â„¦1 is full row
rank, the approximation error satisfies,
2

2

k|(I âˆ’ PY )A|k â‰¤ k|Î£2 |k +

k|Î£2 â„¦2 â„¦â€ 1 |k2

(11)

where k|.|k denotes either the spectral or Frobenius norm.
An elaborate proof for the above theorem can be found in
(Halko et al., 2011). Equation (11) simplifies to,
q
k|A âˆ’ QQâˆ— A|k â‰¤ Ïƒk+1 1 + k|â„¦2 |k2 k|â„¦â€ 1 |k2 . (12)

Theorem 7 (Error bounds for code matrix) Let A be
m Ã— n matrix with singular values Ïƒ1 â‰¥ Ïƒ2 â‰¥ Ïƒ3 â‰¥ . . ..
Generate a subsampled code matrix â„¦ with dual distance
â‰¥ 3 as in (4) and r â‰¥ dlog2 (n)e be the length of the message vector used to generate the code matrix. Then the
approximation error for the algorithm satisfies
s
2r
and
kA âˆ’ QQâˆ— Ak â‰¤ Ïƒk+1 1 +
(1 âˆ’ Î´)n
ï£«
ï£¶1/2 s
X
2r
kA âˆ’ QQâˆ— AkF â‰¤ ï£­
Ïƒj2 ï£¸
.
1+
(1 âˆ’ Î´)n
j>k

The bounds for the singular values obtained are:
Ïƒj

Ïƒj â‰¥ Ïƒj (Ak ) â‰¥ r
1+



2r
(1âˆ’Î´)n



Ïƒk+1
Ïƒj

2

(14)

with failure probability O(`âˆ’1 ).
Proof. For the approximate error bounds given in the theorem, we start from equation (12) in Theorem 5. The terms
that depend on the choice of test matrix â„¦ are kâ„¦2 k2 and
kâ„¦â€ 1 k2 . Theorem 1 shows that the code matrix â„¦ preserves
the geometry of the entire subspace of vectors and also ensures that the spectral norm of â„¦â€ 1 is under control. From
Lemma 3.6 in (Liberty et al., 2007), we have
kâ„¦â€ 1 k2 =

1
Ïƒk2 (â„¦1 )

â‰¤

1
(1âˆ’Î´)n
`

.

Recently Ming Gu (Gu, 2014), developed deterministic
lower bounds for the singular values obtained from randomization algorithms, particularly for the power method
(Halko et al., 2011), which is one of the alternatives of randomized algorithms. Given below is the modified version
of Theorem 4.3 in (Gu, 2014) for Algorithm 1.

We bound the spectral norm of â„¦2 as follows kâ„¦2 k2 =
kV2âˆ— â„¦k2 â‰¤ kV2 k2 kâ„¦k2 = kâ„¦k2 = Ïƒ12 (â„¦), since V2 is an
orthonormal matrix. The code matrix Î¦ is orthonormal and
has all itsq
singular values
q equal to one. Thus, the singular

Theorem 6 (Deterministic singular value bounds) Let
A = U Î£V âˆ— be the SVD of A, for a fix k, and let V âˆ— â„¦ be

Lemma 8 Let Î¦ be a 2r Ã— ` code matrix with orthogonal
columns and have singular values equal to Ïƒ1 (Î¦) = . . . =

values of

2r
` Î¦

are

2r
` .

We need the following lemma.

Low Rank Approximation using Error Correcting Coding Matrices
30

r

Ïƒ` (Î¦) = 2` . Let â„¦ = ST Î¦, a sub-matrix of Î¦ formed
by selecting n out of 2r rows, randomly. Then,
r
2r
Ïƒ1 (â„¦) â‰¤ Ïƒ1 (Î¦) =
(15)
`
Proof of the above lemma is straightforward from Theorem 3.1 and Remark 3.1 in (Gu, 2014). Also see (Golub &
Van Loan, 2013) for details. Thus, we have
kâ„¦2 k2 â‰¤ Ïƒ12 (â„¦) â‰¤

20
15
10
5
0
0

2r
`

and substituting these values in (12) will complete the
proof. Similarly, for the bounds on singular values we start
from the equation (13) in Theorem 6. We substitute the
above values for kâ„¦2 k2 and kâ„¦â€ 1 k2 .

Ïƒ(â„“ + 1)
eâ„“ (BCH)
eâ„“ (Gaussian)
eâ„“ (SR F T )
eâ„“ (SR HT )

25

errors (eâ„“ )

q

20

40

60

â„“

80

100

Choice of error-correcting code In the theoretical analysis above, we could choose any coding schemes with dual
distance â‰¥ 3, since the corresponding code matrix Î¦ will
be orthogonal. Code matrices generated by any linear coding scheme can be used in place of Gaussian random matrices. In fact, Hadamard matrices are also a class of Linear code, with variants known as Hadamard code, Simplex
code or 1st-order Reed-Muller code. The dual distance of
Hadamard code is 3. As there are many available classes
of algebraic and combinatorial codes we have a large pool
of candidate matrices. In this paper we chose dual BCH
codes as they particularly have low coherence, and turn out
to perform quite well.

6. Numerical Experiments
The following experiments will illustrate the performance
of subsampled code matrices as sampling matrices in Algorithm 1. Our first experiment is with a 4770 Ã— 4770 matrix
named Kohonen from the Pajek network (a directed graphâ€™s
matrix representation), available from the UFL Sparse Matrix Collection (Davis & Hu, 2011). Such graph Laplacian
matrices are commonly encountered in machine learning
and image processing applications. The performance of

140

Figure 1. The theoretical minimum Ïƒ`+1 and approximate error
as a function of the number of random samples ` using dual BCH
code, Gaussian, SRFT and SRHT matrices.
30

by svds
by BCH
by Gaussian
by SRFT
by SRHT

singular values Ïƒ(i)

25

Remark 1 (Value of Î´) The value of Î´ depends upon the
size n, length of the codeword ` and the failure probability needed. We have from Theorem 1 and Lemma 3,
n
Î± = ` log(`)
. If Î± = 4, then for a failure probability of
O(`âˆ’1 ) we have Î´ = 5/6. For Î± = 9, we have Î´ = 3/5
and if Î± = 14, we have Î´ = 1/2 for a failure probability of
O(`âˆ’1 ). A greater value of Î± implies a smaller value of Î´,
resulting in better error bounds. In practice, we can expect
Î± â‰¥ 10. So, Î´ is at most 0.6. For Î´ â‰¤ 0.6, the error bounds
obtained for code matrices are better than those obtained
for Gaussian random matrices and other structured random matrices (Halko et al., 2011).

120

20

15

10

5

0
0

50

100

150
i

200

250

300

Figure 2. Estimates for top 255 singular values computed by Algorithm 1 using dual BCH code, Gaussian, SRFT and SRHT matrices and the exact singular values by svds function.

the dual BCH code matrix, Gaussian matrix, subsampled
Fourier transform (SRFT) and Hadamard (SRHT) matrices
are compared as sampling matrices â„¦ in Algorithm 1. For
SRHT, we had to subsample the rows as well (similar to
code matrices), since the input size is not a power of 2. All
experiments were implemented in matlab v8.1.
Figure 1 gives the actual error e` = kA âˆ’ Q(`) (Q(`) )âˆ— Ak
for each ` number of samples when a subsampled dual
BCH code matrix, a Gaussian matrix, SRFT and SRHT
matrices are used as sampling matrices, respectively. The
minimum rank-` approximation error Ïƒ`+1 is also given.
Figure 2 plots the singular values obtained from Algorithm
1, for ` = 255 and different sampling matrices â„¦ used.
The top 255 exact singular values of the matrix (available
in the UFL database) are also plotted. We observe that the
performance of all four sampling matrices are similar.
Table 1 compares the errors e` for ` number of samples,
obtained for a variety of input matrices from different applications when subsampled dual BCH code, Gaussian and
SRFT matrices were used. It also provides the theoretical
minimum Ïƒ`+1 value for each input matrices. All matrices
were obtained from the UFL database. Matrices lpi ceria3d
(4400 Ã— 3576) and deter3 (21777 Ã— 7647) are from lin-

Low Rank Approximation using Error Correcting Coding Matrices
Table 2. Comparison of the Number of Incorrect Matches

Table 1. Comparison of errors
M ATRIX
LPICERIA 3 D

G AUSSIAN

SRFT

Ïƒ`+1

15.4865

18.3882

16.3619

6.4625

9.2602

9.2658

9.2984

5.7499

3.8148

3.8492

3.7975

1.9996

6.3864

6.3988

6.3829

5.8469

5.5518

5.5872

5.4096

2.5655

3.2171

3.2003

3.1752

1.3697

4.2977

4.2934

4.2610

2.0239

2.4581

2.4199

2.4718

1.0236

DUAL

BCH

` = 63
DETER 3

` = 127
S80PI
` = 63
D ELAUNAY
` = 63
EPA
` = 255
EPA
` = 511
KOHONEN
` = 511
KOHONEN
` =1023

ear programming problems. S80PI n1 (4028 Ã— 4028) is
from an eigenvalue/model reduction problem. Delaunay
(4096 Ã— 4096), EPA (4772 Ã— 4772) and Kohonen are graph
Laplacian matrices. We chose r = dlog ne such that
2r /n < 2 and the error will mainly depend on the parameter Î´, (i.e., the ratio n/`, see remark 1). We see in the first
four examples (higher n/` ratio), the error performance of
the code matrices is better than that of the Gaussian matrices. As the ratio decreases, the error increases. It however
remains similar to the error for Gaussian matrices.
Eigenfaces: Eigenfaces is a popular method for face
recognition that is based on Principal Component Analysis (PCA) (Turk & Pentland, 1991; Sirovich & Meytlis,
2009). In this experiment (chosen as a verifiable comparison with results in (Gu, 2014)), we demonstrate the performance of randomized algorithm with different sampling
matrices on face recognition. The face dataset is obtained
from the AT&T Labs Cambridge database of faces (Cambridge, 2002). There are ten different images of each of
40 distinct subjects. The size of each image is 92 Ã— 112
pixels, with 256 gray levels per pixel. 200 of these faces,
5 from each individual are used as training images and the
remaining 200 as test images to classify.
In the first step, we compute the principal components
(dimensionality reduction) of mean shifted training image
dataset using Algorithm 1, with different sampling matrix
â„¦ and different p values. Next, we project the mean-shifted
images into the singular vector space using the singular
vectors obtained from the first step. The projections are
called feature vectors and are used to train the classifier. To
classify a new face, we mean-shift the image and project
it onto the singular vector space obtained in the first step,
obtaining a new feature vector. The new feature vector
is classified using a classifier which is trained on the feature vectors from the training images. We used the in-built
MATLAB function classify for feature training and clas-

R ANK
k
10
20
30
40

D UAL BCH
p
10 20
18
14
10
09

13
11
08
08

G AUSSIAN
p
10 20
19
14
13
08

15
12
08
07

SRFT
p
10 20
21
16
12
08

18
12
09
10

T-SVD

26
13
10
06

sification. We compare the performance of the dual BCH
code matrix, Gaussian matrix and SRFT matrix against exact truncated SVD (T-SVD). The results are summarized in
Table 2. For p = 10 dual BCH code matrices give results
that are similar to those of truncated SVD, and for rank
k < 40, p = 20 our results are superior.

7. Conclusion
This paper advocated the use of matrices generated by error
correcting codes as an alternative to random Gaussian or
subsampled Fourier/Hadamard matrices for computing low
rank matrix approximations. Among the attractive properties of the proposed approach are the numerous choices of
parameters available, the orthogonality of columns and the
near-orthogonality of rows. We showed that the code matrices lead to an order optimal O(k) in the worst-case guaranteed sampling complexity, an improvement by a factor
of O(log k) over other known structured matrices. This is
significant when the expected rank k is large and/or when
the input matrix is sparse. The cost of QR factorization will
also reduce from O(n(k log k)2 ) to O(nk 2 ).
It is known that Gaussian matrices perform much better in
practice compared to their theoretical analysis (Halko et al.,
2011). Our code matrices (a) are almost deterministic, and
(b) have Â±1 entries. Still, they perform equally well (as
illustrated by experiments) compared to random real Gaussian matrices and complex Fourier matrices. Indeed, for
larger n/` ratios the performance of our matrices is in fact
superior as explained in remark 1 and depicted in Table 1.
Because of the availability of different families of classical
codes in the rich literature of coding theory, many possible
choices of code matrices are at hand. One of the contributions of this paper is to open up these options for use as
structured sampling operators in low-rank approximations.
Decoding of many, if not most, structured codes can be
performed by the Fast Fourier Transform (Blahut, 1979).
Hence, it is likely that matrix-matrix products with code
matrices will be substantially faster due to the availability
of these fast transform techniques.
Acknowledgements: This work was supported by NSF under grant NSF/CCF-1318597 (S. Ubaru and Y. Saad) and
NSF/CCF-1318093 (A. Mazumdar).

Low Rank Approximation using Error Correcting Coding Matrices

References
Blahut, Richard E. Transform techniques for error control
codes. IBM Journal of Research and development, 23
(3):299â€“315, 1979.
Bose, Raj Chandra and Ray-Chaudhuri, Dwijendra K. On a
class of error correcting binary group codes. Information
and control, 3(1):68â€“79, 1960.
Cambridge, AT&T Laboratories.
The Database of
Faces. 2002. URL http://www.cl.cam.ac.uk/
research/dtg/attarchive/facedatabase.
html.
Cover, Thomas M and Thomas, Joy A. Elements of information theory. John Wiley & Sons, 2012.
Davis, Timothy A and Hu, Yifan. The University of Florida
sparse matrix collection. ACM Transactions on Mathematical Software (TOMS), 38(1):1, 2011.
Delsarte, Philippe and Levenshtein, Vladimir I. Association schemes and coding theory. Information Theory,
IEEE Transactions on, 44(6):2477â€“2504, 1998.
Drineas, Petros, Kannan, Ravi, and Mahoney, Michael W.
Fast Monte Carlo algorithms for matrices II: Computing
a low-rank approximation to a matrix. SIAM Journal on
Computing, 36(1):158â€“183, 2006.
Eckart, Carl and Young, Gale. The approximation of one
matrix by another of lower rank. Psychometrika, 1(3):
211â€“218, 1936.
Golub, Gene H. and Van Loan, Charles F. Matrix Computations, volume 4. Johns Hopkins University Press,
Baltimore,MD, 2013.
Gu, M. Subspace Iteration Randomization and Singular
Value Problems. ArXiv e-prints, August 2014.
Haeffele, Benjamin, Young, Eric, and Vidal, Rene. Structured low-rank matrix factorization: Optimality, algorithm, and applications to image processing. In Proceedings of the 31st International Conference on Machine
Learning (ICML-14), pp. 2007â€“2015, 2014.
Halko, N., Martinsson, P., and Tropp, J. Finding Structure
with Randomness: Probabilistic Algorithms for Constructing Approximate Matrix Decompositions. SIAM
Review, 53(2):217â€“288, 2011. doi: 10.1137/090771806.
Hoeffding, Wassily. Probability inequalities for sums of
bounded random variables. Journal of the American statistical association, 58(301):13â€“30, 1963.
Liberty, Edo. Accelerated Dense Random Projections. PhD
thesis, Yale University, 2009.

Liberty, Edo, Woolfe, Franco, Martinsson, Per-Gunnar,
Rokhlin, Vladimir, and Tygert, Mark. Randomized algorithms for the low-rank approximation of matrices. Proceedings of the National Academy of Sciences, 104(51):
20167â€“20172, 2007.
MacWilliams, Florence Jessie and Sloane, Neil
James Alexander.
The theory of error-correcting
codes, volume 16. Elsevier, 1977.
Martinsson, Per-Gunnar, Rockhlin, Vladimir, and Tygert,
Mark. A randomized algorithm for the approximation of
matrices. Technical report, DTIC Document, 2006.
Mazumdar, Arya. Combinatorial methods in coding theory. PhD thesis, University of Maryland, 2011.
Motwani, R. and Raghavan, P.
Randomized Algorithms. Cambridge International Series on Parallel Computation. Cambridge University Press, 1995. ISBN
9780521474658.
Papailiopoulos, Dimitris, Dimakis, Alexandros, and Korokythakis, Stavros. Sparse PCA through Low-rank Approximations. In Proceedings of The 30th International
Conference on Machine Learning, pp. 747â€“755, 2013.
Sirovich, Lawrence and Meytlis, Marsha. Symmetry, probability, and recognition in face space. Proceedings of
the National Academy of Sciences, 106(17):6895â€“6899,
2009.
Tropp, Joel A. Improved analysis of the subsampled randomized hadamard transform. Advances in Adaptive
Data Analysis, 3(01n02):115â€“126, 2011.
Turk, Matthew and Pentland, Alex. Eigenfaces for recognition. Journal of cognitive neuroscience, 3(1):71â€“86,
1991.
Woolfe, Franco, Liberty, Edo, Rokhlin, Vladimir, and
Tygert, Mark. A fast randomized algorithm for the approximation of matrices. Applied and Computational
Harmonic Analysis, 25(3):335â€“366, 2008.
Ye, Jieping. Generalized Low Rank Approximations of
Matrices. Machine Learning, 61(1-3):167â€“191, 2005.
ISSN 0885-6125. doi: 10.1007/s10994-005-3561-6.

