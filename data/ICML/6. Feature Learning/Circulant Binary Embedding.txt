Circulant Binary Embedding

Felix X. Yu1
Sanjiv Kumar2
Yunchao Gong3
Shih-Fu Chang1
1
Columbia University, New York, NY 10027
2
Google Research, New York, NY 10011
3
University of North Carolina at Chapel Hill, Chapel Hill, NC 27599

Abstract
Binary embedding of high-dimensional data requires long codes to preserve the discriminative
power of the input space. Traditional binary coding methods often suffer from very high computation and storage costs in such a scenario. To
address this problem, we propose Circulant Binary Embedding (CBE) which generates binary
codes by projecting the data with a circulant matrix. The circulant structure enables the use of
Fast Fourier Transformation to speed up the computation. Compared to methods that use unstructured matrices, the proposed method improves
the time complexity from O(d2 ) to O(d log d),
and the space complexity from O(d2 ) to O(d)
where d is the input dimensionality. We also
propose a novel time-frequency alternating optimization to learn data-dependent circulant projections, which alternatively minimizes the objective in original and Fourier domains. We show
by extensive experiments that the proposed approach gives much better performance than the
state-of-the-art approaches for fixed time, and
provides much faster computation with no performance degradation for fixed number of bits.

1. Introduction
Embedding input data in binary spaces is becoming popular for efficient retrieval and learning on massive data sets
(Li et al., 2011; Gong et al., 2013a; Raginsky & Lazebnik, 2009; Gong et al., 2012; Liu et al., 2011). Moreover,
Proceedings of the 31 st International Conference on Machine
Learning, Beijing, China, 2014. JMLR: W&CP volume 32. Copyright 2014 by the author(s).

YUXINNAN @ EE . COLUMBIA . EDU
SANJIVK @ GOOGLE . COM
YUNCHAO @ CS . UNC . EDU
SFCHANG @ EE . COLUMBIA . EDU

in a large number of application domains such as computer vision, biology and finance, data is typically highdimensional. When representing such high dimensional
data by binary codes, it has been shown that long codes
are required in order to achieve good performance. In fact,
the required number of bits is O(d), where d is the input dimensionality (Li et al., 2011; Gong et al., 2013a; Sánchez
& Perronnin, 2011). The goal of binary embedding is to
well approximate the input distance as Hamming distance
so that efficient learning and retrieval can happen directly in
the binary space. It is important to note that another related
area called hashing is a special case with slightly different
goal: creating hash tables such that points that are similar
fall in the same (or nearby) bucket with high probability. In
fact, even in hashing, if high accuracy is desired, one typically needs to use hundreds of hash tables involving tens of
thousands of bits.
Most of the existing linear binary coding approaches generate the binary code by applying a projection matrix, followed by a binarization step. Formally, given a data point,
x ∈ Rd , the k-bit binary code, h(x) ∈ {+1, −1}k is generated simply as
h(x) = sign(Rx),
(1)
where R ∈ Rk×d , and sign(·) is a binary map which returns element-wise sign1 . Several techniques have been
proposed to generate the projection matrix randomly without taking into account the input data (Charikar, 2002; Raginsky & Lazebnik, 2009). These methods are very popular
due to their simplicity but often fail to give the best performance due to their inability to adapt the codes with respect
to the input data. Thus, a number of data-dependent techniques have been proposed with different optimization criteria such as reconstruction error (Kulis & Darrell, 2009),
data dissimilarity (Norouzi & Fleet, 2012; Weiss et al.,
1

A few methods transform the linear projection via a nonlinear map before taking the sign (Weiss et al., 2008; Raginsky &
Lazebnik, 2009).

Circulant Binary Embedding

2008), ranking loss (Norouzi et al., 2012), quantization error after PCA (Gong et al., 2013b), and pairwise misclassification (Wang et al., 2010). These methods are shown to
be effective for learning compact codes for relatively lowdimensional data. However, the O(d2 ) computational and
space costs prohibit them from being applied to learning
long codes for high-dimensional data. For instance, to generate O(d)-bit binary codes for data with d ∼1M, a huge
projection matrix will be required needing TBs of memory,
which is not practical2 .
In order to overcome these computational challenges, Gong
et al. (2013a) proposed a bilinear projection based coding
method for high-dimensional data. It reshapes the input
vector x into a matrix Z, and applies a bilinear projection
to get the binary code:
h(x) = sign(RT1 ZR2 ).

(2)

When the shapes of Z, R1 , R2 are chosen appropriately,
the method has time and space complexity of O(d1.5 ) and
O(d), respectively. Bilinear codes make it feasible to
work with datasets with very high dimensionality and have
shown good results in a variety of tasks.
In this work, we propose a novel Circulant Binary Embedding (CBE) technique which is even faster than the bilinear
coding. It is achieved by imposing a circulant structure
on the projection matrix R in (1). This special structure
allows us to use Fast Fourier Transformation (FFT) based
techniques, which have been extensively used in signal processing. The proposed method further reduces the time
complexity to O(d log d), enabling efficient binary embedding for very high-dimensional data3 . Table 1 compares
the time and space complexity for different methods. This
work makes the following contributions:
• We propose the circulant binary embedding method,
which has space complexity O(d) and time complexity O(d log d) (Section 2, 3).
• We propose to learn the data-dependent circulant projection matrix by a novel and efficient time-frequency
alternating optimization, which alternatively optimizes the objective in the original and frequency domains (Section 4).
• Extensive experiments show that, compared to the
state-of-the-art, the proposed method improves the result dramatically for a fixed time cost, and provides
much faster computation with no performance degradation for a fixed number of bits (Section 5).

Method
Full projection
Bilinear proj.
Circulant proj.

Time
O(d2 )
O(d1.5 )
O(d log d)

Space
O(d2 )
O(d)
O(d)

Time (Learning)
O(nd3 )
O(nd1.5 )
O(nd log d)

Table 1. Comparison of the proposed method (Circulant proj.)
with other methods for generating long codes (code dimension
k comparable to input dimension d). n is the number of instances
used for learning data-dependent projection matrices.

2. Circulant Binary Embedding (CBE)
A circulant matrix R ∈ Rd×d is a matrix defined by a vector r = (r0 , r2 , · · · , rd−1 )T (Gray, 2006)4 .


r0
rd−1 . . . r2
r1
 r1
r0
rd−1
r2 


 ..
.. 
.
.

.
r1
r0
. 
R = circ(r) :=  .
 . (3)


.
.
.
.
rd−2
.
. rd−1 
rd−1 rd−2 . . . r1
r0
Let D be a diagonal matrix with each diagonal entry being
a Bernoulli variable (±1 with probability 1/2). For x ∈ Rd ,
its d-bit Circulant Binary Embedding (CBE) with r ∈ Rd
is defined as:
h(x) = sign(RDx),

(4)

where R = circ(r). The k-bit (k < d) CBE is defined
as the first k elements of h(x). The need for such a D is
discussed in Section 3. Note that applying D to x is equivalent to applying random sign flipping to each dimension of
x. Since sign flipping can be carried out as a preprocessing
step for each input x, here onwards for simplicity we will
drop explicit mention of D. Hence the binary code is given
as h(x) = sign(Rx).
The main advantage of circulant binary embedding is its
ability to use Fast Fourier Transformation (FFT) to speed
up the computation.
Proposition 1. For d-dimensional data, CBE has space
complexity O(d), and time complexity O(d log d).
Since a circulant matrix is defined by a single column/row,
clearly the storage needed is O(d). Given a data point x,
the d-bit CBE can be efficiently computed as follows. Denote ~ as operator of circulant convolution. Based on the
definition of circulant matrix,
Rx = r ~ x.

(5)

2

In principle, one can generate the random entries of the matrix on-the-fly (with fixed seeds) without needing to store the matrix. But this will increase the computational time even further.
3
One could in principal use other structured matrices like
Hadamard matrix along with a sparse random Gaussian matrix to
achieve fast projection as was done in fast Johnson-Lindenstrauss
transform(Ailon & Chazelle, 2006; Dasgupta et al., 2011), but it
is still slower than circulant projection and needs more space.

The above can be computed based on Discrete Fourier
Transformation (DFT), for which fast algorithm (FFT) is
available. The DFT of a vector t ∈ Cd is a d-dimensional
vector with each element defined as
4
The circulant matrix is sometimes equivalently defined by
“circulating” the rows instead of the columns.

Circulant Binary Embedding

tn · e−i2πlm/d , l = 0, · · · , d − 1.

(6)

m=0

0.25

Independet
Circulant

0.2

Variance

F(t)l =

0.25

Variance

d−1
X

0.15
0.1
0.05
0
0

The above can be expressed equivalently in a matrix form
as
F(t) = Fd t,
(7)

F −1 (t) = (1/d)FH
d t.

F(Rx) = F(r) ◦ F(x).

(9)

Therefore,
h(x) = sign F

−1



(F(r) ◦ F(x)) .

(10)

For k-bit CBE, k < d, we only need to pick the first k bits
of h(x). As DFT and IDFT can be efficiently computed in
O(d log d) with FFT (Oppenheim et al., 1999), generating
CBE has time complexity O(d log d).

3. Randomized Circulant Binary Embedding
A simple way to obtain CBE is by generating the elements of r in (3) independently from the standard normal distribution N (0, 1). We call this method randomized
CBE (CBE-rand). A desirable property of any embedding
method is its ability to approximate input distances in the
embedded space. Suppose Hk (x1 , x2 ) is the normalized
Hamming distance between k-bit codes of a pair of points
x 1 , x 2 ∈ Rd :
Hk (x1 , x2 ) =

k−1

1 X
sign(Ri· x1 )−sign(Ri· x2 )/2, (11)
k i=0

and Ri· is the i-th row of R, R = circ(r). If r is sampled
from N (0, 1), from (Charikar, 2002),

Pr sign(rT x1 ) 6= sign(rT x2 ) = θ/π,
(12)
where θ is the angle between x1 and x2 . Since all the vectors that are circulant variants of r also follow the same
distribution, it is easy to see that
E(Hk (x1 , x2 )) = θ/π.

(13)

For the sake of discussion, if k projections, i.e., first k rows
of R, were generated independently, it is easy to show that
the variance of Hk (x1 , x2 ) will be
Var(Hk (x1 , x2 )) = θ(π − θ)/kπ 2 .

(14)

1

2

3

4

5

6

7

0
0

8

1

2

3

(a) θ = π/12

5

6

7

8

(b) θ = π/6
0.25

Variance

Independet
Circulant

0.2
0.15
0.1
0.05
0
0

4

log k

0.25

Independet
Circulant

0.2
0.15
0.1
0.05

1

2

3

4

5

log k

(8)

Since the convolution of two signals in their original domain is equivalent to the hadamard product in their frequency domain (Oppenheim et al., 1999),

0.1
0.05

log k

Variance

where Fd is the d-dimensional DFT matrix. Let FH
d be the
conjugate transpose of Fd . It is easy to show that F−1
d =
d
(1/d)FH
.
Similarly,
for
any
t
∈
C
,
the
Inverse
Discrete
d
Fourier Transformation (IDFT) is defined as

Independet
Circulant

0.2
0.15

(c) θ = π/3

6

7

8

0
0

1

2

3

4

5

6

7

8

log k

(d) θ = π/2

Figure 1. The analytical variance of normalized hamming distance of independent bits as in (14), and the sample variance of
normalized hamming distance of circulant bits, as a function of
angle between points (θ) and number of bits (k). The two curves
overlap.

Thus, with more bits (larger k), the normalized hamming
distance will be close to the expected value, with lower
variance. In other words, the normalized hamming distance
approximately preserves the angle5 . Unfortunately in CBE,
the projections are the rows of R = circ(r), which are
not independent. This makes it hard to derive the variance
analytically. To better understand CBE-rand, we run simulations to compare the analytical variance of normalized
hamming distance of independent projections (14), and the
sample variance of normalized hamming distance of circulant projections in Figure 1. For each θ and k, we randomly generate x1 , x2 ∈ Rd such that their angle is θ6 .
We then generate k-dimensional code with CBE-rand, and
compute the hamming distance. The variance is estimated
by applying CBE-rand 1,000 times. We repeat the whole
process 1,000 times, and compute the averaged variance.
Surprisingly, the curves of “Independent” and “Circulant”
variances are almost indistinguishable. This means that bits
generated by CBE-rand are generally as good as the independent bits for angle preservation. An intuitive explanation is that for the circulant matrix, though all the rows are
dependent, circulant shifting one or multiple elements will
in fact result in very different projections in most cases.
We will later show in experiments on real-world data that
CBE-rand and Locality Sensitive Hashing (LSH)7 has almost identical performance (yet CBE-rand is significantly
faster) (Section 5).
5

In this paper, we consider the case that the data points are
`2 normalized. Therefore the cosine distance, i.e., 1 - cos(θ), is
equivalent to the l2 distance.
6
This can be achieved by extending the 2D points (1, 0),
(cos θ, sin θ) to d-dimension, and performing a random orthonormal rotation, which can be formed by the Gram-Schmidt process
on random vectors.
7
Here, by LSH we imply the binary embedding using R such
that all the rows of R are sampled iid. With slight abuse of notation, we still call it “hashing” following (Charikar, 2002).

Circulant Binary Embedding

Note that the distortion in input distances after circulant
binary embedding comes from two sources: circulant projection, and binarization. For the circulant projection step,
recent works have shown that the Johnson-Lindenstrausstype lemma holds with a slightly worse bound on the number of projections needed to preserve the input distances
with high probability (Hinrichs & Vybı́ral, 2011; Zhang
& Cheng, 2013; Vybı́ral, 2011; Krahmer & Ward, 2011).
These works also show that before applying the circulant
projection, an additional step of randomly flipping the signs
of input dimensions is necessary8 . To show why such a step
is required, let us consider the special case when x is an allone vector, 1. The circulant projection with R = circ(r)
will result in a vector with all elements to be rT 1. When
r is independently drawn from N (0, 1), this will be close
to 0, and the norm cannot be preserved. Unfortunately the
Johnson-Lindenstrauss-type results do not generalize to the
distortion caused by the binarization step.
One problem with the randomized CBE method is that it
does not utilize the underlying data distribution while generating the matrix R. In the next section, we propose to
learn R in a data-dependent fashion, to minimize the distortions due to circulant projection and binarization.

4. Learning Circulant Binary Embedding
We propose data-dependent CBE (CBE-opt), by optimizing the projection matrix with a novel time-frequency alternating optimization. We consider the following objective function in learning the d-bit CBE. The extension of
learning k < d bits will be shown in Section 4.2.
argmin ||B − XRT ||2F + λ||RRT − I||2F

(15)

B,r

s.t.

R = circ(r),

where X ∈ Rn×d , is the data matrix containing n training
points: X = [x0 , · · · , xn−1 ]T , and B ∈ {−1, 1}n×d is the
corresponding binary code matrix.9
In the above optimization, the first term minimizes distortion due to binarization. The second term tries to make the
projections (rows of R, and hence the corresponding bits)
as uncorrelated as possible. In other words, this helps to
reduce the redundancy in the learned code. If R were to be
an orthogonal matrix, the second term will vanish and the
optimization would find the best rotation such that the distortion due to binarization is minimized. However, when
R is a circulant matrix, R, in general, will not be orthogonal. Similar objective has been used in previous works
including (Gong et al., 2013b;a) and (Wang et al., 2010).
8

For each dimension, whether the sign needs to be flipped is
predetermined by a (p = 0.5) Bernoulli variable.
9
If√ the √
data is `2 normalized, we can set B ∈
{−1/ d, 1/ d}n×d to make B and XRT more comparable.
This does not empirically influence the performance.

4.1. The Time-Frequency Alternating Optimization
The above is a combinatorial optimization problem, for
which an optimal solution is hard to find. In this section
we propose a novel approach to efficiently find a local solution. The idea is to alternatively optimize the objective
by fixing r, and B, respectively. For a fixed r, optimizing
B can be easily performed in the input domain (“time” as
opposed to “frequency”). For a fixed B, the circulant structure of R makes it difficult to optimize the objective in the
input domain. Hence we propose a novel method, by optimizing r in the frequency domain based on DFT. This leads
to a very efficient procedure.
For a fixed r. The objective is independent on each element
of B. Denote Bij as the element of the i-th row and j-th
column of B. It is easy to show that B can be updated as:
(
1
if Rj· xi ≥ 0
,
(16)
Bij =
−1 if Rj· xi < 0
i = 0, · · · , n − 1.

j = 0, · · · , d − 1.

For a fixed B. Define r̃ as the DFT of the circulant vector
r̃ := F(r). Instead of solving r directly, we propose to
solve r̃, from which r can be recovered by IDFT.
Key to our derivation is the fact that DFT projects the signal
to a set of orthogonal basis. Therefore the `2 norm can be
preserved. Formally, according to Parseval’s theorem , for
any t ∈ Cd (Oppenheim et al., 1999),
||t||22 = (1/d)||F(t)||22 .
Denote diag(·) as the diagonal matrix formed by a vector.
Denote <(·) and =(·) as the real and imaginary parts, respectively. We use Bi· to denote the i-th row of B. With
complex arithmetic, the first term in (15) can be expressed
in the frequency domain as:
||B − XRT ||2F =

=

n−1
1X
||F(BTi· − Rxi )||22
d i=0

(17)

n−1
n−1
1X
1X
||F(BTi· )−r̃◦F(xi )||22 =
||F(BTi· )−diag(F(xi ))r̃||22
d i=0
d i=0

n−1
 

1 X
F(BTi· )−diag(F(xi ))r̃ T F(BTi· )−diag(F(xi ))r̃
d i=0
i
1h
= <(r̃)T M<(r̃)+=(r̃)T M=(r̃)+<(r̃)T h+=(r̃)T g +||B||2F ,
d

=

where,
M = diag

n−1
X


<(F(xi ))◦<(F(xi ))+=(F(xi ))◦=(F(xi ))

i=0

h = −2

n−1
X

<(F(xi ))◦<(F(BTi· ))+=(F(xi )) ◦ =(F(BTi· ))

i=0

g=2

n−1
X
i=0

=(F(xi )) ◦ <(F(BTi· )) − <(F(xi )) ◦ =(F(BTi· )).

Circulant Binary Embedding

For the second term in (15), we note that the circulant matrix can be diagonalized by DFT matrix Fd and its conjud
gate transpose FH
d . Formally, for R = circ(r), r ∈ R ,
R = (1/d)FH
d diag(F(r))Fd .

=||r̃ ◦ r̃ −

1||22

2

2

= ||<(r̃) + =(r̃) −

1||22 .

(19)

Furthermore, as r is real-valued, additional constraints on
r̃ are needed. For any u ∈ C, denote u as the complex conjugate of u. We have the following result (Oppenheim et al., 1999): For any real-valued vector t ∈ Cd ,
F(t)0 is real-valued, and
F(t)d−i = F(t)i , i = 1, · · · , bd/2c.
From (17) − (19), the problem of optimizing r̃ becomes
argmin <(r̃)T M<(r̃) + =(r̃)T M=(r̃) + <(r̃)T h

argmin ||BPk −XPTk RT ||2F +λ||RPk PTk RT −I||2F
B,r

s.t.

R = circ(r),

(23)




Ik
O
, Ik is a k × k identity matrix,
O Od−k
is a (d − k) × (d − k) all-zero matrix.

in which Pk =
and Od−k

In fact, the right multiplication of Pk can be understood as
a “temporal cut-off”, which is equivalent to a frequency domain convolution. This makes the optimization difficult, as
the objective in frequency domain can no longer be decomposed. To address this issues, we propose a simple solution
in which Bij = 0, i = 0, · · · , n − 1, j = k, · · · , d − 1 in
(15). Thus, the optimization procedure remains the same,
and the cost is also O(nd log d). We will show in experiments that this heuristic provides good performance in
practice.

5. Experiments

r̃

+ =(r̃)T g + λd||<(r̃)2 + =(r̃)2 − 1||22

In the case of learning k < d bits, we need to solve the
following optimization problem:

(18)

Let Tr(·) be the trace of a matrix. Therefore,
1
H
2
||RRT − I||2F = || FH
d (diag(r̃) diag(r̃) − I)Fd ||F
d


1 H
H
H
H
= Tr Fd (diag(r̃) diag(r̃)−I) (diag(r̃) diag(r̃)−I)Fd
d


= Tr (diag(r̃)H diag(r̃) − I)H (diag(r̃)H diag(r̃) − I)
H

4.2. Learning k < d Bits

(20)

(22)

To compare the performance of the proposed circulant
binary embedding technique, we conducted experiments
on three real-world high-dimensional datasets used by the
current state-of-the-art method for generating long binary
codes (Gong et al., 2013a). The Flickr-25600 dataset contains 100K images sampled from a noisy Internet image
collection. Each image is represented by a 25, 600 dimensional vector. The ImageNet-51200 contains 100k images sampled from 100 random classes from ImageNet
(Deng et al., 2009), each represented by a 51, 200 dimensional vector. The third dataset (ImageNet-25600) is another random subset of ImageNet containing 100K images
in 25, 600 dimensional space. All the vectors are normalized to be of unit norm.

In (21), we need to minimize a 4th order polynomial with
one variable, with the closed form solution readily available. In (22), we need to minimize a 4th order polynomial
with two variables. Though the closed form solution is hard
(requiring solution of a cubic bivariate system), we can find
local minima by gradient descent, which can be considered as having constant running time for such small-scale
problems. The overall objective is guaranteed to be nonincreasing in each step. In practice, we can get a good solution with just 5-10 iterations. In summary, the proposed
time-frequency alternating optimization procedure has running time O(nd log d).

We compared the performance of the randomized (CBErand) and learned (CBE-opt) versions of our circulant
embeddings with the current state-of-the-art for highdimensional data, i.e., bilinear embeddings. We use both
the randomized (bilinear-rand) and learned (bilinear-opt)
versions. Bilinear embeddings have been shown to perform similar or better than another promising technique
called Product Quantization (Jegou et al., 2011). Finally,
we also compare against the binary codes produced by the
baseline LSH method (Charikar, 2002), which is still applicable to 25,600 and 51,200 dimensional feature but with
much longer running time and much more space. We also
show an experiment with relatively low-dimensional data
in 2048 dimensional space using Flickr data to compare
against techniques that perform well for low-dimensional
data but do not scale to high-dimensional scenario. Exam-

s.t.

=(r̃0 ) = 0
<(r̃i ) = <(r̃d−i ), i = 1, · · · , bd/2c
=(r̃i ) = −=(r̃d−i ), i = 1, · · · , bd/2c.

The above is non-convex. Fortunately, the objective function can be decomposed, such that we can solve two variables at a time. Denote the diagonal vector of the diagonal
matrix M as m. The above optimization can then be decomposed to the following sets of optimizations.
2
argmin m0 r̃02 + h0 r̃0 + λd r̃02 − 1 , s.t. r̃0 = r̃0 . (21)
r̃0

argmin (mi + md−i )(<(r̃i )2 + =(r̃i )2 )
r̃i
2
+ 2λd <(r̃i )2 + =(r̃i )2 − 1
+ (hi + hd−i )<(r̃i ) + (gi − gd−i )=(r̃i ),
i = 1, · · · , bd/2c.

Circulant Binary Embedding
Bilinear proj.
2.85
1.91 × 101
3.76 × 102
1.22 × 104
2.68 × 105

Circulant proj.
1.11
4.23
3.77 × 101
8.10 × 102
8.15 × 103

Table 2. Computational time (ms) of full projection (LSH, ITQ,
SH etc.), bilinear projection (Bilinear), and circulant projection
(CBE). The time is based on a single 2.9GHz CPU core. The
error is within 10%. An empty cell indicates that the memory
needed for that method is larger than the machine limit of 24GB.

Original
25.59±0.33

Following (Gong et al., 2013a; Norouzi & Fleet, 2012;
Gordo & Perronnin, 2011), we use 10,000 randomly sampled instances for training. We then randomly sample 500
instances, different from the training set as queries. The
performance (recall@1-100) is evaluated by averaging the
recalls of the query instances. The ground-truth of each
query instance is defined as its 10 nearest neighbors based
on `2 distance. For each dataset, we conduct two sets of experiments: fixed-time where code generation time is fixed
and fixed-bits where the number of bits is fixed across all
techniques. We also show an experiment where the binary
codes are used for classification.
The proposed CBE method is found robust to the choice
of λ in (15). For example, in the retrieval experiments, the
performance difference for λ = 0.1, 1, 10, is within 0.5%.
Therefore, in all the experiments, we simply fix λ = 1. For
the bilinear method, in order to get fast computation, the
feature vector is reshaped to a near-square matrix, and the
dimension of the two bilinear projection matrices are also
chosen to be close to square. Parameters for other techniques are tuned to give the best results on these datasets.
Computational Time. When generating k-bit code for
d-dimensional data, the full projection, bilinear projection, and circulant
√ projection methods have time complexity O(kd), O( kd), and O(d log d), respectively. We compare the computational time in Table 2 on a fixed hardware.
Based on our implementation, the computational time of
the above
√ three methods can be roughly characterized as
d2 : d d : 5d log d. Note that faster implementation of
FFT algorithms will lead to better computational time for
CBE by further reducing the constant factor. Due to the
small storage requirement O(d), and the wide availability
of highly optimized FFT libraries, CBE is also suitable for
implementation on GPU. Our preliminary tests based on
GPU shows up to 20 times speedup compared to CPU. In
this paper, for fair comparison, we use same CPU based
implementation for all the methods.
Retrieval. The recall for different methods is compared on

Bilinear-opt
24.02±0.35

CBE-opt
24.55 ±0.30

Table 3. Multiclass classification accuracy on binary coded
ImageNet-25600. The binary codes of same dimensionality are
32 times more space efficient than the original features (singlefloat).
1

1

0.8

0.8

0.6

0.6
LSH
SKLSH
ITQ
SH
AQBC
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt

0.4

ple techniques include ITQ (Gong et al., 2013b), SH (Weiss
et al., 2008), SKLSH (Raginsky & Lazebnik, 2009), and
AQBC (Gong et al., 2012).

LSH
23.49±0.24

0.2

0
10

Recall

Full proj.
5.44 × 102
-

Recall

d
215
217
220 (1M)
224
227 (100M)

20

30 40 50 60 70 80
Number of retrieved points

(a) # bits = 1,024

90

LSH
SKLSH
ITQ
SH
AQBC
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt

0.4

0.2

100

0
10

20

30 40 50 60 70 80
Number of retrieved points

90

100

(b) # bits = 2,048

Figure 5. Performance comparison on relatively low-dimensional
data (Flickr-2048) with fixed number of bits. CBE gives comparable performance to the state-of-the-art even on low-dimensional
data as the number of bits is increased. However, note that these
other methods do not scale to very high-dimensional data setting
which is the main focus of this work.

the three datasets in Figure 2, 3, and 4 respectively. The
top row in each figure shows the performance for different
methods when the code generation time for all the methods is kept the same as that of CBE. For a fixed time, the
proposed CBE yields much better recall than other methods. Even CBE-rand outperforms LSH and Bilinear code
by a large margin. The second row compares the performance for different techniques with codes of same length.
In this case, the performance of CBE-rand is almost identical to LSH even though it is hundreds of time faster. This is
consistent with our analysis in Section 3. Moreover, CBEopt/CBE-rand outperform the Bilinear-opt/Bilinear-rand in
addition to being 2-3 times faster.
Classification. Besides retrieval, we also test the binary
codes for classification. The advantage is to save on storage allowing even large scale datasets to fit in memory
(Li et al., 2011; Sánchez & Perronnin, 2011). We follow
the asymmetric setting of (Sánchez & Perronnin, 2011) by
training linear SVM on binary code sign(Rx), and testing
on the original Rx. This empirically has been shown to
give better accuracy than the symmetric procedure. We use
ImageNet-25600, with randomly sampled 100 images per
category for training, 50 for validation and 50 for testing.
The code dimension is set as 25,600. As shown in Table 3,
CBE, which has much faster computation, does not show
any performance degradation compared to LSH or bilinear
codes in classification task as well.
Low-Dimensional Experiment. There exist several techniques that do not scale to high-dimensional case. To compare our method with those, we conducted experiments

Circulant Binary Embedding

0.8

0.8

0.8

0.8

0.6

0.6

0.6

0.6

0.4

0.4

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt

0.2

0
10

20

30 40 50 60 70 80
Number of retrieved points

90

0
10

100

(a) # bits (CBE) = 3,200

0.4

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt

0.2

20

30 40 50 60 70 80
Number of retrieved points

90

Recall

1

Recall

1

Recall

1

Recall

1

0.2

0
10

100

(b) # bits (CBE) = 6,400

0.4

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt
20

30 40 50 60 70 80
Number of retrieved points

90

0.2

0
10

100

(c) # bits (CBE) = 12,800

0.8

0.8

0.8

0.6

0.6

0.6

0.6

0.4

0.2

0
10

20

30 40 50 60 70 80
Number of retrieved points

90

0.2

0
10

100

0.4

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt
20

(e) # bits (all) = 3,200

30 40 50 60 70 80
Number of retrieved points

90

0.4

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt

0.2

0
10

100

30 40 50 60 70 80
Number of retrieved points

90

100

Recall

0.8

Recall

1

Recall

1

Recall

1

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt

20

(d) # bits (CBE) = 25,600

1

0.4

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt

(f) # bits (all) = 6,400

20

30 40 50 60 70 80
Number of retrieved points

90

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt

0.2

0
10

100

(g) # bits (all) = 12,800

20

30 40 50 60 70 80
Number of retrieved points

90

100

(h) # bits (all) = 25,600

Figure 2. Recall on Flickr-25600. The standard deviation is within 1%. First Row: Fixed time. “# bits” is the number of bits of CBE.
Other methods are using less bits to make their computational time identical to CBE. Second Row: Fixed number of bits. CBE-opt/CBErand are 2-3 times faster than Bilinear-opt/Bilinear-rand, and hundreds of times faster than LSH.

0.8

0.8

0.8

0.8

0.6

0.6

0.6

0.6

0.4

0.4

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt

0.2

0
10

20

30 40 50 60 70 80
Number of retrieved points

90

0
10

100

(a) # bits (CBE) = 3,200

0.4

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt

0.2

20

30 40 50 60 70 80
Number of retrieved points

90

Recall

1

Recall

1

Recall

1

Recall

1

0.2

0
10

100

(b) # bits (CBE) = 6,400

0.4

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt
20

30 40 50 60 70 80
Number of retrieved points

90

0.2

0
10

100

(c) # bits (CBE) = 12,800

0.8

0.8

0.8

0.6

0.6

0.6

0.6

0.2

0
10

20

30 40 50 60 70 80
Number of retrieved points

90

(e) # bits (all) = 3,200

100

0.4

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt

0.2

0
10

20

30 40 50 60 70 80
Number of retrieved points

90

100

(f) # bits (all) = 64,00

30 40 50 60 70 80
Number of retrieved points

90

100

Recall

0.8

Recall

1

Recall

1

Recall

1

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt

20

(d) # bits (CBE) = 25,600

1

0.4

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt

0.4

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt

0.2

0
10

20

30 40 50 60 70 80
Number of retrieved points

90

(g) # bits (all) = 12,800

100

0.4

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt

0.2

0
10

20

30 40 50 60 70 80
Number of retrieved points

90

100

(h) # bits (all) = 25,600

Figure 3. Recall on ImageNet-25600. The standard deviation is within 1%. First Row: Fixed time. “# bits” is the number of bits
of CBE. Other methods are using less bits to make their computational time identical to CBE. Second Row: Fixed number of bits.
CBE-opt/CBE-rand are 2-3 times faster than Bilinear-opt/Bilinear-rand, and hundreds of times faster than LSH.

with fixed number of bits on a relatively low-dimensional
dataset (Flickr-2048), constructed by randomly sampling
2,048 dimensions of Flickr-25600. As shown in Figure 5,
though CBE is not designed for such scenario, the CBEopt performs better or equivalent to other techniques except

ITQ which scales very poorly with d (O(d3 )). Moreover, as
the number of bits increases, the gap between ITQ and CBE
becomes much smaller suggesting that the performance of
ITQ is not expected to be better than CBE even if one could
run ITQ on high-dimensional data.

Circulant Binary Embedding

0.8

0.8

0.8

0.8

0.6

0.6

0.6

0.6

0.4

0.4

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt

0.2

0
10

20

30 40 50 60 70 80
Number of retrieved points

90

0
10

100

(a) # bits (CBE) = 6,400

0.4

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt

0.2

20

30 40 50 60 70 80
Number of retrieved points

90

Recall

1

Recall

1

Recall

1

Recall

1

0.2

0
10

100

(b) # bits (CBE) = 12,800

0.4

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt
20

30 40 50 60 70 80
Number of retrieved points

90

0.2

0
10

100

(c) # bits (CBE) = 25,600

0.8

0.8

0.8

0.6

0.6

0.6

0.6

0.4

0.2

0
10

20

30 40 50 60 70 80
Number of retrieved points

90

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt

0.2

0
10

100

(e) # bits (all) = 6,400

20

30 40 50 60 70 80
Number of retrieved points

90

100

(f) # bits (all) = 12,800

30 40 50 60 70 80
Number of retrieved points

90

100

Recall

0.8

Recall

1

Recall

1

Recall

1

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt

20

(d) # bits (CBE) = 51,200

1

0.4

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt

0.4

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt

0.2

0
10

20

30 40 50 60 70 80
Number of retrieved points

90

(g) # bits (all) = 25,600

100

0.4

LSH
Bilinear−rand
Bilinear−opt
CBE−rand
CBE−opt

0.2

0
10

20

30 40 50 60 70 80
Number of retrieved points

90

100

(h) # bits (all) = 51,200

Figure 4. Recall on ImageNet-51200. The standard deviation is within 1%. First Row: Fixed time. “# bits” is the number of bits
of CBE. Other methods are using less bits to make their computational time identical to CBE. Second Row: Fixed number of bits.
CBE-opt/CBE-rand are 2-3 times faster than Bilinear-opt/Bilinear-rand, and hundreds of times faster than LSH.

6. Semi-supervised Extension

where, A = A1 + A2 − A3 − A4 , and

In some applications, one can have access to a few labeled
pairs of similar and dissimilar data points. Here we show
how the CBE formulation can be extended to incorporate
such information in learning. This is achieved by adding
an additional objective term J(R).

A1=

argmin||B−XR
B,r

s.t.

||2F

T

+λ||RR −

I||2F

+ µJ(R) (24)

A2=

J(R)=

X

=(diag(F(xi )−F(xj )))T =(diag(F(xi )−F(xj ))),

X

<(diag(F(xi ) − F(xj )))T <(diag(F(xi ) − F(xj ))),

(i,j)∈D

X

=(diag(F(xi ) − F(xj )))T =(diag(F(xi ) − F(xj ))).

(i,j)∈D

||Rxi−Rxj ||22−

i,j∈M

X

(i,j)∈M

A4=

R = circ(r),

<(diag(F(xi ) − F (xj )))T <(diag(F(xi ) − F (xj ))),

(i,j)∈M

A3=
T

X

X

||Rxi−Rxj ||22 .

(25)

i,j∈D

Here M and D are the set of “similar” and “dissimilar” instances, respectively. The intuition is to maximize
the distances between the dissimilar pairs, and minimize
the distances between the similar pairs. Such a term is
commonly used in semi-supervised binary coding methods
(Wang et al., 2010). We again use the time-frequency alternating optimization procedure of Section 4. For a fixed
r, the optimization procedure to update B is the same. For
a fixed B, optimizing r is done in frequency domain by
expanding J(R) as below, with similar techniques used in
Section 4.
||Rxi −Rxj ||22 = (1/d)||diag(F(xi )−F(xj ))r̃||22 .
Therefore,
J(R) = (1/d)(<(r̃)T A<(r̃) + =(r̃)T A=(r̃)),

(26)

Hence, the optimization can be carried out as in Section 4,
where M in (17) is simply replaced by M+µA. Our experiments show that the semi-supervised extension improves
over the non-semi-supervised version by 2% in terms of
averaged AUC on the ImageNet-25600 dataset.

7. Conclusion
We have proposed circulant binary embedding for generating long codes for very high-dimensional data. A novel
time-frequency alternating optimization was also introduced to learn the model parameters from the training data.
The proposed method has time complexity O(d log d) and
space complexity O(d), while showing no performance
degradation on real-world data compared to more expensive approaches (O(d2 ) or O(d1.5 )). On the contrary, for
the fixed time, it showed significant accuracy gains. The
full potential of the method can be unleashed when applied
to ultra-high dimensional data (say d ∼100M), for which
no other methods are applicable.

Circulant Binary Embedding

References
Ailon, Nir and Chazelle, Bernard. Approximate nearest
neighbors and the fast Johnson-Lindenstrauss transform.
In ACM Symposium on Theory of Computing, 2006.
Charikar, Moses S. Similarity estimation techniques from
rounding algorithms. In ACM Symposium on Theory of
Computing, 2002.
Dasgupta, Anirban, Kumar, Ravi, and Sarlós, Tamás. Fast
locality-sensitive hashing. In ACM SIGKDD Conference
on Knowledge Discovery and Data Mining, 2011.
Deng, Jia, Dong, Wei, Socher, Richard, Li, Li-Jia, Li, Kai,
and Fei-Fei, Li. Imagenet: A large-scale hierarchical
image database. In Computer Vision and Pattern Recognition, 2009.
Gong, Yunchao, Kumar, Sanjiv, Verma, Vishal, and Lazebnik, Svetlana. Angular quantization-based binary codes
for fast similarity search. In Advances in Neural Information Processing Systems, 2012.
Gong, Yunchao, Kumar, Sanjiv, Rowley, Henry A, and
Lazebnik, Svetlana. Learning binary codes for highdimensional data using bilinear projections. In Computer
Vision and Pattern Recognition, 2013a.
Gong, Yunchao, Lazebnik, Svetlana, Gordo, Albert, and
Perronnin, Florent. Iterative quantization: A procrustean
approach to learning binary codes for large-scale image
retrieval. IEEE Transactions on Pattern Analysis and
Machine Intelligence, 35(12):2916–2929, 2013b.
Gordo, Albert and Perronnin, Florent. Asymmetric distances for binary embeddings. In Computer Vision and
Pattern Recognition, 2011.

Li, Ping, Shrivastava, Anshumali, Moore, Joshua, and
Konig, Arnd Christian. Hashing algorithms for largescale learning. In Advances in Neural Information Processing Systems, 2011.
Liu, Wei, Wang, Jun, Kumar, Sanjiv, and Chang, Shih-Fu.
Hashing with graphs. In International Conference on
Machine Learning, 2011.
Norouzi, Mohammad and Fleet, David. Minimal loss hashing for compact binary codes. International Conference
on Machine Learning, 2012.
Norouzi, Mohammad, Fleet, David, and Salakhutdinov,
Ruslan. Hamming distance metric learning. In Advances
in Neural Information Processing Systems, 2012.
Oppenheim, Alan V, Schafer, Ronald W, Buck, John R,
et al. Discrete-time signal processing, volume 5. Prentice Hall Upper Saddle River, 1999.
Raginsky, Maxim and Lazebnik, Svetlana. Localitysensitive binary codes from shift-invariant kernels. In
Advances in Neural Information Processing Systems,
2009.
Sánchez, Jorge and Perronnin, Florent. High-dimensional
signature compression for large-scale image classification. In Computer Vision and Pattern Recognition, 2011.
Vybı́ral, Jan. A variant of the Johnson–Lindenstrauss
lemma for circulant matrices. Journal of Functional
Analysis, 260(4):1096–1105, 2011.
Wang, Jun, Kumar, Sanjiv, and Chang, Shih-Fu. Sequential
projection learning for hashing with compact codes. In
International Conference on Machine Learning, 2010.

Gray, Robert M. Toeplitz and circulant matrices: A review.
Now Pub, 2006.

Weiss, Yair, Torralba, Antonio, and Fergus, Rob. Spectral
hashing. In Advances in Neural Information Processing
Systems, 2008.

Hinrichs, Aicke and Vybı́ral, Jan. Johnson-Lindenstrauss
lemma for circulant matrices. Random Structures & Algorithms, 39(3):391–398, 2011.

Zhang, Hui and Cheng, Lizhi. New bounds for circulant Johnson-Lindenstrauss embeddings. arXiv preprint
arXiv:1308.6339, 2013.

Jegou, Herve, Douze, Matthijs, and Schmid, Cordelia.
Product quantization for nearest neighbor search. IEEE
Transactions on Pattern Analysis and Machine Intelligence, 33(1):117–128, 2011.
Krahmer, Felix and Ward, Rachel. New and improved
Johnson-Lindenstrauss embeddings via the restricted
isometry property. SIAM Journal on Mathematical Analysis, 43(3):1269–1281, 2011.
Kulis, Brian and Darrell, Trevor. Learning to hash with binary reconstructive embeddings. In Advances in Neural
Information Processing Systems, 2009.

