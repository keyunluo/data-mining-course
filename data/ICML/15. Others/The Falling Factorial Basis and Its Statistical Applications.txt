The Falling Factorial Basis and Its Statistical Applications

Yu-Xiang Wang
Alex Smola
Ryan J. Tibshirani
Carnegie Mellon University, 5000 Forbes Ave, Pittsburgh, PA 15213

Abstract
We study a novel spline-like basis, which we
name the falling factorial basis, bearing many
similarities to the classic truncated power basis.
The advantage of the falling factorial basis is that
it enables rapid, linear-time computations in basis matrix multiplication and basis matrix inversion. The falling factorial functions are not actually splines, but are close enough to splines that
they provably retain some of the favorable properties of the latter functions. We examine their
application in two problems: trend filtering over
arbitrary input points, and a higher-order variant
of the two-sample Kolmogorov-Smirnov test.

1. Introduction
Splines are an old concept, and they play important roles
in various subfields of mathematics and statistics; see e.g.,
de Boor (1978), Wahba (1990) for two classic references.
In words, a spline of order k is a piecewise polynomial of
degree k that is continuous and has continuous derivatives
of orders 1, 2, . . . k − 1 at its knot points. In this paper,
we look at a new twist on an old problem: we examine a
novel set of spline-like basis functions with sound computational and statistical properties. This basis, which we call
the falling factorial basis, is particularly attractive when
assessing higher order of smoothness via the total variation
operator, due to the capability for sparse decompositions.
A summary of our main findings is as follows.
• The falling factorial basis and its inverse both admit a
linear-time transformation, i.e., much faster decompositions than the spline basis, and even faster than, e.g.,
the fast Fourier transform.
• For all practical purposes, the falling factorial basis
shares the statistical properties of the spline basis. We
Proceedings of the 31 st International Conference on Machine
Learning, Beijing, China, 2014. JMLR: W&CP volume 32. Copyright 2014 by the author(s).

YUXIANGW @ CS . CMU . EDU
ALEX @ SMOLA . ORG
RYANTIBS @ STAT. CMU . EDU

derive a sharp characterization of the discrepancy between the two bases in terms of the polynomial degree
and the distance between sampling points.
• We simplify and extend known convergence results on
trend filtering, a nonparametric regression technique
that implicitly employs the falling factorial basis.
• We also extend the Kolmogorov-Smirnov two-sample
test to account for higher order differences, and utilize
the falling factorial basis for rapid computations. We
provide no theory but demonstrate excellent empirical
results, improving on, e.g., the maximum mean discrepancy (Gretton et al., 2012) and Anderson-Darling
(Anderson & Darling, 1954) tests.
In short, the falling factorial function class offers an exciting prospect for univariate function regularization.
Now let us review some basics. Recall that the set of kth
order splines with knots over a fixed set of n points forms
an (n + k + 1)-dimensional subspace of functions. Here
and throughout, we assume that we are given ordered input points x1 < x2 < . . . < xn and a polynomial order
k ≥ 0, and we define a set of knots T = {t1 , . . . tn−k−1 }
by excluding some of the input points at the left and right
boundaries, in particular,
(
{xk/2+2 , . . . xn−k/2 }
if k is even,
(1)
T =
{x(k+1)/2+1 , . . . xn−(k+1)/2 } if k is odd.
The set of kth order splines with knots in T hence forms
an n-dimensional subspace of functions. The canonical
parametrization for this subspace is given by the truncated
power basis, g1 , . . . gn , defined as
g1 (x) = 1, g2 (x) = x, . . . gk+1 (x) = xk ,
gk+1+j (x) = (x − tj )k · 1{x ≥ tj },

(2)

j = 1, . . . n − k − 1.
These functions can also be used to define the truncated
power basis matrix, G ∈ Rn×n , by
Gij = gj (xi ),

i, j = 1, . . . n,

(3)

The Falling Factorial Basis and Its Statistical Applications

i.e., the columns of G give the evaluations of the basis functions g1 , . . . gn over the inputs x1 , . . . xn . As g1 , . . . gn are
linearly independent functions, G has linearly independent
columns, and hence G is invertible.
As noted, our focus is a related but different set of basis
functions, named the falling factorial basis functions. We
define these functions, for a given order k ≥ 0, as
hj (x) =

j−1
Y

(x − x` ),

j = 1, . . . k + 1,

`=1

hk+1+j (x) =

k
Y

(4)
(x − xj+` ) · 1{x ≥ xj+k },

`=1

j = 1, . . . n − k − 1.
(Our convention is to take the empty product to be 1, so
that h1 (x) = 1.) The falling factorial basis functions are
piecewise polynomial, and have an analogous form to the
truncated power basis functions in (2). Loosely speaking,
they are given by replacing an rth order power function in
the truncated power basis with an appropriate r-term product, e.g., replacing x2 with (x − x2 )(x − x1 ), and (x − tj )k
with (x − xj+k )(x − xj+k−1 ) · . . . (x − xj+1 ). Similar to
the above, we can define the falling factorial basis matrix,
H ∈ Rn×n , by
Hij = hj (xi ),

i, j = 1, . . . n,

(5)

and the linear independence of h1 , . . . hn implies that H
too is invertible.
Note that the first k + 1 functions of either basis, the truncated power or falling factorial basis, span the same space
(the space of kth order polynomials). But this is not true
of the last n − k − 1 functions. Direct calculation shows
that, while continuous, the function hj+k+1 has discontinuous derivatives of all orders 1, . . . k at the point xj+k , for
j = 1, . . . n − k − 1. This means that the falling factorial
functions hk+2 , . . . hn are not actually kth order splines,
but are instead continuous kth order piecewise polynomials that are “close to” splines. Why would we ever use such
a seemingly strange basis as that defined in (4)? To repeat
what was summarized above, the falling factorial functions
allow for linear-time (and closed-form) computations with
the basis matrix H and its inverse. Meanwhile, the falling
factorial functions are close enough to the truncated power
functions that using them in several spline-based problems
(i.e., using H in place of G) can be statistically legitimized.
We make this statement precise in the sections that follow.
As we see it, there is really nothing about their form in
(4) that suggests a particularly special computational structure of the falling factorial basis functions. Our interest
in these functions arose from a study of trend filtering, a
nonparametric regression estimator, where the inverse of

H plays a natural role. The inverse of H is a kind of discrete derivative operator of order k + 1, properly adjusted
for the spacings between the input points x1 , . . . xn . It is
really the special, banded structure of this derivative operator that underlies the computational efficiency surrounding
the falling factorial basis; all of the computational routines
proposed in this paper leverage this structure.
Here is an outline for rest of this article. In Section 2, we
describe a number of basic properties of the falling factorial
basis functions, culminating in fast linear-time algorithms
for multiplication H and H −1 , and tight error bounds between H and the truncated power basis matrix G. Section 3
discusses B-splines, which provide another highly efficient
basis for spline manipulations; we explain why the falling
factorial basis offers a preferred parametrization in some
specific statistical applications, e.g., the ones we present in
Sections 4 and 5. Section 4 covers trend filtering, and extends a known convergence result for trend filtering over
evenly spaced input points (Tibshirani, 2014) to the case of
arbitrary input points. The conclusion is that trend filtering
estimates converge at the minimax rate (over a large class
of true functions) assuming only mild conditions on the inputs. In Section 5, we consider a higher order extension
of the classic two-sample Kolmogorov-Smirnov test. We
find this test to have better power in detecting higher order
(tail) differences between distributions when compared to
the usual Kolmogorov-Smirnov test; furthermore, by employing the falling factorial functions, it can computed in
linear time. In Section 6, we end with some discussion.

2. Basic properties
Consider the falling factorial basis matrix H ∈ Rn×n , as
defined in (5), over input points x1 < . . . < xn . The following subsections describe a recursive decomposition for
H and its inverse, which lead to fast computational methods for multiplication by H and H −1 (as well as H T and
(H T )−1 ). The last subsection bounds the maximum absolute difference bewteen the elements of H and G, the
truncated power basis matrix (also defined over x1 , . . . xn ).
Lemmas 1, 2, 4 below were derived in Tibshirani (2014)
for the special case of evenly spaced inputs, xi = i/n for
i = 1, . . . n. We reiterate that here we consider generic input points x1 , . . . xn . In the interest of space, we defer all
proofs to a supplementary document.
2.1. Recursive decomposition
Our first result shows that H decomposes into a product of
simpler matrices. It helpful to define, for k ≥ 1,

∆(k) = diag xk+1 − x1 , xk+2 − x2 , . . . xn − xn−k ,
the (n − k) × (n − k) diagonal matrix whose diagonal elements contain the k-hop gaps between input points.

The Falling Factorial Basis and Its Statistical Applications

Lemma 1. Let Im denote the m × m identity matrix, and
Lm the m × m lower triangular matrix of 1s. If we write
H (k) for the falling factorial basis matrix of order k, then
in this notation, we have H (0) = Ln , and for k ≥ 1,


Ik
0
(k)
(k−1)
H =H
·
.
(6)
0 ∆(k) Ln−k
Lemma 1 is really a key workhorse behind many properties of the falling factorial basis functions. E.g., it acts as
a building block for results to come: immediately, the representation (6) suggests both an analogous inverse representation for H (k) , and a computational strategy for matrix
multiplication by H (k) . These are discussed in the next two
subsections. We remark that the result in the lemma may
seem surprising, as there is not an apparent connection between the falling factorial functions in (4) and the recursion
in (6), which is based on taking cumulative sums at varying offsets (the rightmost matrix in (6)). We were led to
this result by studying the evenly spaced case; its proof for
the present case is considerably longer and more technical,
but the statement of the lemma is still quite simple.
2.2. The inverse basis
The result in Lemma 1 clearly also implies a result on the
inverse operators, namely, that (H (0) )−1 = L−1
n , and


Ik
0
(H (k) )−1 =
· (H (k−1) )−1 (7)
(k) −1
0 L−1
(∆
)
n−k
for all k ≥ 1. We note that

1 0 ...
 1 1 ...

L−1
m =  ..
 .
1

1

...

−1
0
 T 
0 
e1

,
 =
D(1)

1

(8)

with e1 = (1, 0, . . . 0) ∈ Rm being the first standard basis
vector, and D(1) ∈ R(m−1)×m the first discrete difference
operator


−1
1 0 ...
0 0
 0 −1 1 . . .
0 0 


D(1) = 
(9)
,
..


.
0
0 0 . . . −1 1
With this in mind, the recursion in (7) now looks like the
construction of the higher order discrete difference operators, over the input x1 , . . . xn . To define these operators,
we start with the first order discrete difference operator
D(1) ∈ R(n−1)×n as in (9), and define the higher order
difference discrete operators according to
D(k+1) = D(1) · k · (∆(k) )−1 · D(k) ,

(10)

for k ≥ 1. As D(k+1) ∈ R(n−k−1)×n , leading matrix D(1)
above denotes the (n − k − 1) × (n − k) version of the first
order difference operator in (9).
To gather intuition, we can think of D(k) as a type of
discrete kth order derivative operator across the underlying points x1 , . . . xn ; i.e., given an arbitrary sequence
u = (u1 , . . . un ) ∈ Rn over the positions x1 , . . . xn , respectively, we can think of (D(k) u)i as the discrete kth
derivative of the sequence u evaluated at the point xi . It
is not difficult to see, from its definition, that D(k) is a
banded matrix with bandwidth k + 1. The middle (diagonal) term in (10) accounts for the fact that the underlying positions x1 , . . . xn are not necessarily evenly spaced.
When the input points are evenly spaced, this term contributes only a constant factor, and the difference operators
D(k) , k = 1, 2, 3, . . . take a very simple form, where each
row is a shifted version of the previous, and the nonzero
elements are given by the kth order binomial coefficients
(with alternating signs); see Tibshirani (2014).
By staring at (7) and (10), one can see that the falling factorial basis matrices and discrete difference operators are
essentially inverses of each other. The story is only slightly
more complicated because the difference matrices are not
square.
Lemma 2. If H (k) is the kth order falling factorial basis
matrix defined over the inputs x1 , . . . xn , and D(k+1) is the
(k+1)st order discrete difference operator defined over the
same inputs x1 . . . xn , then


C
(k) −1
,
(11)
(H ) =
1
(k+1)
k! · D
for an explicit matrix C ∈ R(k+1)×n . If we let Ai denote
the ith row of a matrix A, then C has first row C1 = eT1 ,
and subsequent rows


1
· (∆(i) )−1 · D(i) , i = 1, . . . k.
Ci+1 =
(i − 1)!
1
Lemma 2 shows that the last n − k − 1 rows of (H (k) )−1
are given exactly by D(k+1) /k!. This serves as the crucial
link between the falling factorial basis functions and trend
filtering, discussed in Section 4. The route to proving this
result revealed the recursive expressions (6) and (7), and in
fact these are of great computational interest in their own
right, as we discuss next.
2.3. Fast matrix multiplication
The recursions in (6) and (7) allow us to apply H (k) and
(H (k) )−1 with specialized linear-time algorithms. Further,
these algorithms are completely in-place: we do not need
to form the matrices H (k) or (H (k) )−1 , and the algorithms

The Falling Factorial Basis and Its Statistical Applications

Algorithm 1 Multiplication by H (k)
Input: Vector to be multiplied y ∈ Rn , order k ≥ 0,
sorted inputs vector x ∈ Rn .
Output: y is overwritten by H (k) y.
for i = k to 0 do
y(i+1):n = cumsum(y(i+1):n ),
where ya:b denotes the subvector (ya , ya+1 , ..., yb )
and cumsum is the cumulative sum operator.
if i 6= 0 then
y(i+1):n = (x(i+1):n − x1:(n−i) ) .∗ y(i+1):n ,
where .∗ denotes entrywise multiplication.
end if
end for
Return y.
Algorithm 2 Multiplication by (H (k) )−1
Input: Vector to be multiplied y ∈ Rn , order k ≥ 0,
sorted inputs vector x ∈ Rn .
Output: y is overwritten by (H (k) )−1 y.
for i = 0 to k do
if i 6= 0 then
y(i+1):n = yi+1:n ./ (x(i+1):n − x1:(n−i] ),
where ./ is entrywise division.
end if
y(i+2):n = diff(y(i+1):n ),
where diff is the pairwise difference operator.
end for
Return y.

operate entirely by manipulating the input vector (the vector to be multiplied).
Lemma 3. For the kth order falling factorial basis matrix
H (k) ∈ Rn×n , over arbitrary sorted inputs x1 , . . . xn , multiplication by H (k) and (H (k) )−1 can each be computed in
O((k+1)n) in-place operations with zero memory requirements (aside from storing the inputs and the vector to be
multiplied), i.e., we do not need to form H (k) or (H (k) )−1 .
Algorithms 1 and 2 give the details. The same is true for
matrix multiplication by (H (k) )T and [(H (k) )T ]−1 ; Algorithms 3 and 4, found in the supplement, give the details.
Note that the lemma assumes presorted inputs x1 , . . . xn
(sorting requires an extra O(n log n) operations). The routines for multiplication by H (k) and (H (k) )−1 , in Algorithms 1 and 2, are really just given by inverting each term
one at a time in the product representations (6) and (7).
They are composed of elementary in-place operations, like
cumulative sums and pairwise differences. This brings to
mind a comparison to wavelets, as both the wavelet and
inverse wavelets operators can be viewed as highly specialized linear-time matrix multplications.
Borrowing from the wavelet perspective, given a sampled

signal yi = f (xi ), i = 1, . . . n, the action (H (k) )−1 y can
be thought of as the forward transform under the piecewise
polynomial falling factorial basis, and H (k) y as the backward or inverse transform under this basis. It might be interesting to consider the applicability of such transforms to
signal processing tasks, but this is beyond the scope of the
current paper, and we leave it to potential future work.
We do however include a computational comparison between the forward and backward falling factorial transforms, in Algorithms 2 and 1, and the well-studied Fourier
and wavelet transforms. Figure 1(a) shows the runtimes
of one complete cycle of falling factorial transforms (i.e.,
one forward and one backward transform), with k = 3,
versus one cycle of fast Fourier transforms and one cycle of wavelet transforms (using symmlets). The comparison was run in Matlab, and we used Matlab’s “fft” and
“ifft” functions for the fast Fourier transforms, and the
Stanford WaveLab’s “FWT PO” and “IWT PO” functions
(with symmlet filters) for the wavelet transforms (Buckheit
& Donoho, 1995). These functions all call on C implementations that have been ported to Matlab using MEXfunctions, and so we did the same with our falling factorial transforms to even the comparison. For each problem size n, we chose evenly spaced inputs (this is required
for the Fourier and wavelet transforms, but recall, not for
the falling factorial transform), and averaged the results
over 10 repetitions. The figure clearly demonstrates a linear scaling for the runtimes of the falling factorial transform, which matches their theoretical O(n) complexity;
the wavelet and fast fourier transforms also behave as expected, with the former having O(n) complexity, and the
latter O(n log n). In fact, a raw comparison of times shows
that our implementation of the falling factorial transforms
runs slightly faster than the highly-optimized wavelet transforms from the Stanford WaveLab.
For completeness, Figure 1(b) displays a comparison between the falling factorial transforms and the corresponding transforms using the truncated power basis (also with
k = 3). We see that the latter scale quadratically with n,
which is again to be expected, as the truncated power basis
matrix is essentially lower triangular.
2.4. Proximity to truncated power basis
With computational efficiency having been assured by the
last lemma, our next lemma lays the footing for the statistical credibility of the falling factorial basis.
Lemma 4. Let G(k) and H (k) be the kth order truncated
power and falling factorial matrices, defined over inputs
0 ≤ x1 < . . . < xn ≤ 1. Let δ = maxi=1,...n (xi − xi−1 ),
where we write x0 = 0. Then
max

i,j=1,...n

(k)

(k)

|Gij − Hij | ≤ k 2 δ.

The Falling Factorial Basis and Its Statistical Applications
1

0.5

0

10

Runtime (in seconds)

0.45

Runtime (in seconds)

10

Fourier
Wavelet
Falling factorial
B−spline

0.55

0.4
0.35
0.3
0.25
0.2

−1

10

−2

10

−3

10

0.15
−4

10

0.1

Falling factorial
Truncated power

0.05
−5

10
0.5

1

1.5

2

2.5

n

3

3.5

2

4

10

4
6

x 10

10

6

10

n

(a) Falling factorial vs. Fourier, wavelet, (b) Falling factorial (H) vs. truncated
and B-spline transforms (linear scale)
power (G) transforms (log-log scale)
Figure 1. Comparison of runtimes for different transforms. The
experiments were performed on a laptop computer.

This tight elementwise bound between the two basis matrices will be used in Section 4 to prove a result on the
convergence of trend filtering estimates. We will also discuss its importance in the context of a fast nonparametric
two-sample test in Section 5. To give a preview: in many
problem instances, the maximum gap δ between adjacent
sorted inputs x1 , . . . xn is of the order log n/n (for a more
precise statement see Lemma 5), and this means that the
maximum absolute discrepancy between the elements of
G(k) and H (k) decays very quickly.

3. Why not just use B-splines?
B-splines already provide a computationally efficient
parametrization for the set of kth order splines; i.e., since
they produce banded basis matrices, we can already perform linear-time basis matrix multiplication and inversion
with B-splines. To confirm this point empirically, we included B-splines in the timing comparison of Section 2.3,
refer to Figure 1(a) for the results. So, why not always use
B-splines in place of the falling factorial basis, which only
approximately spans the space of splines?
A major reason is that the falling factorial functions (like
the truncated power functions) admit a sparse representation under the total variation operator, whereas the Bspline functions do not. To be more specific, suppose that
f1 , . . . fm are kth order piecewise polynomial functions
with knots at the points 0 ≤ z1P< . . . < zr ≤ 1, where
m
m = r + k + 1. Then, for f = j=1 αj fj , we have



r X
m 

X


(k)
(k)
(k)

TV(f ) =
fj (zi ) − fj (zi−1 ) · αj  ,


i=1  j=1
denoting z0 = 0 for ease of notation. If f1 , . . . fm are the
falling factorial functions defined over the points z1 , . . . zr ,
(k)
(k)
then the term fj (zi ) − fj (zi−1 ) is equal to 0 for all i, j,
except when i = j − k − 1 and j ≥ k + 2, in which case

Pm
it equals 1. Therefore, TV(f (k) ) = j=k+2 |αj |, a simple
sum of absolute coefficients in the falling factorial expansion. The same result holds for the truncated power basis
functions. But if f1 , . . . fm are B-splines, then this is not
true; one can show that in this case TV(f (k) ) = kCαk1 ,
where C is a (generically) dense matrix. The fact that
C is dense makes it cumbersome, both mathematically
and computationally, to use the B-spline parametrization
in spline problems involving total variation, such as those
discussed in Sections 4 and 5.

4. Trend filtering for arbitrary inputs
Trend filtering is a relatively new method for nonparametric
regression. Suppose that we observe
yi = f0 (xi ) + i ,

i = 1, . . . n,

(12)

for a true (unknown) regression function f0 , inputs x1 <
. . . < xn ∈ R, and errors 1 , . . . n . The trend filtering
estimator was first proposed by Kim et al. (2009), and further studied by Tibshirani (2014). In fact, the latter work
motivated the current paper, as it derived properties of the
falling factorial basis over evenly spaced inputs xi = i/n,
i = 1, . . . n, and use these to prove convergence rates for
trend filtering estimators. In the present section, we allow x1 , . . . xn to be arbitrary, and extend the convergence
guarantees for trend filtering, utilizing the properties of the
falling factorial basis derived in Section 2.
The trend filtering estimate β̂ of order k ≥ 0 is defined by
β̂ = argmin
β∈Rn

1
1
ky − βk22 + λ · kD(k+1) βk1 ,
2
k!

(13)

where y = (y1 , . . . yn ) ∈ Rn , D(k+1) ∈ R(n−k−1)×n is
the (k + 1)st order discrete difference operator defined in
(10) over the input points x1 , . . . xn , and λ ≥ 0 is a tuning parameter. We can think of the components of β̂ as
defining an estimated function fˆ over the input points. To
give an example, in Figure 2, we drew noisy observations
from a smooth underlying function, where the input points
x1 , . . . xn were sampled uniformly at random over [0, 1],
and we computed the trend filtering estimate β̂ with k = 3
and a particular choice of λ. From the plot (where we interpolated between (x1 , β̂1 ), . . . (xn , β̂n ) for visualization
purposes), we can see that the implicitly defined trend filtering function fˆ displays a piecewise cubic structure, with
adaptively chosen knot points. Lemma 2 makes this connection precise by showing that such a function fˆ is indeed
a linear combination of falling factorial functions. Letting
β = H (k) α, where H (k) ∈ Rn×n is the kth order falling
factorial basis matrix defined over the inputs x1 , . . . xn , the
trend filtering problem in (13) becomes
α̂ = argmin
α∈Rn

n
X
1
ky − H (k) αk22 + λ ·
|αj |,
2
j=k+2

(14)

The Falling Factorial Basis and Its Statistical Applications

1.0
0.5
−1.0

−0.5

0.0

●●
●

●
●●
● ●
●
●
●●
● ●●
●
●
●
● ●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●●
●
●●
●
●●
●
●
●●

●●
● ●● ●
● ●
●●
●●●●
●●
●●●
●
●
●●
●
●
●
●
●●
●
●
● ●
●
●
●
● ●●
●
●
●
●
●
●●
●
●●
●
●●
●●
● ●● ●●
●
●●●
●
●
●●
●●
●
●● ●
●
●●
● ●
●
●
●
●

−1.5

Trend filtering
Smoothing spline
0.0

●●
●

●

●
●
●
●
●
●●
●●●
● ●● ●● ●●
● ●
●
●●
● ●●● ●
●●●
●
●
●●
●●
●●
● ● ●
●
● ●●
●●
● ●●
●
●
●
●
●
● ●●
●
● ●
●
●
●
●
●
●

0.2

●
●
●
●
●
●●
●
● ●
● ●●
●●
● ●
●
●
●
● ● ●
●
●
●
● ●●
●●
●

●
●

●

●
●

●
●
●●
●
●
●
●
●

●
●
●
●
●
●

●
●

●●

● ●●
●
● ● ●●
● ●●
●●
●
●
● ●
● ●
●
●

0.4

●
●
●
●
●
●

●
●
●
●●

●

●
●●
● ●

●
●

●

●
●●
●

●●
● ●●
●●
● ● ● ●● ●
●● ●● ● ●
●
●
●●
●
●
●
● ●
● ●●
●
● ●●● ●
●
●
● ●
● ●
●
●
●
●
●
●
●
●
●
●●
●
●
●●
● ●
●
●● ●
●
●
●●
●
●
●● ●
●
●
●
●
●
●
●
●
●●
●
●
●
●

●
●●

●
●
●

0.6

● ●
●
●
●
●●

●
●
●
● ●
●●
● ●
● ●
●●
●
● ●●●●
●● ●
●
●
●
● ●●
● ●
●●●
●
● ●●
●●●
●●● ●
●●
●
●
●
●
●
●
●●●●
●●
●
●
●
●
●
●
●
●

●
● ●
●
● ●
●
●

●
● ●
●
● ●●
●
●

●

●

0.8

1.0

Figure 2. Example trend filtering and smoothing spline estimates.

equivalent to the functional minimization problem
n
2
1X
fˆ = argmin
yi − f (xi ) + λ · TV f (k) ), (15)
f ∈Hk 2 i=1

where Hk = span{h1 , . . . hn } is the span of the kth order
falling factorial functions in (4), TV(·) denotes the total
variation operator, and f (k) denotes the kth weak derivative
of f . In other words, the solutions of problems (13) and
(15) are related by β̂i = fˆ(xi ), i = 1, . . . n. The trend
filtering estimate hence verifiably exhibits the structure of
a kth order piecewise polynomial function, with knots at a
subset of x1 , . . . xn , and this function is not necessarily a
spline, but is close to one (since it lies in the span of the
falling factorial functions h1 , . . . hn ).
In Figure 2, we also fit a smoothing spline estimate to the
same example data. A striking difference: the trend filtering estimate is far more locally adaptive towards the middle of plot, where the underlying function is less smooth
(the two estimates were tuned to have the same degrees of
freedom, to even the comparison). This phenomenon is investigated in Tibshirani (2014), where it is shown that trend
filtering estimates attain the minimax convergence rate over
a large class of underlying functions, a class for which it is
known that smoothing splines (along with any other estimator linear in y) are suboptimal. This latter work focused
on evenly spaced inputs, xi = i/n, i = 1, . . . n, and the
next two subsections extend the trend filtering convergence
theory to cover arbitrary inputs x1 , . . . xn ∈ [0, 1]. We first
consider the input points as fixed, and then random. All
proofs are deferred until the supplement.
4.1. Fixed input points
The following is our main result on trend filtering.
Theorem 1. Let y ∈ Rn be drawn from (12), with fixed
inputs 0 ≤ x1 < . . . < xn ≤ 1, having a maximum gap

and i.i.d., mean zero sub-Gaussian errors. Assume that, for
an integer k ≥ 0 and constant C > 0, the true function f0
(k)
is k times weakly differentiable, with TV(f0 ) ≤ C. Then
the kth order trend filtering estimate β̂ in (13), with tuning
parameter value λ = Θ(n1/(2k+3) ), satisfies
n
2
1X
β̂i − f0 (xi ) = OP (n−(2k+2)/(2k+3) ).
n i=1

Remark 1. The rate n−(2k+2)/(2k+3) is the minimax rate of
convergence with respect to the class of k times weakly differentiable functions f such that TV(f (k) ) ≤ C (see, e.g.,
Nussbaum (1985), Tibshirani (2014)). Hence Theorem 1
shows that trend filtering estimates converge at the minimax rate over a broad class of true functions f0 , assuming
that the fixed input points are not too irregular, in that the
maximum adjacent gap between points must satisfy (16).
This condition is not stringent and is naturally satisfied by
continuously distributed random inputs, as we show in the
next subsection. We note that Tibshirani (2014) proved the
same conclusion (as in Theorem 1) for unevenly spaced inputs x1 , . . . xn , but placed very complicated and basically
uninterpretable conditions on the inputs. Our tighter analysis of the falling factorial functions yields the simple sufficient condition (16).
Remark 2. The conclusion in the theorem can be strengthened, beyond the the convergence of β̂ to f0 in (17); under the same assumptions, the trend filtering estimate β̂
also converges to fˆspline at the same rate n−(2k+2)/(2k+3) ,
where we write fˆspline to denote the solution in (15) with
Hk replaced by Gk = span{g1 , . . . gn }, the span of the
truncated power basis functions in (2). This asserts that the
trend filtering estimate is indeed “close to” a spline, and
here the bound in Lemma 4, between the truncated power
and falling factorial basis matrices, is key. Moreover, we
actually rely on the convergence of β̂ to fˆspline to establish (17), as the total variation regularized spline estimator
fˆspline is already known to converge to f0 at the minimax
rate (Mammen & van de Geer, 1997).
4.2. Random input points
To analyze trend filtering for random inputs, x1 , . . . xn , we
need to bound the maximum gap between adjacent points
with high probability. Fortunately, this is possible for a
large class of distributions, as shown in the next lemma.
Lemma 5. If 0 ≤ x1 < . . . < xn ≤ 1 are sorted i.i.d.
draws from an arbitrary continuous distribution supported
on [0, 1], whose density is bounded below by p0 > 0, then
with probability at least 1 − 2p0 n−10 ,
max (xi − xi−1 ) ≤

i=1,...n

max (xi − xi−1 ) = O(log n/n),

i=1,...n

(16)

(17)

for a universal constant c0 .

c0 log n
,
p0 n

The Falling Factorial Basis and Its Statistical Applications

The proof of this result is readily assembled from classical
results on order statistics; we give a simple alternate proof
in the supplement. Lemma 5 implies the next corollary.
Corollary 1. Let y ∈ Rn be distributed according to the
model (12), where the inputs 0 ≤ x1 < . . . < xn ≤ 1
are sorted i.i.d. draws from an arbitrary continuous distribution on [0, 1], whose density is bounded below. Assume
again that the errors are i.i.d., mean zero sub-Gaussian
variates, independent of the inputs, and that the true func(k)
tion f0 has k weak derivatives and satisfies TV(f0 ) ≤ C.
Then, for λ = Θ(n1/(2k+3) ), the kth order trend filtering
estimate β̂ converges at the same rate as in Theorem 1.

5. A higher order Kolmogorov-Smirnov test
The two-sample Kolmogorov-Smirnov (KS) test is a standard nonparametric hypothesis test of equality between
two distributions, say PX and PY , from independent samples x1 , . . . xm ∼ PX and y1 , . . . yn ∼ PY . Writing
X(m) = (x1 , . . . xm ), Y(n) = (y1 , . . . yn ), and Z(m+n) =
(z1 , . . . zm+n ) = X(m) ∪ Y(n) for the joined samples, the
KS statistic can be expressed as
KS(X(m) , Y(n) ) =


m
n

1 X
1X


1{xi ≤ zj } −
1{yi ≤ zj } .
max 
zj ∈Z(m+n)  m

n
i=1
i=1
(18)
This examines the maximum absolute difference between
the empirical cumulative distribution functions from X(m)
and Y(n) , across all points in the joint set Z(m+n) , and so
the test rejects for large values of (18). A well-known alternative (variational) form for the KS statistic is
KS(X(m) , Y(n) ) =




max
ÊX(m) [f (X)] − ÊY(n) [f (Y )] , (19)
f : TV(f )≤1

where ÊX(m) denotes the empirical
Pmexpectation under
X(m) , so that ÊX(m) [f (X)] = 1/m i=1 f (xi ), and similarly for ÊY(n) . The equivalence between (19) and (18)
comes from the fact that maximum in (19) is achieved by
taking f to be a step function, with its knot (breakpoint) at
one of the joined samples z1 , . . . zm+n .
The KS test is perhaps one of the most widely used nonparametric tests of distributions, but it does have its shortcomings. Loosely speaking, it is known to be sensitive in
detecting differences between the centers of distributions
PX and PY , but much less sensitive in detecting differences in the tails. In this section, we generalize the KS
test to “higher order” variants that are more powerful than
the original KS test in detecting tail differences (when, of
course, such differences are present). We first define the

higher order KS test, and describe how it can be computed
in linear time with the falling factorial basis. We then empirically compare these higher order versions to the original
KS test, and several other commonly used nonparametric
two-sample tests of distributions.
5.1. Definition of the higher order KS tests
For a given order k ≥ 0, we define the kth order KS test
statistic between X(m) and Y(n) as



 (k) T 1X(m)
1Y(n) 
(k)
 .

−
KSG (X(m) , Y(n) ) = (G2 )

m
n
∞
(20)
Here G(k) ∈ R(m+n)×(m+n) is the kth order truncated
power basis matrix over the joined samples z1 < . . . <
zm+n , assumed sorted without a loss of generality, and
(k)
G2 is the submatrix formed by excluding its first k + 1
columns. Also, 1X(m) ∈ R(m+n) is a vector whose components indicate the locations of x1 < . . . < xm among
z1 < . . . < zm+n , and similarly for 1Y(n) . Finally, k · k∞
denotes the `∞ norm, kuk∞ = maxi=i,...r |ui | for u ∈ Rr .
As per the spirit of our paper, an alternate definition for the
kth order KS statistic uses the falling factorial basis,



 (k) T 1X(m)
1Y(n) 
(k)
 ,
−
(H
)
KSH (X(m) , Y(n) ) = 

 2
m
n
∞
(21)
where now H (k) ∈ R(m+n)×(m+n) is the kth order falling
factorial basis matrix over the joined samples z1 < . . . <
zm+n . Not surprisingly, the two definitions are very close,
and Hölder’s inequality shows that
(k)

(k)

|KSG (X(m) , Y(n) ) − KSH (X(m) , Y(n) )|
≤

max

i,j=1,...m+n

(k)

(k)

2|Gij − Hij | ≤ 2k 2 δ,

the last inequality due to Lemma 4, with δ the maximum
gap between z1 , . . . zm+n . Recall that Lemma 5 shows δ to
be of the order log(m+n)/(m+n) for continuous distributions PX , PY supported nontrivially on [0, 1], which means
that with high probability, the two definitions differ by at
most 2k 2 log(m + n)/(m + n), in such a setup.
The advantage to using the falling factorial definition is that
the test statistic in (21) can be computed in O((k + 1)(m +
(k)
n)) time, without even having to form the matrix H2 (this
is assuming sorted points z1 , . . . zm+n ). See Lemma 3, and
Algorithm 3 in the supplement. By comparison, the statistic in (20) requires O((m + n)2 ) operations. In addition
to the theoretical bound described above, we also find empirically that the two definitions perform quite similarly, as
shown in the next subsection, and hence we advocate the
(k)
use of KSH for computational reasons.
A motivation for our proposed tests is as follows: it can be
shown that (20), and therefore (21), approximately take a

The Falling Factorial Basis and Its Statistical Applications
1

1

0.9

0.9

0.8

0.8
k=5
k=4

0.6
k=3

0.5
k=2

0.4
k=1

0.3

k=1

0.7

True postive rate

True postive rate

0.7

k=2

0.6
k=3

0.5
k=4

0.4
k=5

0.3

0th order KS
kth order KS (with G)
kth order KS (with H)
Oracle

0.2
0.1

0th order KS
kth order KS (with G)
kth order KS (with H)
Oracle

0.2
0.1

0

0
0

0.1

0.2

0.3

0.4

0.5

0.6

0.7

0.8

0.9

1

0

0.1

0.2

0.3

1

0.9

0.9

0.8

0.8

0.7

0.7

0.6
0.5
0.4

0th order KS
3rd order KS
Rank−sum
MMD
Anderson−Darling
Oracle

0.3
0.2
0.1

0.4

0.5

0.6

0.7

0.8

0.9

1

False postive rate

1

True postive rate

True postive rate

False postive rate

0.6
0.5
0.4

0th order KS
3rd order KS
Rank−sum
MMD
Anderson−Darling
Oracle

0.3
0.2
0.1

0

0
0

0.1

0.2

0.3

0.4

0.5

0.6

0.7

0.8

0.9

1

0

0.1

False postive rate

Figure 3. ROC curves for experiment 1, normal vs. t.

variational form similar to (19), but where the constraint is
over functions whose kth (weak) derivative has total variation at most 1. See the supplement.
5.2. Numerical experiments
We examine the higher order KS tests by simulation. The
setup: we fix two distributions P, Q. We draw n i.i.d. samples X(n) , Y(n) ∼ P , calculate a test statistic, and repeat
this R/2 times; we also draw n i.i.d. samples X(n) ∼ P ,
Y(n) ∼ Q, calculate a test statistic, and repeat R/2 times.
We then construct an ROC curve, i.e., the true positive rate
versus the false positive rate of the test, as we vary its rejection threshold. For the test itself, we consider our kth order
KS test, in both its G and H forms, as well as the usual KS
test, and a number of other popular two-sample tests: the
Anderson-Darling test (Anderson & Darling, 1954; Scholz
& Stephens, 1987), the Wilcoxon rank-sum test (Wilcoxon,
1945), and the maximum mean discrepancy (MMD) test,
with RBF kernel (Gretton et al., 2012).
Figures 3 and 4 show the results of two experiments in
which n = 100 and R = 1000. (See the supplement for
more experiments.) In the first we used P = N (0, 1) and
Q = t3 (t-distribution with 3 degrees of freedom), and
in the second P = Laplace(0) and Q = Laplace(0.3)
(Laplace distributions of different means). We see that our
proposed kth order KS test performs favorably in the first
experiment, with its power increasing with k. When k = 3,
it handily beats all competitors in detecting the difference
between the standard normal distribution and the heavier-

0.2

0.3

0.4

0.5

0.6

0.7

0.8

0.9

1

False postive rate

Figure 4. ROC curves for experiment 2, Laplace vs. Laplace.

tailed t-distribution. But there is no free lunch: in the second experiment, where the differences between P, Q are
mostly near the centers of the distributions and not in the
tails, we can see that increasing k only decreases the power
of the kth order KS test. In short, one can view our proposal as introducing a family of tests parametrized by k,
which offer a tradeoff in center versus tail sensitivity. A
more thorough study will be left to future work.

6. Discussion
We formally proposed and analyzed the spline-like falling
factorial basis functions. These basis functions admit attractive computational and statistical properties, and we
demonstrated their applicability in two problems: trend
filtering, and a novel higher order variant of the KS test.
These examples, we feel, are just the beginning. As typical operations associated with the falling factorial basis
scale merely linearly with the input size (after sorting), we
feel that this basis may be particularly well-suited to a rich
number of large-scale applications in the modern data era,
a direction that we are excited to pursue in the future.
Acknowledgements This work was partially supported by
NSF Grant DMS-1309174, a Google Research Grant, and
the Singapore National Research Foundation under its International Research Centre @ Singapore Funding Initiative and administered by the IDM Programme Office.
Supplement This paper and its accompanying supplement
(with proofs and extra experiments) can be found on arXiv.

The Falling Factorial Basis and Its Statistical Applications

References
Anderson, Theodore and Darling, Donald. A test of goodness of fit. Journal of the American Statistical Association, 49(268):765–769, 1954.
Buckheit, Jonathan and Donoho, David. Wavelab and reproducible research. Lecture Notes in Statistics, 103:55–
81, 1995.
de Boor, Carl. A Practical Guide to Splines. Springer, New
York, 1978.
Gretton, Arthur, Borgwardt, Karsten, Rasch, Malte,
Schölkopf, Bernhard, and Smola, Alexander. A kernel
two-sample test. Journal of Machine Learning Research,
13:723–773, 2012.
Kim, Seung-Jean, Koh, Kwangmoo, Boyd, Stephen, and
Gorinevsky, Dimitry. `1 trend filtering. SIAM Review,
51(2):339–360, 2009.
Mammen, Enno and van de Geer, Sara. Locally apadtive
regression splines. Annals of Statistics, 25(1):387–413,
1997.
Nussbaum, Michael. Spline smoothing in regression models and asymptotic efficiency in L2 . Annals of Statistics,
13(3):984–997, 1985.
Scholz, Fritz and Stephens, Michael. K-sample AndersonDarling tests. Journal of the American Statistical Association, 82(399):918–924, 1987.
Tibshirani, Ryan J. Adaptive piecewise polynomial estimation via trend filtering. Annals of Statistics, 42(1):
285–323, 2014.
Wahba, Grace. Spline Models for Observational Data. Society for Industrial and Applied Mathematics, Philadelphia, 1990.
Wilcoxon, Frank. Individual comparisons by ranking methods. Biometrics Bulletin, 1(6):80–83, 1945.

