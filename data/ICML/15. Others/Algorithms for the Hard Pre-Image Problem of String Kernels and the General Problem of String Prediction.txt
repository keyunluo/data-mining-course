Algorithms for the Hard Pre-Image Problem of String Kernels and
the General Problem of String Prediction

Sébastien Giguère 1,2∗
GIGUERE . SEBASTIEN @ GMAIL . COM
Amélie Rolland 2∗
AMELIE . ROLLAND .1@ ULAVAL . CA
François Laviolette 2
FRANCOIS . LAVIOLETTE @ IFT. ULAVAL . CA
Mario Marchand 2
MARIO . MARCHAND @ IFT. ULAVAL . CA
1
Institute for Research in Immunology and Cancer, University of Montreal, Montreal, Canada
2
Department of Computer Science and Software Engineering, Laval University, Quebec, Canada
∗
These authors contributed equally to this work.

Abstract
We address the pre-image problem encountered
in structured output prediction and the one of
finding a string maximizing the prediction function of various kernel-based classifiers and regressors. We demonstrate that these problems reduce to a common combinatorial problem valid
for many string kernels. For this problem, we
propose an upper bound on the prediction function which has low computational complexity
and which can be used in a branch and bound
search algorithm to obtain optimal solutions. We
also show that for many string kernels, the complexity of the problem increases significantly
when the kernel is normalized.
On the optical word recognition task, the exact
solution of the pre-image problem is shown to
significantly improve the prediction accuracy in
comparison with an approximation found by the
best known heuristic. On the task of finding
a string maximizing the prediction function of
kernel-based classifiers and regressors, we highlight that existing methods can be biased toward long strings that contain many repeated
symbols. We demonstrate that this bias is removed when using normalized kernels. Finally,
we present results for the discovery of lead compounds in drug discovery. The source code can
be found at https://github.com/a-ro/
preimage.

Proceedings of the 32 nd International Conference on Machine
Learning, Lille, France, 2015. JMLR: W&CP volume 37. Copyright 2015 by the author(s).

1. Introduction
This work addresses two combinatorial problems related to
string prediction. For both problems, let A be the set of all
symbols from an alphabet and A∗ be the set of all possible
strings of symbols from that alphabet.
1.1. Structured Output Pre-image
In the structured output prediction framework, the learner
has access to a set S = {(x1 , y1 ), . . . , (xm , ym )} ∈ X ×Y
of input-output pairs. The input space X is arbitrary but we
assume that the output space Y is the set A∗ of strings from
an alphabet A. We assume the existence of an input feature
map φ X : X → HX and an output feature map φ Y : Y →
HY , where both HX and HY are high-dimensional vector
spaces and, more generally, RKHS. The input kernel KX :
X 2 → R is defined by the inner product between vectors
φX (x), φ X (x0 )i ∀(x, x0 ) ∈ X 2 .
in HX , i.e., KX (x, x0 ) = hφ
A similar definition holds for the output kernel KY .
We consider predictors that are linear operators W :
HX → HY . Given any such W, and any x ∈ X , the predicted output yw (x) of W on input x is given by solving
the following structured output pre-image problem


φX (x) ,
yw (x) = argmin φ Y (y) − Wφ
(1)
y∈Y

where k · k denotes the L2 norm in HY . Hence, the preimage problem arises when trying to reconstruct the output from the output feature vector predicted by W. A preimage is said to be exact when there exists y ∈ Y for which
φX (x). Units feature vector φ Y (y) is exactly equal to Wφ
fortunately, an exact pre-image rarely exists for linear operators obtained by vector-valued ridge regression. Hence,
in practice, we have to deal with a hard pre-image problem.
Let us consider normalized output feature vectors. Hence,
def
φ Y (y)
b (y) =
given any φ Y , let us use φ
Y
φ (y)k . Then, equakφ
Y

Algorithms for the Hard Pre-Image Problem of String Kernels and the General Problem of String Prediction

tion (1) becomes
b (y), Wφ
φX (x)i .
yw (x) = argmax hφ
Y

(2)

y∈Y

Given any linear operator W obtained by vectorφX (x)
valued ridge regression, we have Wφ
=
Pm Pm b
φ
(y
)A
K
(x
,
x)
for
some
m
×
m
i,j X
j
i=1
j=1 Y i
matrix A (Cortes et al., 2007). In that case, yw (x)
becomes
argmax
y∈Y

m X
m
X

KY (yi , y)
p

i=1 j=1

KY (yi , yi )KY (y, y)

Ai,j KX (xj , x) .

(3)
As we will see, this paper presents a branch and bound algorithm for solving this combinatorial problem when the
output kernel KY belongs to some family of string kernels.
1.2. String prediction for Classification and Regression
The second problem addressed in this paper consists of
finding the string maximizing the prediction function of
kernel-based classifiers and regressors. For example, finding the string maximizing the prediction function of a
support vector machine consists of finding the positivelylabeled string at greatest distance from the separating hyperplane. Alternatively, the string maximizing the prediction function of a kernel ridge regressor is the string achieving the greatest predicted real value.
In that second framework, the learner has access to a set
S = {(y1 , r1 ), . . . , (ym , rm )} of m training examples
where yi is a string and ri is a scalar label. For example,
yi could be a peptide (a small sequence of amino acids)
and ri could quantify its ability to bind to a certain protein or to inhibit some biological process. Alternatively, ri
could represent one of two classes, namely +1 or −1. For
both cases, the first step is to build a real-valued prediction
function h whose value on any input y is given by
h(y) =

m
X

αi KY (yi , y) ,

(4)

i=1

where the weight vector α = (α1 , . . . , αm ) is obtained by
minimizing an objective function (such as those for support
vector machines or kernel ridge regression), and where KY
is assumed to be a string kernel. In the regression case,
h(y) is the predicted real-valued label for input y. In the
classification case, the predicted class on input y is given
by sgn(h(y)). In both cases, given a predictor, we are interested at finding the input y maximizing the value of the
prediction function h(y), i.e., when the inputs are strings
of length `, we want to solve
yh = argmax h(y) .
y∈A`

(5)

y

y0

KY (y, y0 )

AAB
AAA

AAB
AAB

5
6

√

KY (y,y0 )
KY (y,y)KY (y0 ,y0 )

1
0.89

Table 1. Example using the 1-gram kernel where KY (y,√y0 ) >
0
KY (y0 , y0 ) when
5 and
√ y 6= y . Here, ||φY (AAB)|| =
||φY (AAA)|| = 9.

Recently, an algorithm was proposed (Giguère et al., 2015)
to solve this problem in polynomial time for any prediction function h in the form of Equation (4) when KY belongs to a family of unnormalized string kernels known as
the Generic String (GS) kernel. Their approach consists of
mapping this combinatorial problem to the problem of finding the longest (weighted) path in a directed acyclic graph.
Because the graph is acyclic, this problem is solved by dynamic programming in O(`|A|n+1 ) time, where n is the
maximum sub-string size considered by the GS kernel.
However, there exists an important problem for most string
kernels which can bias the solution of Equation (5) in an
undesirable way. Given two strings y and y0 of the same
length, the Euclidean norms of the feature vectors φ Y (y)
and φ Y (y0 ) induced by an unnormalized string
kernel can
p
K
(y,
y) 
differ
substantially,
i.e.
we
can
have
Y
p
0
0
0
KY (y , y ) even if y and y have the same length.
Consider, for example, two strings AAAAA and ABCDE
and the n-gram kernel with n = 2 (also known as the
Spectrum kernel√ (Leslie et al., 2002)). String AAAAA
2
has
√ a norm of 4 = 4, while ABCDE has a norm of
2
2
2
1 + 1 + 1 + 12 = 2. Hence the norm of the feature
vector induced by this kernel is sensitive to repetitions in
the string. The norm is also influenced by the length of the
string. This problem is shared by most string kernels that
are based on n-gram counts or comparisons.
Note that we can also have KY (y, y0 ) > KY (y, y) while
y 6= y0 . Table 1 shows a simple example when this happens. Consequently, h(y) depends on the norm of φ (y) and
yh is biased toward strings having a feature vector of large
norm, for example, a long string having many n-gram repetitions. For most applications, this is not a desirable bias
which can be removed by normalizing the kernel. In this
case, the prediction function becomes
b
h(y) =

m
X

KY (yi , y)
αi p
.
KY (yi , yi )KY (y, y)
i=1

(6)

Consequently, we are then interested at solving
b
yh = argmax b
h(y) .

(7)

y∈A∗

We will see that, despite its similarity with optimization
problem (5), the increase in computational complexity of
problem (7) is striking.

Algorithms for the Hard Pre-Image Problem of String Kernels and the General Problem of String Prediction

1.3. Unified Optimization Problem
An important observation is that both Equation (7) and
Equation (3) reduce to solving
m

X
1
y? = argmax p
βi KY (yi , y) ,
KY (y, y) i=1
y∈A∗

(8)

for solving Equation (7), and
where βi = √ αi
KY (yi ,yi )
Pm
√ Ai,j
βi = βi (x) =
KX (xj , x) for solving
j=1
KY (yi ,yi )

Equation (3). Observe that for the pre-image problem, this
makes the problem independent of the input kernel KX .
Hence, the rest of this paper will focus on solving this unified problem defined by Equation (8).
The computational complexity of Problem (8) depends on
the choice of string kernel for KY . The use of the Generic
String (GS) kernel (Giguère et al., 2013) is appealing since,
depending on the chosen hyper-parameters, this kernel can
be specialized to eight different kernels; namely, the Hamming kernel, the Blended Spectrum (Shawe-Taylor & Cristianini, 2004), the Radial Basis Function (RBF), the Oligo
(Meinicke et al., 2004), and the Weighted degree (Rätsch &
Sonnenburg, 2004). Hence, any advance in solving Equation (8) would also be applicable to these eight string kernels. The GS kernel was originally proposed for strings
of amino acids by comparing them using their physicochemical properties. Although we present the GS kernel
in a bioinformatics context, the concept of similarity between the elements of a sequence is not limited to this field.
For example, one could use phoneme similarity in speech
recognition, words similarity in part of speech tagging or
synonymous words in machine translation.
Given any pair (y, y0 ) of strings, the value of the GS kernel
is defined as
0

def

GS(y, y0 , n, σp , σc ) =

|−l
n |y|−l
X
X |yX
l=1 i=0


exp

l

ψ (yi+1 ,..,yi+l ) − ψ
−kψ
2σc2

l

exp



j=0

0
0
(yj+1
,..,yj+l
)k2

−(i−j)2
2σp2




,
(9)

where n controls the maximum length of the compared lgrams, ψ l : Al → Rld encodes the physico-chemical properties of l-grams by mapping each of the l amino acids to
a real-valued vector containing d components, σc controls
the penalty incurred when the physico-chemical properties
of two l-grams differ, and σp controls the penalty incurred
when two l-grams are not sharing the same position in their
respective strings.
Our ability to efficiently solve the Problem (8) could contribute to many discoveries. If b
h predicts the binding affin-

ity of a peptide to some protein involved in a certain disb
ease, finding the peptide yh having the highest predicted
binding affinity could have significant impact on our ability to design new drugs. Alternatively, if b
h predicts the
b
anti-microbial activity of a peptide, finding the peptide yh
having the greatest predicted anti-microbial activity could
be a valuable tool in the fight of new infectious diseases.
Most structured output prediction algorithms need to solve
the pre-image for inference, some also during the training
phase. The the accuracy of these algorithms will improve
with a faster and more accurate pre-image solver.
In the next section, we present low computational complexity upper bounds on Equation (8). The bounds are later
used in a branch and bound search to obtain exact solutions
to the unified string prediction problem (8).

2. Method
The computational complexity of Problem (8) depends on
the values of the parameters defining the GS kernel. Parameters σc and σp each control the variance of one Gaussian function. Whenever one of these parameters equals 0,
the related Gaussian function becomes a Dirac delta function. These simpler cases allow for algorithmic optimizations and tighter bounds. For that reason, we consider separately three different cases; from the easiest to the hardest.
2.1. Case when σp = 0


2
is the identity function and is
In that case, exp −(i−j)
2σp2
equal to 1 if i = j and 0 otherwise. Recall that i and j are
the positions of the l-grams in the strings y and y0 . Hence,
only l-grams that are at the same position contribute to the
GS kernel of Equation (9). We recover the Hamming kernel
if (σc = 0 and n = 1), the Weighted Degree kernel (Rätsch
& Sonnenburg, 2004) if (σc = 0 and n > 0), and, finally,
a variant of the Weighted Degree (Toussaint et al., 2010) if
(σc > 0 and n > 0).
All these kernels have the property that KY (y, y) is a constant c for all strings y of the same length. When searching
for a string y having a fixed length `, Equation (8) becomes
m

1 X
y? = argmax √
βi KY (yi , y) ,
c i=1
y∈A`

(10)

with βi defined as in Equation (8). In that case, we recover the problem studied by Giguère et al. (2015). Their
approach uses a graph, similar to a De Bruijn graph, that
has a source and a sink node. The graph has three major properties. First, a single source-sink path is associated to every possible string in A` . Next, the number of
edges and arcs in the graph are dependant of |An |, not
|A` |. Finally, the length (or weight) of a path (a string) is

Algorithms for the Hard Pre-Image Problem of String Kernels and the General Problem of String Prediction

Pm
exactly i=1 βi KY (yi , y). Consequently, the solution y?
of Equation (8) is given by the longest path which can be
found by dynamic programming since the graph is acyclic.
For a string of unknown length, the procedure can be repeated and the string achieving the highest score is kept.
2.2. Case when σp > 0 and σc = 0
When σp > 0, the optimization problem becomes harder
`
because KY (y, y) is no longer
 ∈ A.
 constant for all y
ψl

ψl

0

2

− ψ (s )k
in turn
However, when σc = 0, exp −kψψ (s)2σ
2
c
becomes the identity function and is equal to 1 if the lgrams s and s0 are identical and 0 otherwise. For that reason, we recover the well known Blended Spectrum kernel
(Shawe-Taylor & Cristianini, 2004) if σp = ∞ and the ngram kernel if, in addition, we keep only the term l = n
in the summation over l in Equation (9). When σp is finite,
we recover the Oligo kernel (Meinicke et al., 2004).

2.2.2. B RANCH AND B OUND
A branch and bound algorithm starts by dividing the search
space into disjoint subspaces. For example, one subspace
could be all strings ending with the string DE. For a maximization problem, an upper bound on the best achievable
solution is computed for each subspace. Then, the subspace
with the highest upper bound is further divided. Finally,
the search in a subspace stops when the subspace can no
longer be divided (a leaf is reached in the search tree), or
when the upper bound value is lower than the value of an
already achieved solution (i.e., an already reached leaf in
the search tree). A branch and bound approach can thus
avoid exploring a large part of the search space.

Let us now describe the approach of Cortes et al. (2007)
for the n-gram pre-image to which we will compare later.
Then, we will explain the branch and bound algorithm we
used. Next, we will demonstrate how a tight bound can be
obtained when σc = 0. Later, in Section 2.3, we present a
similar but looser bound for the case when σc > 0.

The search algorithm used here differ slightly from a standard branch and bound. It alternates between a branch and
bound phase and a greedy phase. The later is important
to ensure that leaves of the search tree are quickly visited.
This allows good but sub-optimal solutions to be returned
by the algorithm if the allowed computational time expires.
Whenever a node is visited, the bound is computed for
all its children and they are added to a priority queue accordingly. This greedy process is repeated until a leaf is
reached. Then, the node with the largest bound is visited
and the greedy process starts again. At all time, the best
solution found so far is kept and the search stops when the
bound of the node on top of the priority queue is smaller
than the value of the best solution. The search algorithm is
detailed in the Supplementary Material.

2.2.1. E ULERIAN PATH H EURISTIC

2.2.3. U PPER BOUND WHEN σp > 0 AND σc = 0

Cortes et al. (2007) solved the exact pre-image problem of
the n-gram kernel by finding an Eulerian circuit in a graph.
To find yw (x), the components of the predicted feature
φX (x) are first rounded to obtain a vector z of
vector Wφ
integer values. Each component of z should represent the
number of times each of the possible n-grams appears in
the string yw (x). Then, they define a graph Gz,n , similar to
a De Bruijn graph, composed of a vertex for each possible
(n − 1)-gram in An−1 . Next, the number of edges between
the vertex a1 , .., an−1 and the vertex a2 , .., an is given by
the count of the n-gram a1 , .., an in z. Finally, they predict
a string by constructing the Eulerian circuit in Gz,n (assuming that it exists). However, the exact pre-image does not
φX (x) are not integers.
exist when some components of Wφ
Also, the rounded integer-valued vector z might not give
an Eulerian graph. When facing this problem, the authors
proposed to merge multiple paths together. There is thus no
guarantee on the optimality of the predicted string. Finally,
this heuristic is in O(` + |A|n ) if an Eulerian circuit exists.

An upper bound for a maximization problem takes as
input a partial solution and returns an upper bound of
the maximum achievable with that partial solution. In
our setting, a partial solution y0 = y10 , .., yp0 is the last
p characters of a possibly longer string of ` characters:
y1 , .., y(`−p) , y10 , .., yp0 . That way, we can define A`−p ×
{y0 } as the set of all possible strings of length ` ending
with y10 , . . . , yp0 . Our goal is to have a function F that upper bounds Equation (8) for every string in A`−p × {y0 }.
In other words,

In these cases, the approach of Giguère et al. (2015) is
no longer guaranteed to find the optimal solution of Problem (8). However, it can still be used to compute an upper
bound on partial solutions in a branch and bound search.

m

X
1
p
βi KY (yi , y) .
F (y , `) ≥
max
y∈A`−p ×{y0 }
KY (y, y) i=1
(11)
def
To do so, let F (y0 , `) = √ 1 0 g(y0 , `), where
0

f (y ,`)

f (y0 , `) ≤

min

KY (y, y)

(12)

βi KY (yi , y) .

(13)

y∈A`−p ×{y0 }

and
g(y0 , `) ≥

max

y∈A`−p ×{y0 }

m
X
i=1

Algorithms for the Hard Pre-Image Problem of String Kernels and the General Problem of String Prediction

Observe that the right hand side of the upper bound g(y0 , `)
is the same optimization problem as in Equation (5). For
that reason, the approach of (Giguère et al., 2015) can be
used for the computation of that bound. Their approach
uses a weight table W|A|n ×(`−n+1) and a dynamic programming table T|A|n ×(`−n+1) to compute the longest path
in a graph and it is relatively easy to modify their algorithm
to return the tables instead of the solution. In that way,
given a string with suffix y0 , it is possible to determine,
by accessing T , the value of the prefix from A`−p maximizing the right hand side of Equation (13). This value is
given by the row corresponding to the n-gram y10 , ..., yn0
and the column ` − |y0 | in T . To this we add the weights
of all the n-grams of y20 , ..., yp0 , respectively located at the
columns ` − |y0 | + 1 to ` − n in W . Thus, the algorithm in
O((` − n)|A|n+1 ) only needs to be executed once, before
the branch and bound search, to obtain the value of g(y0 , `)
in constant time for any y0 . Finally, g is the smallest possible upper bound and is exact since there
Pm always exists a
string y ∈ A`−p ×{y0 } with g(y, `) = i=1 βi KY (yi , y).
Let us demonstrate how to obtain the lower bound f (y0 , `)
when KY is the GS kernel with hyper-parameters n , σp
and σc . The bound is defined as follows (more details are
given in Supplementary Material):

=

l=1

i=0

min

y∈Al

X

exp

j=0



−(i−j+|y0 |−`)2
2σp2



0
0
× I(y1 , .., yl = yj+1
, .., yj+l
),

Y Y (d, n, σp , σc ) =

d−1
d−1 X
n X
X

l=1

min

y∈Al

i=0


× exp

X

exp



j=0

−(i−j+|y0 |−`)2
2σp2

0
0
ψ l (y1 ,..,yl ) − ψ l (yj+1
−kψ
,..,yj+l
)k
2
2σc

S(i, j, l, d, σp , σc ) = exp



−(i−j)2
2σp2



exp




(17)


2
,

−l(D(i,j))
2σc2



and
D(i, j) =


0
 max
0

(a,a )∈A2

if i = j,
0

2

ψ (a) − ψ (a )||
||ψ

otherwise.

The computational complexity of Y Y is thus unchanged
since the computation to identify the couple (a, a0 ) only
has to be done once for an alphabet.

3. Results and Discussion

3.1. Pre-image string prediction

Y Y 0 (y0 , `, n, σp , σc )
|y0 |−l

=

(15)

where
0

|y0 |−l

0

n `−|y
X
X|−1

(14)

def

n `−|y
X|−1
X

Y Y 0 (y0 , `, n, σp , σc )

We report the results of our approach on two distinct problems. The first one corresponds to the structured output
pre-image problem and consists of predicting the word associated to an image representation. The second one corresponds to the prediction function maximization problem
and consists of finding the peptide with the greatest predicted bioactivity value.

f (y0 , `) = GS(y0 , y0 , n, σp , σc ) + 2Y Y 0 (y0 , `, n, σp , σc )
+ Y Y (` − |y0 |, n, σp , σc ) ,

grams. In that case,

S(i, j, l, d, σp , σc ), (16)

l=1 i=0 j=0

S(i, j, l, d, σp , σc )

1
if i = j,



 2

−d
if |i − j| ∈ {|A|l , 2|A|l , 3|A|l , ...},
= exp
2
2σ

p



0
otherwise.
Observe that when |A| > `, Y Y 0 is zero and Y Y is n(` −
|y0 |). In contrast with g, the lower bound f is not always
attained since it can underestimate the value of the string
y ∈ A`−p × {y10 , . . . , yp0 } minimizing KY (y, y).
2.3. Case when σp > 0 and σc > 0
When σp > 0 and σc > 0, the functions Y Y 0 and S are
modified to take in account the similarity between the n-

In the first set of experiments, we compared our approach
with the one proposed by Cortes et al. (2007) to solve the
pre-image problem on the optical word recognition task
(Taskar et al., 2004). This task consists of predicting the
handwritten word contained in a binary pixel image. We
used the same 10 folds division as (Taskar et al., 2004),
where each fold has approximately 600 training and 5500
testing examples. The performances were measured according to the percentage of errors on words (0/1 risk),
the percentage of errors on letters (letter risk), and the percentage of character edits (insertions, deletions, substitutions) required to change the predicted words into the correct words (Levenshtein risk). The results were averaged
over the 10 folds.
For both approaches, we used multiple-output ridge regression (Cortes et al., 2007) (with parameter λ) as the
learning algorithm and the polynomial kernel of degree d.
The parameters λ and d were chosen using standard crossvalidation in each fold. The parameters σp and n of the GS
kernel were fixed to obtain the Hamming (σp = 0, n = 1),
the Weighted degree (σp = 0, n = 2, 3), and the n-gram

Algorithms for the Hard Pre-Image Problem of String Kernels and the General Problem of String Prediction

?
yHamming
?
yWeighted
Degree-2
?
yWeighted
Degree-3
?
yGS
?
y2-gram
Eulerian2-gram
?
y3-gram
Eulerian3-gram

0/1 risk

Letter risk

8.10 ±.62
5.77 ±1.1
5.19 ±.91
5.22 ±.93
18.82 ±.72
20.86 ±.67
6.18 ±1.2
6.95 ±.80

4.97 ±.56
3.80 ±.81
3.75 ±.77
3.78 ±.76
12.38 ±.54
13.66 ±.43
4.26 ±.80
4.84 ±.71

Levenshtein
risk
4.95 ±.55
3.78 ±.79
3.73 ±.76
3.75 ±.75
9.76 ±.50
10.93 ±.45
4.17 ±.85
4.59 ±.69

Table 2. Empirical results on the optical word recognition task
when |y| is known at prediction time.

(σp = ∞, n = 2, 3) kernels. Also, to obtain the n-gram
kernel, we fixed l = n in the summation over l in Equations (9), (15), and (16). Otherwise, substrings of length 1
to n would contribute to the kernel, in which case, this is
known as the Blended Spectrum kernel. Finally, we also
present results obtained using the GS kernel where σc , σp
and n are chosen by cross-validation. Note that for all experiments, the branch and bound search was limited to 30
seconds by prediction.
The pre-image heuristic of Cortes et al. (2007) is based on
Eulerian paths and is only valid for the n-gram kernel. We
used the n-gram with n = 2, 3 when comparing with this
approach. Also, for non-unique pre-images, the solution
was randomly chosen among the equivalent solutions.
3.1.1. C ASE WHEN THE LENGTH IS KNOWN
We first considered the case where `, the length of y, is
known at prediction time. For the Eulerian path heuristic,
we normalized and rounded the predicted n-gram counts
to obtain the correct number of n-grams in y. The results
for this setting are summarized in the second and third part
of Table 2. Despite using the same learning algorithm and
n-gram kernel, the accuracies of both methods differ significantly. The heuristic of rounding the predicted n-gram
counts into integer values probably explains the decrease
in accuracy. This suggests that, when possible, the exact
computation of the pre-image is preferable.
The best results were obtained when using the Weighted
degree kernel with n = 3. This suggests that, for this task,
the positions of the n-gram in the words are important. Previously lacking a pre-image algorithm for this kernel, this
is the first time it has been used for optical word recognition. Interestingly, the Weighted degree is among the cases
where its pre-image is computable in polynomial time.
3.1.2. C ASE WHEN THE LENGTH IS UNKNOWN
The second setting consists of a more difficult pre-image
problem where `, the length of the output word y, is un-

0/1 risk
?
yHamming
?
yWeighted
Degree-2
?
yWeighted
Degree-3
?
yGS
?
y2-gram
Eulerian2-gram
?
y3-gram
Eulerian3-gram

8.25 ±.63
6.01 ±1.1
5.46 ±.95
5.47 ±.96
22.29 ±.85
64.11 ±2.0
9.07 ±.65
34.76 ±2.5

Levenshtein
risk
5.15 ±.54
3.78 ±.60
3.79 ±.58
3.93 ±.73
11.67 ±.42
32.62 ±1.6
6.01 ±.50
17.25 ±1.2

Table 3. Empirical results on the optical word recognition task
when |y| is unknown at prediction time.

known at prediction time. For this task, the search algorithm was modified to take as parameters the minimum
length `min and the maximum length `max observed in the
training set instead of the exact length `. We then created
a priority queue for each of the `max − `min + 1 lengths.
At every iteration, the best node of each priority queue was
explored. Only the best solution over all lengths was kept.
This allowed the algorithm to stop exploring the solutions
for a specific length if the node on top of that priority queue
had a smaller bound than the best solution found.
For the Eulerian path algorithm, we followed the procedure
as explained in Cortes et al. (2007). That is, we chose a
threshold tj for each n-gram and rounded to one the count
φX (x))j > tj . Each
of the j-th predicted n-gram if (Wφ
threshold
training set in a way
Pm tj was selected using theP
φX (xi ))j > tj ] = m
that i=1 I [(Wφ
i=1 φ Y (yi )j . When
φ
no components of Wφ X (x) were above the thresholds, we
φX (x))j .
rounded to one the `min − n + 1 highest (Wφ
Table 3 reports the results for this setting. A decrease in
accuracy was observed for both approaches, but is substantially greater for the Eulerian path algorithm. This could
be explained by the difficulty of finding the thresholds for
which all test examples would have the correct predicted
number of n-grams. As for the branch and bound algorithm, the increased number of possible solutions over all
lengths made it harder to find the exact pre-image during
the 30 seconds allowed for the search. However, as seen in
Table 3, the solutions returned by the best-first scheme of
the branch and bound generally outperformed the approximations made by the Eulerian path algorithm.
Note that, for this setting, Cortes et al. (2007) have reported
a 0/1 risk of 34.7 ± 2.3 by using a different kernel over
the input x, and a 0/1 risk of 24.4 ± 1.5 by combining the
predictions obtained with different values of n. However,
even with these improvements, the proposed approach still
achieve better accuracy. Given the popularity of the n-gram
kernel, the fact that it is outperformed by the Weighted Degree and other kernels (see Tables 2 and 3) is noteworthy.

Algorithms for the Hard Pre-Image Problem of String Kernels and the General Problem of String Prediction

Predictor
h
b
h
hσp =∞
b
hσp =∞

BPPs
0.6134
0.6128
0.5111
0.5589

CAMPs
0.5916
0.5918
0.5222
0.5351

Table 4. 10-fold cross-validation R2 of the predictors on the BPPs
and CAMPs datasets. Computed using the union of the 10 validation sets.

3.1.3. E XECUTION TIME ANALYSIS
For the Hamming and the Weighted degree, with n = 2, it
took an average of 15 milliseconds (ms) per prediction in
both settings. For the Weighted degree, when n = 3, the
time increased to 35 ms and 50 ms in the first and second
setting respectively. The branch and bound search for the
n-gram, with n = 2, 3, was allowed a maximum of 30 seconds. In the known length case, the search ended in the allowed time 99.94% of the time, with an average of 159 ms
per prediction for the 2-gram and 70 ms for the 3-gram. In
the unknown length case, the branch and bound was forced
to terminate most of the time. However, as shown in Table 3, the correct output string was generally found. The
branch and bound for the unknown length case was executed on one core of an Intel Xeon X5560 CPUs (2.8GHz).
All other results were computed on one core of an Intel
Core i7 (1.9GHz).
In comparison with the results of Table 2, the initial depth
first search guided by the bounds gave a 0/1 loss of 44.48%
for the 2-gram and 7.94% for the 3-gram. Demonstrating
the usefulness of the full branch and bound procedure.
3.2. String prediction for Classification and Regression
We followed the protocol suggested in Giguère et al. (2015)
and used the same two bioactivity regression datasets they
used. The first contains 101 cationic antimicrobial pentadecapeptides (CAMPs) (Wade & Englund, 2002). The
second dataset consists of 31 bradykinin-potentiating pentapeptides (BPPs) (Ufkes et al., 1982).
As in Giguère et al. (2015), we used kernel ridge regression
as the learning algorithm. Except when stated otherwise,
all hyper-parameters for the GS kernel (n, σc , σp ) and the
kernel ridge regression (λ) were chosen by standard crossvalidation. For each dataset, we learned two predictors, the
first denoted by h uses an unnormalized kernel (the predictor used in Giguère et al. (2015)). The second, denoted by
b
h, was trained using a normalized kernel. For some experiments, all hyper-parameters except σp = ∞ were chosen
by cross-validation. When this is the case, we will refer
to the two predictors by hσp =∞ and b
hσp =∞ . The R2 (coefficient of determination) of all predictors are shown in
Table 4.

As explained in Section 2.1, whenever σp = 0, the sob
lutions yh and yh are the same. The motivations behind
presenting results obtained from the predictors hσp =∞ and
b
hσp =∞ are two folds. First, it highlights the regime in
which yh and yh differ the most. Second, many kernels,
including the n-gram and the Blended Spectrum, are only
obtained when σp = ∞. These kernels are commonly
used, it this thus important to evaluate the proposed approach when using these even if they were not selected by
cross-validation for the specific task studied here.
b

3.2.1. C OMPARING THE SOLUTIONS FOUND
The first experiment compares the peptides found by both
approaches under two different settings: the first uses h and
b
h, while the second uses hσp =∞ and b
hσp =∞ .
In the first setting, the method of Giguère et al. (2015) was
used to identify yh ∈ A15 and yh ∈ A5 , respectively for
the CAMPs and BPPs dataset. The branch and bound was
b
b
used to identify yh ∈ A15 and yh ∈ A5 . The results are
shown in the first half of Table 5. On the two datasets,
both methods identified the same peptides. On the CAMPs
and the BPPs datasets, the values of σp , chosen by crossvalidation, are respectively 0.8 and 0.2. Since the values of
σp are so close to 0, it is normal that both methods found
the same solutions. This also suggests that the method
of Giguère et al. (2015) offers some resistance to variation
in the norm of φ Y (y) when σp is small.
In the second setting, we used the predictors hσp =∞ and
b
hσp =∞ .The solutions found by both methods are shown
in the second half of Table 5. In that setting, the solution yhσp =∞ contains many n-gram repetitions. On the
BPPs dataset, the solution contained two times the 2-gram
WA. On the CAMPs dataset, the solution is basically the
repetition of the 2-grams FK and KI. Hence, in situations
where the norm of feature vectors can vary a lot, h favors
strings having repetitions, thus a feature vector of large
norm. However, this bias is generally unjustified and not
biologically founded for peptides. In contrast, the solution
b
yhσp =∞ found by the branch and bound contains no repetition for the BPPs dataset and fewer for the CAMPs dataset.
Finally, the solutions found by the branch and bound share
many substructures with the most bioactive peptides of the
training sets.
3.2.2. C OMPARING THE NORMS AND THE LENGTHS
The second experiment quantitatively compares
b
φY (yhσp =∞ )|| with ||φ
φY (yhσp =∞ )||.
||φ
To make the
comparison more informative, we use the fact that the
method of Giguère et al. (2015) can output a rank of the
k sequences having the greatest predicted value, such that
[h(y1h ) ≥ h(y2h ) ≥ . . . ≥ h(ykh )]. This is also possible for

Algorithms for the Hard Pre-Image Problem of String Kernels and the General Problem of String Prediction

CAMPs
WWKWWKRLRRLFLLV
WWKWWKRLRRLFLLV
FKKIFKKIFKKIFKF
WKKIFKKIWKFRVFK

Table 5. Predicted peptides with highest bioactivity on BPPs and
CAMPs datasets

the branch and bound by stopping the search only when
the bound on top of the priority queue is lower than the
k-th string found. For both datasets, we found the 1000 top
peptides maximizing the un-normalized predictor hσp =∞
and the normalized predictor b
hσp =∞ . Then, we compared
the cumulative moving average norm of the feature vectors
for all peptides.
The results on both datasets are shown in Figure 1. We
observe that the branch and bound favored solutions with
feature vectors of smaller norm.
The last experiment compares the ability of each method to
handle strings of different lengths. This experiment is similar to the optical word recognition case where the length
of the output word is unknown. Using both methods, we
b
found yh ∈ A` and yh ∈ A` for different string lengths `.
The results for both datasets are shown in Figure 2. The
maximum bioactivity of h as a function of `, increases,
then stabilizes. In contrast, the maximum bioactivity of
b
h peaks near the optimal length, then decreases. This coincides more closely with our current understanding of the
biology. This synthetic experiment suffices to highlight that
when kernels are not normalized the solution yh will be bib
ased towards the longest possible string, a bias that yh does
not suffer from. Finally, the same comparison is done for
hσp =∞ and b
hσp =∞ in the Supplementary Material.
3.2.3. E XECUTION TIME ANALYSIS
The branch and bound search for the b
h predictor took 5 seconds and 48 seconds respectively for the BPPs and CAMPs
datasets. The time increased to 10 seconds and 23 minutes
to find the 1000 best peptides. The search for the b
hσp =∞
predictor on the BPPs dataset took 8 seconds for the best
peptide and 15 seconds for the 1000 best peptides. The
branch and bound did not terminate for the b
hσp =∞ predictor on the CAMPs dataset. However, the best peptide found
after 10 minutes was the same as after 20 hours, suggesting
that proving optimality might be the crux of the problem.

4. Conclusion
First, we demonstrated that the structured output pre-image
problem and the string prediction problem with normalized

hσp =∞
b
hσp =∞

4.2

Average norm

BPPs
IEWAK
IEWAK
WAKWA
VEWAK

4

12
11

3.6

10
0

hσp =∞
b
hσp =∞

13

3.8
3.4

0

500
1,000
Peptide rank

500
1,000
Peptide rank

φY (y)|| for the 1, 000
Figure 1. Cumulative moving average of ||φ
peptides with highest predicted bioactivities for the BPPs (left)
and the CAMPs (right) datasets.

Bioactivity

Method
yh
b
yh
yhσp =∞
b
yhσp =∞

1

2

1.5

h
b
h

4
6
8 10
Peptide length

0.5

h
b
h

5
10 15 20
Peptide length

Figure 2. Maximum predicted bioactivity as a function of the peptide length for the BPPs (left) and the CAMPs (right) datasets.

kernels both reduce to a unique combinatorial problem. We
showed that for some string kernels, it is sometimes possible to solve this problem in polynomial time. When it is
not possible, we proposed a low computational complexity
upper bound for this problem. We demonstrated the usefulness of the bound in a branch and bound algorithm.
On the practical task of optical word recognition, the proposed approach significantly outperforms an existing preimage heuristic whether the lengths of the words in the
testing set are known or unknown. Also, empirical results
show that the method proposed by Giguère et al. (2015) is
biased toward strings having a feature with a large norm,
a problem common to most string kernels. In these situations, the proposed method was shown to overcome this
bias and new applications in structured output and string
prediction are thus expected.
The g(y0 , `) bound was shown to be optimal. However, the
f (y0 , `) bound could benefit from improvement, specifically in the case when σp > 0 and σc > 0. Finally, to
further improve F (y0 , `), one could explore dual decomposition and Lagrangian relaxation methods (Fisher, 2004;
Rush & Collins, 2014) to exploit the difference between
the solution approaching g(y0 , `) and the one approaching
f (y0 , `).

Algorithms for the Hard Pre-Image Problem of String Kernels and the General Problem of String Prediction

Acknowledgments
The authors would like to thank Claude-Guy Quimper for
his insightful recommendations on the branch and bound.
This work was supported in part by NSERC Discovery
grants (FL:262067 , MM: 122405), by Fonds de recherche
du Québec (FRQNT) (FL, MM: 2013-PR-166708), by
Compute Canada, and by an award to Michael Tyers from
the Ministère de l’enseignement supérieur, de la recherche,
de la science et de la technologie du Québec through
Génome Québec. AR is recipient of a Master’s Scholarship from the FRQNT.

References
Cortes, Corinna, Mohri, Mehryar, and Weston, Jason.
A general regression framework for learning string-tostring mappings. In Bakır, Gökhan, Hofmann, Thomas,
Schölkopf, Bernhard, Smola, Alexander J., Taskar, Ben,
and Vishwanathan, S. (eds.), Predicting Structured Data,
chapter 8, pp. 143–168. MIT Press, Cambridge, MA,
2007.
Fisher, Marshall L. The lagrangian relaxation method for
solving integer programming problems. Management
science, 50(12 supplement):1861–1871, 2004.
Giguère, Sébastien, Marchand, Mario, Laviolette,
François, Drouin, Alexandre, and Corbeil, Jacques.
Learning a peptide-protein binding affinity predictor
with kernel ridge regression. BMC Bioinformatics, 14,
2013.
Giguère, Sébastien, Laviolette, François, Marchand,
Mario, Tremblay, Denise, Moineau, Sylvain, Liang,
Xinxia, Biron, Éric, and Corbeil, Jacques. Machine
learning assisted design of highly active peptides for
drug discovery. PLoS Comput Biol, 11(4):e1004074, 04
2015. doi: 10.1371/journal.pcbi.1004074.
Leslie, Christina S, Eskin, Eleazar, and Noble,
William Stafford. The spectrum kernel: A string
kernel for svm protein classification. In Pacific symposium on biocomputing, volume 7, pp. 566–575. World
Scientific, 2002.
Meinicke, P., Tech, M., Morgenstern, B., and Merkl, R.
Oligo kernels for datamining on biological sequences:
A case study on prokaryotic translation initiation sites.
BMC Bioinformatics, 5, 2004.
Rätsch, Gunnar and Sonnenburg, Sören. Accurate Splice
Site Detection for Caenorhabditis elegans. In B and Vert,
J. P. (eds.), Kernel Methods in Computational Biology,
pp. 277–298. MIT Press, 2004.

Rush, Alexander M and Collins, Michael. A tutorial on
dual decomposition and lagrangian relaxation for inference in natural language processing. arXiv preprint
arXiv:1405.5208, 2014.
Shawe-Taylor, John and Cristianini, Nello. Kernel methods
for pattern analysis. Cambridge university press, 2004.
Taskar, Ben, Guestrin, Carlos, and Koller, Daphne. Maxmargin Markov networks. In Thrun, Sebastian, Saul,
Lawrence, and Schölkopf, Bernhard (eds.), Advances in
Neural Information Processing Systems 16. MIT Press,
Cambridge, MA, 2004.
Toussaint, Nora, Widmer, Christian, Kohlbacher, Oliver,
and Rätsch, Gunnar. Exploiting physico-chemical properties in string kernels. BMC bioinformatics, 11(Suppl
8):S7, 2010.
Ufkes, Jan G.R., Visser, Berend J., Heuver, Gerritdina,
Wynne, Herman J., and Meer, Cornelis Van Der. Further studies on the structure-activity relationships of
bradykinin-potentiating peptides. European Journal of
Pharmacology, 79(12):155 – 158, 1982.
Wade, David and Englund, Jukka. Synthetic antibiotic peptides database. Protein and peptide letters, 9(1):53–57,
2002.

