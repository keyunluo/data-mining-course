Linear Programming for Large-Scale Markov Decision Problems

Yasin Abbasi-Yadkori
Queensland University of Technology, Brisbane, QLD, Australia 4000
Peter L. Bartlett
University of California, Berkeley, CA 94720
and Queensland University of Technology, Brisbane, QLD, Australia 4000
Alan Malek
University of California, Berkeley, CA 94720

Abstract
We consider the problem of controlling a Markov
decision process (MDP) with a large state space,
so as to minimize average cost. Since it is intractable to compete with the optimal policy for
large scale problems, we pursue the more modest
goal of competing with a low-dimensional family of policies. We use the dual linear programming formulation of the MDP average cost problem, in which the variable is a stationary distribution over state-action pairs, and we consider a
neighborhood of a low-dimensional subset of the
set of stationary distributions (defined in terms
of state-action features) as the comparison class.
We propose a technique based on stochastic convex optimization and give bounds that show that
the performance of our algorithm approaches the
best achievable by any policy in the comparison
class. Most importantly, this result depends on
the size of the comparison class, but not on the
size of the state space. Preliminary experiments
show the effectiveness of the proposed algorithm
in a queuing application.

1. Introduction
We study the average loss Markov decision process problem. The problem is well-understood when the state and
action spaces are small (Bertsekas, 2007). Dynamic programming (DP) algorithms, such as value iteration (Bellman, 1957) and policy iteration (Howard, 1960), are stanProceedings of the 31 st International Conference on Machine
Learning, Beijing, China, 2014. JMLR: W&CP volume 32. Copyright 2014 by the author(s).

YASIN . ABBASIYADKORI @ QUT. EDU . AU

BARTLETT @ EECS . BERKELEY. EDU

MALEK @ EECS . BERKELEY. EDU

dard techniques to compute the optimal policy. In large
state space problems, exact DP is not feasible as the computational complexity scales quadratically with the number
of states.
A popular approach to large-scale problems is to restrict
the search to the linear span of a small number of features.
The objective is to compete with the best solution within
this comparison class. Two popular methods are Approximate Dynamic Programming (ADP) and Approximate Linear Programming (ALP). This paper focuses on ALP. For
a survey on theoretical results for ADP see (Bertsekas and
Tsitsiklis, 1996; Sutton and Barto, 1998), (Bertsekas, 2007,
Vol. 2, Chapter 6), and more recent papers (Sutton et al.,
2009b;a; Maei et al., 2009; 2010).
Our aim is to develop methods that find policies with performance guaranteed to be close to the best in the comparison class but with computational complexity that does not
grow with the size of the state space. All prior work on
ALP either scales badly or requires access to samples from
a distribution that depends on the optimal policy.
This paper proposes a new algorithm to solve the Approximate Linear Programming problem that is computationally
efficient and does not require knowledge of the optimal policy. In particular, we introduce new proof techniques and
tools for average cost MDP problems and use these techniques to derive a reduction to stochastic convex optimization with accompanying error bounds.
1.1. Notation
Let X and A be positive integers. Let X = {1, 2, . . . , X}
and A = {1, 2, . . . , A} be state and action spaces, respectively. Let ‚àÜS denote probability distributions over set S.
A policy œÄ is a map from the state space to ‚àÜA : œÄ : X ‚Üí
‚àÜA . We use œÄ(a|x) to denote the probability of choosing
action a in state x under policy œÄ. A transition probability

Linear Programming for Large-Scale Markov Decision Problems

kernel (or transition kernel) P : X √ó A ‚Üí ‚àÜX maps from
the direct product of the state and action spaces to ‚àÜX . Let
P œÄ denote the probability transition kernel under policy œÄ.
A loss function is a bounded real-valued function over state
and action spaces, ` : X √ó A ‚Üí [0, 1]. Let Mi,: and M:,j
denote ith rowP
and jth column of matrix M respectively.
Let kvk1,c =
i ci |vi | and kvk‚àû,c = maxi ci |vi | for a
positive vector c. We use 1 and 0 to denote vectors with all
elements equal to one and zero, respectively. We use ‚àß and
‚à® to denote the minimum and the maximum, respectively.
For vectors v and w, v ‚â§ w means element-wise inequality,
i.e. vi ‚â§ wi for all i.
1.2. Linear Programming Approach to Markov
Decision Problems
Under certain assumptions, there exist a scalar Œª‚àó and a
vector h‚àó ‚àà RX that satisfy the Bellman optimality equations for average loss problems,
"
#
X
0
Œª‚àó + h‚àó (x) = min `(x, a) +
P(x,a),x0 h‚àó (x ) .
a‚ààA

x0 ‚ààX

The scalar Œª‚àó is called the optimal average loss, while the
vector h‚àó is called a differential value function. The action
that minimizes the right-hand side of the above equation is
the optimal action in state x and is denoted by a‚àó (x). The
optimal policy is defined by œÄ‚àó (a‚àó (x)|x) = 1. Given `
and P , the objective of the planner is to compute the optimal action in all states, or equivalently, to find the optimal
policy.
The MDP problem can also be stated in the LP formulation (Manne, 1960),
max Œª ,

The objective function, ¬µ> `, is the average loss under stationary distribution ¬µ. The first two constraints ensure
that ¬µ is a probability distribution over state-action space,
while the last constraint ensures that ¬µ is a stationary distribution. Given a P
solution ¬µ, we can obtain a policy via
œÄ(a|x) = ¬µ(x, a)/ a0 ‚ààA ¬µ(x, a0 ).
1.3. Approximations for Large State Spaces
The LP formulations (1) and (2) are not practical for large
scale problems as the number of variables and constraints
grows linearly with the number of states. Schweitzer
and Seidmann (1985) propose approximate linear programming (ALP) formulations. These methods were later improved by de Farias and Van Roy (2003a;b); Hauskrecht
and Kveton (2003); Guestrin et al. (2004); Petrik and Zilberstein (2009); Desai et al. (2012). As noted by Desai
et al. (2012), the prior work on ALP either requires access
to samples from a distribution that depends on the optimal
policy or assumes the ability to solve an LP with as many
constraints as states. (See Appendix A for a more detailed
discussion.) Our objective is to design algorithms for very
large MDPs that do not require knowledge of the optimal
policy.
In contrast to the aforementioned methods, which solve the
primal ALPs (with value functions as variables), we work
with the dual form (2) (with stationary distributions as variables). Analogous to ALPs, we control the complexity by
limiting our search to a linear subspace defined by a small
number of features. Let d be the number of features and Œ¶
be a (XA) √ó d matrix with features as column vectors. By
adding the constraint ¬µ = Œ¶Œ∏, we get
min Œ∏> Œ¶> ` ,
Œ∏

(1)

Œª,h

s.t.

Œ∏> Œ¶> 1 = 1, Œ¶Œ∏ ‚â• 0, Œ∏> Œ¶> (P ‚àí B) = 0 .

s.t. B(Œª1 + h) ‚â§ ` + P h ,
where B ‚àà {0, 1}XA√óX is a binary matrix such that the ith
column has A ones in rows 1+(i‚àí1)A to iA. Let vœÄ be the
stationary distribution under policy œÄ and let ¬µœÄ (x, a) =
vœÄ (x)œÄ(a|x). We can write
X
X
œÄ‚àó = argmin
vœÄ (x)
œÄ(a|x)`(x, a)
œÄ

= argmin
œÄ

x‚ààX

X

If a stationary distribution ¬µ0 is known, it can be added to
the linear span to get the ALP
min(¬µ0 + Œ¶Œ∏)> ` ,
Œ∏

s.t.

(¬µ0 + Œ¶Œ∏)> 1 = 1, ¬µ0 + Œ¶Œ∏ ‚â• 0,
(¬µ0 + Œ¶Œ∏)> (P ‚àí B) = 0 .

a‚ààA

Although ¬µ0 + Œ¶Œ∏ might not be a stationary distribution, it
still defines a policy1

¬µœÄ (x, a)`(x, a)

(x,a)‚ààX √óA

= argmin ¬µ>
œÄ` .

[¬µ0 (x, a) + Œ¶(x,a),: Œ∏]+
,
0
a0 [¬µ0 (x, a ) + Œ¶(x,a0 ),: Œ∏]+

œÄ

œÄŒ∏ (a|x) = P

In fact, the dual of LP (1) has the form of
min ¬µ> ` ,

¬µ‚ààRXA

s.t.

(3)

¬µ> 1 = 1, ¬µ ‚â• 0, ¬µ> (P ‚àí B) = 0 .

(2)

(4)

We denote the stationary distribution of this policy ¬µŒ∏ ,
which is only equal to ¬µ0 + Œ¶Œ∏ if Œ∏ is in the feasible set.
1

We use the notation [v]‚àí = v ‚àß 0 and [v]+ = v ‚à® 0.

Linear Programming for Large-Scale Markov Decision Problems

1.4. Problem definition
With the above notation, we can now be explicit about the
problem we are solving.
Definition 1 (Efficient Large-Scale Dual ALP). For an
MDP specified by ` and P , a feature matrix Œ¶ and a stationary distribution ¬µ0 , the efficient large-scale dual ALP
problem is to produce parameters Œ∏b such

	
¬µ>
` ‚â§ min ¬µ>
(5)
Œ∏ ` : Œ∏ feasible for (3) + O()
Œ∏b
in time polynomial in d and 1/. The model of computation
allows access to arbitrary entries of Œ¶, `, P , ¬µ0 , P > Œ¶, and
1> Œ¶ in unit time.
Importantly, the computational complexity cannot scale
with X and we do not assume any knowledge of the optimal policy. In fact, as we shall see, we solve a harder
problem, which we define as follows.
Definition 2 (Expanded Efficient Large-Scale Dual ALP).
Let V : <d ‚Üí <+ be some ‚Äúviolation function‚Äù that represents how far ¬µ0 + Œ¶Œ∏ is from a valid stationary distribution, satisfying V (Œ∏) = 0 if Œ∏ is a feasible point for
the ALP (3). The expanded efficient large-scale dual ALP
problem is to produce parameters Œ∏b such that


1
d
>
V
(Œ∏)
:
Œ∏
‚àà
<
+ O(),
(6)
`
‚â§
min
¬µ
`
+
¬µ>
Œ∏
Œ∏b

in time polynomial in d and 1/, under the same model of
computation as in Definition 1.
Note that the expanded problem is strictly more general as
guarantee (6) implies guarantee (5). Also, many feature
vectors Œ¶ may not admit any feasible points. In this case,
the dual ALP problem is trivial, but the expanded problem
is still meaningful.
Having access to arbitrary entries of the quantities in Definition 1 arises naturally in many situations. In many cases,
entries of P > Œ¶ are easy to compute. For example, suppose
that for any state x0 there is a small number of state-action
pairs (x, a) such that P (x0 |x, a) > 0. Consider Tetris; although the number of board configurations is large, each
state has a small number of possible neighbors. Dynamics specified by graphical models with small connectivity
also satisfy this constraint. Computing entries of P > Œ¶ is
also feasible given reasonable features. If a feature œïi is
a stationary distribution, then P > œïi = B > œïi . Otherwise,
it is our prerogative to design sparse feature vectors, hence
making the multiplication easy. We shall see an example of
this setting later.

(standard) assumption that any policy converges quickly
to its stationary distribution. Our algorithm take as input a constant S and an error tolerance , and has access to the various quantities listed in Definition 1. Define
Œò = {Œ∏ : Œ∏> Œ¶> 1 = 1 ‚àí ¬µ>
0 1, kŒ∏k ‚â§ S}. If no stationary
distribution is known, we can simply choose ¬µ0 = 0. The
algorithm is based on stochastic convex optimization. We
prove that for any Œ¥ ‚àà (0, 1), after O(1/4 ) steps of gradient descent, the algorithm finds a vector Œ∏b ‚àà Œò such that,
with probability at least 1 ‚àí Œ¥,


1
>
>
k[¬µ0 + Œ¶Œ∏]‚àí k1
¬µŒ∏b ` ‚â§¬µŒ∏ ` + O




1
>


(P ‚àí B) (¬µ0 + Œ¶Œ∏) 1 + O( log(1/Œ¥))
+O

holds for all Œ∏ ‚àà Œò; i.e., we solve the expanded problem
for V (Œ∏) bounded by a constant times the L1 error of the
violation. The second and third terms are zero for feasible
points (points in the intersection of the feasible set of LP (2)
and the span of the features). For points outside the feasible
set, these terms measure the extent of constraint violations
for the vector ¬µ0 + Œ¶Œ∏, which indicates how well stationary
distributions can be represented by the chosen features.

2. A Reduction to Stochastic Convex
Optimization
In this section, we describe our algorithm as a reduction
from Markov decision problems to stochastic convex optimization. The main idea is to convert the ALP (3) into
an unconstrained optimization over Œò by adding a function of the constraint violations to the objective, then run
stochastic gradient descent with unbiased estimated of the
gradient.
For a positive constant H, form the following convex cost
function by adding a multiple of the total constraint violations to the objective of the LP (3):
c(Œ∏) = `> (¬µ0 + Œ¶Œ∏) + H k[¬µ0 + Œ¶Œ∏]‚àí k1


+ H (P ‚àí B)> (¬µ0 + Œ¶Œ∏)
1

= `> (¬µ0 + Œ¶Œ∏) + H k[¬µ0 + Œ¶Œ∏]‚àí k1


+ H (P ‚àí B)> Œ¶Œ∏1
X

[¬µ0 (x, a) + Œ¶(x,a),: Œ∏]‚àí 
= `> (¬µ0 + Œ¶Œ∏) + H
(x,a)

X

(P ‚àí B)>

+H
:,x0 Œ¶Œ∏ .
x0

(7)
1.5. Our Contributions
In this paper, we introduce an algorithm that solves the
expanded efficient large-scale dual ALP problem under a

We justify using this surrogate loss as follows. Supb ‚â§
pose we find a near optimal vector Œ∏b such that c(Œ∏)
minŒ∏‚ààŒò c(Œ∏) + O(). We will prove

Linear Programming for Large-Scale Markov Decision Problems







b
b ‚àí
1. that [¬µ0 + Œ¶Œ∏]
 are
 and (P ‚àí B)> (¬µ0 + Œ¶Œ∏)
1

1

small and ¬µ0 + Œ¶Œ∏b is close to ¬µŒ∏b (by Lemma 2 in
Section 2.1), and
b ‚â§ minŒ∏‚ààŒò c(Œ∏) + O().
2. that `> (¬µ0 + Œ¶Œ∏)
As we will show, these two facts imply that with high probability, for any Œ∏ ‚àà Œò,


1
>
¬µ>
`
‚â§
¬µ
`
+
O
k[¬µ
+
Œ¶Œ∏]
k
0
‚àí
Œ∏
1
Œ∏b




1
(P ‚àí B)> (¬µ0 + Œ¶Œ∏) + O() ,
+O
1

which is to say that minimization of c(Œ∏) solves the extended efficient large-scale ALP problem.
Unfortunately, calculating the gradients of c(Œ∏) is O(XA).
Instead, we construct unbiased estimators and use stochastic gradient descent. Let T be the number of iterations of
our algorithm. Let q1 and q2 be distributions over the stateaction and state space, respectively (we will later discuss
how to choose them). Let ((xt , at ))t=1...T be i.i.d. samples from q1 and (x0t )t=1...T be i.i.d. samples from q2 . At
round t, the algorithm estimates subgradient ‚àác(Œ∏) by
gt (Œ∏) = `> Œ¶ ‚àí H

+H

Œ¶(xt ,at ),:
I{¬µ (x ,a )+Œ¶(xt ,at ),: Œ∏<0}
q1 (xt , at ) 0 t t
(8)

(P ‚àí B)>
:,x0 Œ¶
t

q2 (x0t )

s((P ‚àí B)>
:,x0t Œ¶Œ∏).

This estimate is fed to the projected subgradient method,
which in turn generates a vector Œ∏t . After T rounds, we
average vectors (Œ∏t )t=1...T and obtain the final solution
PT
b
Œ∏bT =
t=1 Œ∏t /T . Vector ¬µ0 + Œ¶Œ∏T defines a policy,
which in turn defines a stationary distribution ¬µŒ∏bT .2 The
algorithm is shown in Figure 1.
2.1. Analysis
In this section, we state and prove our main result, Theorem 1. We begin with a discussion of the assumptions
we make then follow with the main theorem. We break
the proof into two main ingredients. First, we demonstrate
that a good approximation to the surrogate loss gives a feature vector that is almost a stationary distribution; this is
Lemma 2. Second, we justify the use of unbiased gradients
2

Recall that ¬µŒ∏ is the stationary distribution of policy
[¬µ0 (x, a) + Œ¶(x,a),: Œ∏]+
.
0
0
a0 [¬µ0 (x, a ) + Œ¶(x,a ),: Œ∏]+

œÄŒ∏ (a|x) = P

With an abuse of notation, we use ¬µŒ∏ to denote policy œÄŒ∏ as well.

Input: Constant S > 0, number of rounds T , constant
H.
Let Œ†Œò be the Euclidean projection onto Œò.
Initialize Œ∏1 = 0.
for t := 1, 2, . . . , T do
Sample (xt , at ) ‚àº q1 and x0t ‚àº q2 .
Compute subgradient estimate gt (8).
Update Œ∏t+1 = Œ†Œò (Œ∏t ‚àí Œ∑t gt ).
end for P
T
Œ∏bT = T1 t=1 Œ∏t .
Return policy œÄŒ∏bT .
Figure 1. The Stochastic Subgradient Method for Markov Decision Processes

in Theorem 3 and Lemma 5. The section concludes with
the proof of Theorem 1.
We make a mixing assumption on the MDP so that any
policy quickly converges to its stationary distribution.
Assumption A1 (Fast Mixing)
Let M œÄ be a X √ó
œÄ
(XA) matrix that encodes policy œÄ, M(i,(i‚àí1)A+1)
-(i,iA) =
œÄ(¬∑|xi ). Other entries of this matrix are zero. For any
policy œÄ, there exists a constant œÑ (œÄ) > 0 such that
for all distributions d and d0 over the state-action space,
kdP M œÄ ‚àí d0 P M œÄ k1 ‚â§ e‚àí1/œÑ (œÄ) kd ‚àí d0 k1 .
Further, we assume columns of the feature matrix Œ¶ are
positive and sum to one. Define


Œ¶(x,a),: 
C1 = max
,
(x,a)‚ààX √óA q1 (x, a)


(P ‚àí B)>

:,x Œ¶
C2 = max
.
x‚ààX
q2 (x)
These constants appear in our performance bounds. So we
would like to choose distributions q1 and q2 such that C1
and C2 are small. For example, if there is C 0 > 0 such
that for any (x, a) and i, Œ¶(x,a),i ‚â§ C 0 /(XA) and each
column of P has only N non-zero elements, then we can
simply choose q1 and q2 to be uniform distributions. Then
it is easy to see that




(P ‚àí B)>

Œ¶(x,a),: 
:,x Œ¶
0
‚â§C ,
‚â§ C 0 (N + A) .
q1 (x, a)
q2 (x)
As another example, if Œ¶:,i are exponential distributions
and feature values at neighboring states are close to each
other, then we can choose q1 and
 q2 to be appropriate
Œ¶(x,a),:  /q1 (x, a) and
exponential
distributions
so
that


>
(P ‚àí B):,x Œ¶ /q2 (x) are always bounded. Another example is when there exists a constant C 00 > 0 such

Linear Programming for Large-Scale Markov Decision Problems

 >   > 
that,3 for any x, P:,x
Œ¶ / B:,x Œ¶ < C 00 and we have
access to an efficient
algorithm
that computes
Z1 =


P 
P

 > 

can sample
x B:,x Œ¶ and
(x,a) Œ¶(x,a),:  and Z2 =
 > 
Œ¶ /Z2 .
from q1 (x, a) = Œ¶(x,a),:  /Z1 and q2 (x) = B:,x
In what follows, we assume that appropriate distributions
q1 and q2 are known.
We now state the main theorem.
Theorem 1. Consider an expanded efficient large-scale
dual ALP problem, with violation function V = O(V1 +
V2 ), defined by
V1 (Œ∏) = k[¬µ0 + Œ¶Œ∏]‚àí k1


V2 (Œ∏) = (P ‚àí B)> (¬µ0 + Œ¶Œ∏)1 .
Assume œÑ := sup{œÑ (¬µŒ∏ ) : Œ∏ ‚àà Œò} < ‚àû is finite. Suppose we apply the stochastic subgradient method (shown
in Figure 1) to the problem. Let  ‚àà (0, 1). Let T = 1/4
be the number of rounds and H = 1/ be the constraints
multiplier in the subgradient estimate (8). Let Œ∏bT be the
output of the stochastic subgradient method after
‚àö T rounds
and let‚àö the learning rate be Œ∑t = S/(G0 T ), where
G0 = d + H(C1 + C2 ). Then, for any Œ¥ ‚àà (0, 1), with
probability at least 1 ‚àí Œ¥,




1
>
(V
(Œ∏)
+
V
(Œ∏))
+
O()
,
¬µ>
`
‚â§
min
¬µ
`
+
O
1
2
Œ∏
Œ∏bT
Œ∏‚ààŒò

(9)
where the constants hidden in the big-O notation are polynomials in S, d, C1 , C2 , and log(1/Œ¥).
The functions V1 and V2 are bounded by small constants
for any set of normalized features: for any Œ∏ ‚àà Œò,
V1 (Œ∏) ‚â§ k¬µ0 k1 + kŒ¶Œ∏k1
X
‚àö

Œ¶(x,a),: Œ∏ ‚â§ 1 + S d ,
‚â§1+
(x,a)

where the last step follows from the fact that columns of Œ¶
are probability distributions. Further,
X
 X >

>
P:,x

B:,x0 (¬µ0 + Œ¶Œ∏)
V2 (Œ∏) ‚â§
0 (¬µ0 + Œ¶Œ∏) +
x0

‚â§

x0

X

>
P:,x
0

|¬µ0 + Œ¶Œ∏| +

x0

X

>
B:,x
0 |¬µ0 + Œ¶Œ∏|

x0
>

= 21 |¬µ0 + Œ¶Œ∏|
‚â§ 21> (|¬µ0 | + |Œ¶Œ∏|)
‚àö
‚â§ 2(1 + S d) .
Thus V1 and V2 can be small given a carefully designed set
of features.
3

This condition requires that columns of Œ¶ are close to their
one step look-ahead.

p
The optimal choice for  is  = V1 (Œ∏‚àó ) + V2 (Œ∏‚àó ), where
Œ∏‚àó is the minimizer of the RHS
p of (9). Thus, the optimized
error bound scales like O( V1 (Œ∏‚àó ) + V2 (Œ∏‚àó )). Unfortunately, Œ∏‚àó is not known in advance. To partially alleviate
the problem, once we obtain Œ∏bT , q
we can estimate V1 (Œ∏bT )
and V2 (Œ∏bT ) and use input  =
V1 (Œ∏bT ) + V2 (Œ∏bT ) in a
second run of the algorithm.
The next lemma, providing the first ingredient of the proof,
shows how the amount of constraint violation of a vector Œ∏
shifts the resulting stationary distribution ¬µŒ∏ .
Lemma 2. Let u ‚àà RXA be a vector. Assume
X


u(x, a) = 1, k[u]‚àí k1 ‚â§ 0 , u> (P ‚àí B)1 ‚â§ 00 .
x,a

The vector [u]+ / k[u]+ k1 defines a policy, which in turn
defines a stationary distribution ¬µu . We have that
k¬µu ‚àí uk1 ‚â§ (œÑ (¬µu ) log(1/(20 + 00 )) + 2)(20 + 00 ) .
Proof. Define h = [u]+ / k[u]+ k1 . We first show that h is
almost a stationary distribution, in the sense that
 >

h (P ‚àí B) ‚â§ 20 + 00 .
(10)
1
To see this, notice that the first
 assumption
 is equivalent to
k[u]+ k1 ‚àí k[u]‚àí k1 = 1, so h> (P ‚àí B)1 is equal to


 [u]>

+


 k[u]+ k (P ‚àí B)
1
1


(u ‚àí [u]‚àí )> (P ‚àí B)
1
=
1 + k[u]‚àí k1





‚â§ u> (P ‚àí B)1 + [u]>
‚àí (P ‚àí B) 1


‚â§ 00 + k[u]‚àí k (P ‚àí B)> 
1

1

‚â§ 00 + 20 ,
because the linear maps defined by P and B have operator
norms (corresponding to the 1-norm) bounded by 1. Next,
notice that
kh ‚àí uk1 ‚â§ kh ‚àí [u]+ k1 + k[u]+ ‚àí uk1
= k[u]‚àí k1 + k[u]‚àí k1 ‚â§ 20 .
Next we bound k¬µh ‚àí hk1 . Let ŒΩ0 = h be the initial stateaction distribution. We will show that as we run policy h
(equivalently, policy ¬µh ), the state-action distribution converges to ¬µh and this vector is close to h. From (10), we
have ŒΩ0> P = h> B + v0 , where v0 is such that kv0 k1 ‚â§
20 + 00 . Let M h be the X √ó (XA) matrix that encodes
h
policy h, via M(i,(i‚àí1)A+1)
-(i,iA) = h(¬∑|x = i). Other
entries of this matrix are zero. Define the state-action distribution after running policy h for one step as
ŒΩ1> := h> P M h = (h> B + v0 )M h
= h> BM h + v0 M h = h> + v0 M h .

Linear Programming for Large-Scale Markov Decision Problems

Let
v1 = v0 M h P = v0 P h and notice that kv1 k1 =
 h>
P v0>  ‚â§ kv0 k ‚â§ 20 + 00 . Thus,
1
1
ŒΩ2> = ŒΩ1> P M h = h> + (v0 + v1 )M h .
By repeating this argument for k rounds, we get that
ŒΩk> = h> + (v0 + v1 + ¬∑ ¬∑ ¬∑ + vk‚àí1 )M h .
Since
the operator norm of M h is no more than 1,

(v0 + v1 + ¬∑ ¬∑ ¬∑ + vk‚àí1 )M h  ‚â§ Pk‚àí1 kvi k ‚â§ k(20 +
i=0
1
1
00 ). Thus, kŒΩk ‚àí hk1 ‚â§ k(20 + 00 ). Now, since ŒΩk is
the state-action distribution after k rounds of policy ¬µh ,
by the mixing assumption, kŒΩk ‚àí ¬µh k1 ‚â§ 2e‚àík/œÑ (h) . By
the choice of k = œÑ (h) log(1/(20 + 00 )), we get that
k¬µh ‚àí hk1 ‚â§ (œÑ (h) log(1/(20 + 00 )) + 2)(20 + 00 ).

have that for any Œ¥ ‚àà (0, 1), with probability at least 1 ‚àí Œ¥,
SG0
(12)
c(Œ∏bT ) ‚àí min c(Œ∏) ‚â§ ‚àö
Œ∏‚ààŒò
T
s



1 + 4S 2 T
1
S2T
+
2
log
+
d
log
1
+
.
T2
Œ¥
d
With both ingredients in place, we can prove our main result.
Proof of Theorem 1. Let bT be the RHS of (12). Lemma 5
implies that with high probability for any Œ∏ ‚àà Œò,
`> (¬µ0 + Œ¶Œ∏bT ) + H V1 (Œ∏bT ) + H V2 (Œ∏bT ) ‚â§ `> (¬µ0 + Œ¶Œ∏)
+ H V1 (Œ∏) + H V2 (Œ∏) + bT .

(13)

From (13), we get that
The second ingredient is the validity of using estimates of
the subgradients. We assume access to estimates of the subgradient of a convex cost function. Error bounds can be
obtained from results in the stochastic convex optimization
literature; the following theorem, a high-probability version of Lemma 3.1 of Flaxman et al. (2005) for stochastic
convex optimization, is sufficient. The proof can be found
in Appendix B.
Theorem 3. Let Z be a positive constant and Z be a
bounded convex subset of Rd such that for any z ‚àà Z,
kzk ‚â§ Z. Let (ft )t=1,2,...,T be a sequence of real-valued
convex cost functions defined over Z. Let z1 , z2 , . . . , zT ‚àà
Z be defined by z1 = 0 and zt+1 = Œ†Z (zt ‚àí Œ∑ft0 ), where
Œ†Z is the Euclidean projection onto Z, Œ∑ > 0 is a learning
rate, and f10 , . . . , fT0 are unbiased subgradient estimates
such that E [ft0 |zt ] = ‚àáf (zt ) ‚àö
and kft0 k ‚â§ F for some
F > 0. Then, for Œ∑ = Z/(F T ), for any Œ¥ ‚àà (0, 1),
with probability at least 1 ‚àí Œ¥,
T
T
X
X
‚àö
ft (zt ) ‚àí min
ft (z) ‚â§ ZF T
z‚ààZ

t=1

s
+

(11)

t=1



1
Z 2T
2
(1 + 4Z T ) 2 log + d log 1 +
.
Œ¥
d



‚àö
1 
2(1 + S d) + H V1 (Œ∏) + H V2 (Œ∏) + bT
V1 (Œ∏bT ) ‚â§
H
def
= 0 ,
(14)


‚àö
1
2(1 + S d) + H V1 (Œ∏) + H V2 (Œ∏) + bT
V2 (Œ∏bT ) ‚â§
H
def 00
= .
(15)
Inequalities (14) and (15) and Lemma 2 give the following
bound:


 >

¬µŒ∏b ` ‚àí (¬µ0 + Œ¶Œ∏bT )> ` ‚â§
T

(œÑ (¬µŒ∏bT ) log(1/(20 + 00 )) + 2)(20 + 00 ) .

(16)

From (13) we also have
`> (¬µ0 + Œ¶Œ∏bT ) ‚â§ `> (¬µ0 + Œ¶Œ∏) +H V1 (Œ∏) +H V2 (Œ∏) +bT ,
which, together with (16) and Lemma 2, gives the final result:
¬µ>
` ‚â§ `> (¬µ0 + Œ¶Œ∏) + H V1 (Œ∏) + H V2 (Œ∏) + bT
Œ∏b
T

+ (œÑ (¬µŒ∏bT ) log(1/(20 + 00 )) + 2)(20 + 00 )
‚â§ ¬µ>
Œ∏ ` + H V1 (Œ∏) + H V2 (Œ∏) + bT
+ (œÑ (¬µŒ∏bT ) log(1/(20 + 00 )) + 2)(20 + 00 )

Remark 4. Let BT denote the RHS of (11). If all cost functions are equal to f , then by convexity of f and
PTan application of Jensen‚Äôs inequality, we obtain that f ( t=1 zt /T )‚àí
minz‚ààZ f (z) ‚â§ BT /T .
As the next lemma shows, Theorem 3 can be applied in our
problem to optimize the cost function c. The proof can be
found in Appendix B.
Lemma 5. Under the same conditions as in Theorem 1, we

+ (œÑ (¬µŒ∏ ) log(1/(2V1 (Œ∏) + V2 (Œ∏))))
√ó (2V1 (Œ∏) + V2 (Œ∏)) .
‚àö
Recall that bT = O(H/ T ). Because H = 1/ and T =
1/4 , we get that with high probability,
for any Œ∏ ‚àà Œò,

1
>
¬µ>
`
‚â§
¬µ
`
+
O
(V
(Œ∏)
+
V
(Œ∏))
+
O().
1
2
Œ∏

Œ∏b
T

Linear Programming for Large-Scale Markov Decision Problems

Let‚Äôs compare Theorem 1 with results of de Farias and Van
Roy (2006). Their approach is to relate the original MDP
to a perturbed version4 and then analyze the corresponding
ALP. (See Appendix A for more details.) Let Œ® be a feature
matrix that is used to estimate value functions. Recall that
Œª‚àó is the average loss of the optimal policy and Œªw is the
average loss of the greedy policy with respect to value function Œ®w. Let h‚àóŒ≥ be the differential value function when the
restart probability in the perturbed MDP is 1 ‚àí Œ≥. For vector v and positive vector u, define the weighted maximum
norm kvk‚àû,u = maxx u(x) |v(x)|. de Farias and Van Roy
(2006) prove that for appropriate constants C, C 0 > 0 and
weight vector u,


C
min h‚àóŒ≥ ‚àí Œ®w‚àû,u + C 0 (1 ‚àí Œ≥) .
1‚àíŒ≥ w
(17)
This bound has similarities to bound (9): tightness of both
bounds depends on the quality of feature vectors in representing the relevant quantities (stationary distributions in
(9) and value functions in (17)). Once again, we emphasize that the algorithm proposed by de Farias and Van Roy
(2006) is computationally expensive and requires access to
a distribution that depends on optimal policy.
Œªw‚àó ‚àí Œª‚àó ‚â§

Remark 6. In our algorithm, we estimate the subgradient
by sampling constraints of the LP. A natural question to ask
is if we can first sample constraints then exactly solve the
resulting LP. Analysis for such an algorithm is presented in
Appendix C. However the analysis requires stronger conditions on the choice of feature vectors.

3. Experiments
In this section, we apply our algorithm to the fourdimensional discrete-time queueing network illustrated in
Figure 3. This network has a relatively long history; see,
e.g. (Rybko and Stolyar, 1992) and more recently (de Farias
and Van Roy, 2003a) (c.f. Section 6.2). There are four
queues, ¬µ1 , . . . , ¬µ4 , each with state 0, . . . , B. Since the
cardinality of the state space is X = (1 + B)4 , even a modest B results in huge state spaces. For time t, let Xt ‚àà X
be the state and let si,t ‚àà {0, 1}, i = 1, 2, 3, 4 denote the
actions. The value si,t = 1 indicates that queue i is being served. Server 1 only serves queue 1 or 4, server 2
only serves queue 2 or 3, and neither server can idle. Thus,
s1,t + s4,t = 1 and s2,t + s3,t = 1. The dynamics are defined by the rate parameters a1 , a3 , d1 , d2 , d3 , d4 ‚àà (0, 1)
as follows. At each time t, the following random variables are sampled independently: A1,t ‚àº Bernoulli(a1 ),
A3,t ‚àº Bernoulli(a3 ), and Di,t ‚àº Bernoulli(di si,t ) for
i = 1, 2, 3, 4. Using e1 , . . . , e4 to denote the standard basis
4

In a perturbed MDP, the state process restarts with a certain
probability to a restart distribution. Such perturbed MDPs are
closely related to discounted MDPs.

vectors, the dynamics are:
0
Xt+1
=Xt + A1,t e1 + A3,t e3

+ D1,t (e2 ‚àí e1 ) ‚àí D2,t e2
+ D3,t (e4 ‚àí e3 ) ‚àí D4,t e4 ,
0
and Xt+1 = max(0, min(B, Xt+1
)) (i.e. all four states
are thresholded from below by 0 and above by B). The
loss function is the total queue size: `(Xt ) = ||Xt ||1 . We
compared our method against two common heuristics. In
the first, denoted LONGER, each server operates on the
queue that is longer with ties broken uniformly at random
(e.g. if queue 1 and 4 had the same size, they are equally
likely to be served). In the second, denoted LBFS (last
buffer first served), the downstream queues always have
priority (server 1 will serve queue 4 unless it has length
0, and server 2 will serve queue 2 unless it has length 0).
These heuristics are common and have been used an benchmarks for queueing networks (e.g. (de Farias and Van Roy,
2003a)).

We used a1 = a3 = .08, d1 = d2 = .12, and d3 = d4 =
.28, and buffer sizes B1 = B4 = 38, B2 = B3 = 25
as the parameters of the network. The asymmetric size
was chosen because server 1 is the bottleneck and tends to
have longer queues. The first two features are the stationary
distributions corresponding to the two heuristics LONGER
and LBFS. We also included two types of features that do
not correspond to stationary distribution. For every interval
(0, 5], (6, 10], . . . , (45, 50] and action A, we added a feature œà with œï(x, a) = 1 if `(x, a) is in the interval and
a = A. To define the second type, consider the three intervals I1 = [0, 10], I2 = [11, 20], and I3 = [21, 25]. For
every 4-tuple of intervals (J1 , J2 , J3 , J4 ) ‚àà {I1 , I2 , I3 }4
and action A, we created a feature œà with œà(x, a) = 1 only
if xi ‚àà Ji and a = A. Every feature was normalized to
sum to 1. In total, we had 372 features which is about a
104 reduction in dimension from the original problem.
To obtain a lower variance estimate of our gradient, we
sampled gt (Œ∏) 1000 times and averaged (which is equivalent to sampling 1000 i.i.d. constraints from both q1 and
q2 ). Rather than the fixed learning rate Œ∑ considered in Section 2, our learning rate began at 10‚àí4 and halved every
2000 iterations. The results of the simulations are plotted in Figure 3, where Œ∏bt denotes the running average of
Œ∏t . The left plot is of the LP objective, `> (¬µ0 + Œ¶Œ∏bt ).
The
 middle plot
 is of the sum of theconstraint violations,




b
[¬µ0 + Œ¶Œ∏t ]‚àí  + (P ‚àí B)> Œ¶Œ∏bt  . Thus, c(Œ∏bt ) is a
1
1
scaled sum of the first two plots. Finally, the right plot
is of the average losses, `> ¬µŒ∏bt and the two horizontal lines
correspond to the loss of the two heuristics, LONGER and
LBFS. The right plot demonstrates that, as predicted by
our theory, minimizing the surrogate loss c(Œ∏) does lead
to lower average losses.

Linear Programming for Large-Scale Markov Decision Problems

a1
d4

¬µ1

d1

¬µ2

d2

¬µ4

d2

¬µ3

a3

server1

server2

Figure 2. The 4D queueing network. Customers arrive at queue ¬µ1 or ¬µ3 then are referred to queue ¬µ2 or ¬µ4 , respectively. Server 1 can
either process queue 1 or 4, and server 2 can only process queue 2 or 3.
loss of running average

total constraint violation of running average

0

42

average loss of the running average policy

10

52
50

41

48
40

46
‚àí1

39

10

44
42

38

40
37

36

38
‚àí2

0

2000

4000

6000

8000

10

0

2000

4000

6000

8000

36

0

2000

4000

6000

8000

Figure 3. The left plot is of the linear objective of the running average, i.e. `> Œ¶Œ∏bt . The center plot is the sum of the two constraint
violations of Œ∏bt , and the right plot is `> ¬µÃÉŒ∏bt (the average loss of the derived policy). The two horizontal lines correspond to the loss of
the two heuristics, LONGER and LBFS.

All previous algorithms (including (de Farias and Van Roy,
2003a)) work with value functions, while our algorithm
works with stationary distributions. Due to this difference,
we cannot use the same feature vectors to make a direct
comparison. The solution that we find in this different approximating set is comparable to the solution of de Farias
and Van Roy (2003a).

5. Acknowledgements
We gratefully acknowledge the support of the NSF through
grant CCF-1115788 and of the ARC through an Australian Research Council Australian Laureate Fellowship
(FL110100281).

References
4. Conclusions
In this paper, we defined and solved the extended largescale efficient ALP problem. We proved that, under certain
assumptions about the dynamics, the stochastic subgradient
method produces a policy with average loss competitive to
all Œ∏ ‚àà Œò, not not just all Œ∏ producing a stationary distribution. We demonstrated this algorithm on the RybkoStoylar four-dimensional queueing network and recovered
a policy better than two common heuristics and comparable to previous results on ALPs (de Farias and Van Roy,
2003a). A future direction is to find other interesting regularity conditions under which we can handle large-scale
MDP problems. We also plan to conduct more experiments
with challenging large-scale problems.

Y. Abbasi-Yadkori.
Online Learning for Linearly
Parametrized Control Problems. PhD thesis, University
of Alberta, 2012.
R. Bellman. Dynamic Programming. Princeton University
Press, 1957.
D. P. Bertsekas. Dynamic Programming and Optimal Control. Athena Scientific, 2007.
D. P. Bertsekas and J. Tsitsiklis. Neuro-Dynamic Programming. Athena scientific optimization and computation
series. Athena Scientific, 1996.
G. Calafiore and M. C. Campi. Uncertain convex programs:
randomized solutions and confidence levels. Mathematical Programming, 102(1):25‚Äì46, 2005.

Linear Programming for Large-Scale Markov Decision Problems

M. C. Campi and S. Garatti. The exact feasibility of randomized solutions of uncertain convex programs. SIAM
Journal on Optimization, 19(3):1211‚Äì1230, 2008.
D. P. de Farias and B. Van Roy. The linear programming
approach to approximate dynamic programming. Operations Research, 51, 2003a.
D. P. de Farias and B. Van Roy. Approximate linear programming for average-cost dynamic programming. In
NIPS, 2003b.
D. P. de Farias and B. Van Roy. On constraint sampling
in the linear programming approach to approximate dynamic programming. Mathematics of Operations Research, 29, 2004.
D. P. de Farias and B. Van Roy. A cost-shaping linear program for average-cost approximate dynamic programming with performance guarantees. Mathematics of Operations Research, 31, 2006.
V. H. de la PenÃÉa, T. L. Lai, and Q-M. Shao. Self-normalized
processes: Limit theory and Statistical Applications.
Springer, 2009.
V. V. Desai, V. F. Farias, and C. C. Moallemi. Approximate
dynamic programming via a smoothed linear program.
Operations Research, 60(3):655‚Äì674, 2012.
A. D. Flaxman, A. T. Kalai, and H. B. McMahan. Online
convex optimization in the bandit setting: gradient descent without a gradient. In SODA, 2005.
C. Guestrin, M. Hauskrecht, and B. Kveton. Solving factored mdps with continuous and discrete variables. In
UAI, 2004.
M. Hauskrecht and B. Kveton. Linear program approximations to factored continuous-state markov decision processes. In NIPS, 2003.
R. A. Howard. Dynamic Programming and Markov Processes. MIT, 1960.
H. R. Maei, Cs. SzepesvaÃÅri, S. Bhatnagar, D. Precup,
D. Silver, and R. S. Sutton. Convergent temporaldifference learning with arbitrary smooth function approximation. In NIPS, 2009.
H. R. Maei, Cs. SzepesvaÃÅri, S. Bhatnagar, and R. S. Sutton.
Toward off-policy learning control with function approximation. In ICML, 2010.
A. S. Manne. Linear programming and sequential decisions. Management Science, 6(3):259‚Äì267, 1960.
M. Petrik and S. Zilberstein. Constraint relaxation in approximate linear programs. In ICML, 2009.

A. N. Rybko and A. L. Stolyar. Ergodicity of stochastic processes describing the operation of open queueing
networks. Problemy Peredachi Informatsii, 28(3):3‚Äì26,
1992.
P. Schweitzer and A. Seidmann. Generalized polynomial
approximations in Markovian decision processes. Journal of Mathematical Analysis and Applications, 110:
568‚Äì582, 1985.
R. S. Sutton and A. G. Barto. Reinforcement Learning: An
Introduction. Bradford Book. MIT Press, 1998.
R. S. Sutton, H. R. Maei, D. Precup, S. Bhatnagar, D. Silver, Cs. SzepesvaÃÅri, and E. Wiewiora. Fast gradientdescent methods for temporal-difference learning with
linear function approximation. In ICML, 2009a.
R. S. Sutton, Cs. SzepesvaÃÅri, and H. R. Maei. A convergent
O(n) algorithm for off-policy temporal-difference learning with linear function approximation. In NIPS, 2009b.
V. N. Vapnik and A. Y. Chervonenkis. On the uniform convergence of relative frequencies of events to their probabilities. Theory of Probability and its Applications, 16
(2):264‚Äì280, 1971.
M. H. Veatch. Approximate linear programming for average cost mdps. Mathematics of Operations Research, 38
(3), 2013.
T. Wang, D. Lizotte, M. Bowling, and D. Schuurmans.
Dual representations for dynamic programming. Journal of Machine Learning Research, pages 1‚Äì29, 2008.
M. Zinkevich. Online convex programming and generalized infinitesimal gradient ascent. In ICML, 2003.

