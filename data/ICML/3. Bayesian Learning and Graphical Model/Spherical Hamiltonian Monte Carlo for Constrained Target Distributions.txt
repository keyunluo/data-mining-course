Spherical Hamiltonian Monte Carlo for Constrained Target Distributions

Shiwei Lan
Department of Statistics, University of California, Irvine, CA 92697, USA.

SLAN @ UCI . EDU

Bo Zhou
Department of Statistics, University of California, Irvine, CA 92697, USA.

BZHOU 1@ UCI . EDU

Babak Shahbaba
Department of Statistics, University of California, Irvine, CA 92697, USA.

BABAKS @ UCI . EDU

Abstract
Statistical models with constrained probability
distributions are abundant in machine learning.
Some examples include regression models with
norm constraints (e.g., Lasso), probit models,
many copula models, and Latent Dirichlet Allocation (LDA) models. Bayesian inference involving probability distributions confined to constrained domains could be quite challenging for
commonly used sampling algorithms. For such
problems, we propose a novel Markov Chain
Monte Carlo (MCMC) method that provides a
general and computationally efficient framework
for handling boundary conditions. Our method
first maps the D-dimensional constrained domain of parameters to the unit ball BD
0 (1), then
augments it to a D-dimensional sphere SD such
that the original boundary corresponds to the
equator of SD . This way, our method handles
the constraints implicitly by moving freely on the
sphere generating proposals that remain within
boundaries when mapped back to the original
space.

1. Introduction
Many commonly used statistical models in Bayesian analysis involve high-dimensional probability distributions confined to constrained domains. Some examples include regression models with norm constraints (e.g., Lasso), probit models, many copula models, and Latent Dirichlet Allocation (LDA) models. Very often, the resulting models
are intractable, simulating samples for Monte Carlo estiProceedings of the 31 st International Conference on Machine
Learning, Beijing, China, 2014. JMLR: W&CP volume 32. Copyright 2014 by the author(s).

mations is quite challenging (Neal & Roberts, 2008; Sherlock & Roberts, 2009; Neal et al., 2012; Brubaker et al.,
2012; Pakman & Paninski, 2012), and mapping the domain to the entire Euclidean space for convenience would
be computationally inefficient. In this paper, we propose a
novel Markov Chain Monte Carlo (MCMC) method, which
provides a natural and computationally efficient framework
for sampling from constrained target distributions. Our
method is based on Hamiltonian Monte Carlo (HMC) (Duane et al., 1987; Neal, 2010), which is a Metropolis algorithm with proposals guided by Hamiltonian dynamics.
In recent years, several methods have been proposed to improve the computational efficiency of HMC (Beskos et al.,
2011; Girolami & Calderhead, 2011; Hoffman & Gelman,
2011; Shahbaba et al., 2013b; Lan et al., 2012; Byrne &
Girolami, 2013). In general, these methods do not directly
address problems with constrained target distributions. In
this current paper, we focus on improving HMC-based algorithms when the target distribution is constrained by inequalities. When dealing with such constrained target distributions, the standard HMC algorithm needs to evaluate
each proposal to ensure it is within the boundaries imposed
by the constraints. Computationally, this is quite inefficient. Alternatively, as discussed by Neal (Neal, 2010), one
could modify standard HMC such that the sampler bounces
off the boundaries by letting the potential energy go to infinity for parameter values that violate the constraints. This
approach, however, is not very efficient either. Byrne and
Girolami (Byrne & Girolami, 2013) discuss this method
for situations where constrained domains can be identified
as submanifolds. Pakman and Paninski (Pakman & Paninski, 2012) also follow this idea and propose an exact HMC
algorithm specifically for truncated Gaussian distributions
with non-holonomic constraints. Brubaker et al. (Brubaker
et al., 2012) on the other hand propose a modified version of HMC for handling holonomic constraint c(θ) = 0.
All these methods provide interesting solutions for specific

Spherical Hamiltonian Monte Carlo for Constrained Target Distributions

types of constraints. In contrast, our proposed method in
this paper provides a general and computationally efficient
framework for handling constraints given by inequalities
involving general vector norms.
In what follows, before we present our method, we provide
a brief overview of HMC (Section 2). We then present our
method for distributions confined to the unit ball in Section
3. The unit ball is a special case of q-norm constraints. In
Section 4, we discuss the application of our method for qnorm constraints in general. In Section 5, we evaluate our
proposed method using simulated and real data. Finally, we
discuss future directions in Section 6.

reject it according to the Metropolis acceptance probability.
(See Neal, 2010, for more discussions).
Although HMC explores the target distribution more efficiently than random walk Metropolis, it does not fully
exploit its geometric properties. To address this issue,
Girolami and Calderhead (Girolami & Calderhead, 2011)
propose Riemannian Manifold HMC (RMHMC), which
adapts to the local Riemannian geometry of the target distribution by using a position-specific mass matrix M =
G(θ). More specifically, they set G(θ) to the Fisher information matrix. Our proposed sampling method can be
viewed as an extension of this approach since it explores
the geometry of sphere.

2. HMC
HMC improves upon random walk Metropolis by proposing states that are distant from the current state, but nevertheless accepted with high probability. These distant proposals are found by numerically simulating Hamilton dynamics, whose state space consists of its position, denoted
by the vector θ, and its momentum, denoted by the vector
p. Our objective is to sample from the continuous probability distribution of θ with the density function f (θ). It is
common to assume that the fictitious momentum variable
p ∼ N (0, M ), where M is a symmetric, positive-definite
matrix known as the mass matrix, often set to the identity
matrix I for convenience.
In this Hamilton dynamics, the potential energy, U (θ), is
defined as minus the log density of θ (plus any constant);
the kinetic energy, K(p) for the auxiliary momentum variable p is set to be minus the log density of p (plus any constant). Then the total energy of the system, Hamiltonian
function is defined as their sum:
H(θ, p) = U (θ) + K(p)
Given the Hamiltonian H(θ, p), the system of (θ, p)
evolves according to following Hamilton’s equations,
θ̇
ṗ

=
∇p H(θ, p)
= −∇θ H(θ, p)

=
M −1 p
= −∇θ U (θ)

Note that since momentum is mass times velocity, v =
M −1 p is regarded as velocity. Throughout this paper, we
express the kinetic energy K in terms of velocity, v, instead
of momentum, p (Beskos et al., 2011; Lan et al., 2012).
In practice when the analytical solution to Hamilton’s equations is not available, we need to numerically solve these
equations by discretizing them, using some small time step
. For the sake of accuracy and stability, a numerical
method called leapfrog is commonly used to approximate
the Hamilton’s equations (Neal, 2010). We numerically
solve the system for L steps, with some step size, , to propose a new state in the Metropolis algorithm, and accept or

3. Sampling from distributions defined on the
unit ball
In many cases, bounded connected constrained regions
can be bijectively mapped to theqD-dimensional unit ball
PD 2
D
BD
: kθk2 =
0 (1) := {θ ∈ R
i=1 θi ≤ 1}. Therefore, in this section, we first focus on distributions confined
to the unit ball with the constraint kθk2 ≤ 1.
We start by augmenting the original D-dimensional parameter θ with an extra auxiliary variable θD+1 to form an extended (D + 1)-dimensional p
parameter θ̃ = (θ, θD+1 ) such
that kθ̃k2 = 1 so θD+1 = ± 1 − kθk22 . This way, the domain of the target distribution is changed from the unit ball
D
D+1
BD
:
0 (1) to the D-dimensional sphere, S := {θ̃ ∈ R
kθ̃k2 = 1}, through the following transformation:
q
D
TB→S : BD
(1)
−→
S
,
θ
→
7
θ̃
=
(θ,
±
1 − kθk22 )
0
(1)
Note that although θD+1 can be either positive or negative,
its sign does not affect our Monte Carlo estimates since
after applying the above transformation, we need adjust our
estimates according to the change of variable theorem as
follows:


Z
Z
 dθB 
 dθ̃S
f (θ)dθB =
f (θ̃) 
(2)
dθ̃S 
BD
SD
0 (1)
+


 B
where  dθ
 = |θD+1 | as shown in Appendix A. Here,
dθ̃
S

dθB and dθ̃S are under Euclidean measure and spherical
measure respectively.
Using the above transformation, we define the dynamics on
the sphere. This way, the resulting HMC sampler can move
freely on SD while implicitly handling the constraints imposed on the original parameters. As illustrated in Figure 1,
the boundary of the constraint, i.e., kθk2 = 1, corresponds
to the equator on the sphere SD . Therefore, as the sampler
moves on the sphere, passing across the equator from one
hemisphere to the other translates to “bouncing back” off

Spherical Hamiltonian Monte Carlo for Constrained Target Distributions

●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●●
●●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
A
●
●
B
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●

●
●
●●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●●
●●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●●
●
●
●
●
●
●●
●
●
●
●
●
●
●●
●
●●
●
●●
●●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●●
●
●●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
A
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●●
●
●●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●●
●●
●
●
●
●●
●
●
●
●●
●
●
●
●●
●
●
●
●●
●
●●
●●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●●
●●
●●
●
●
●
●
●
●
●
●
●
●
●●
●●
●
●●
●
●
●
●●
●
●●
●●
●●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●●
●●
●
●●
●
●●
●●
●
●
●●
●
●●
●
●
●●
●
●
●●
●
●●
●
●
●●
●
●
●
●
●
●
●
●●
●●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●●
●
●●
●
●
●
●●
●
●
●●
●●
●●
●●
●
●
●
●●
●●
●
●
●
●●
●
●
●●
●
●●
●
●●
●●
●●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●●
●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●●
●●
●●
●●
●●●
●
●●
●●
●●●
●●
●●
●
●●
●●
●●
●●
●
●
●
●
●●
●●
●●
●
●
●
●
●
●
●
●
●

rectly from the standard (D + 1)-dimensional Gaussian,
 




I
−1
ṽ ∼ N 0,
GS I − θ/θD+1
(6)
−θT /θD+1
which simplifies to

B

ṽ ∼ N (0, ID+1 − θ̃θ̃T )
D
Figure 1. Transforming unit ball BD
0 (1) to sphere S .

the the boundary in the original parameter space.
By defining HMC on the sphere, besides handling the constraints implicitly, the computational efficiency of the sampling algorithm could be improved by using splitting techniques discussed in (Beskos et al., 2011; Shahbaba et al.,
2013b; Byrne & Girolami, 2013). Consider a family of
target distributions, {f (· ; θ)}, defined on the unit ball
BD
0 (1) (i.e., the original parameter space) endowed with
the Euclidean metric I. The potential energy is defined as
U (θ) := − log f (· ; θ). Associated with the auxiliary variable v (i.e., velocity), we define the kinetic energy K(v) =
1 T
D
2 v Iv for v ∈ Tθ B0 (1), which is a D-dimensional vector
sampled from the tangent space of BD
0 (1). Therefore, the
Hamiltonian is defined on BD
0 (1) as
1
H(θ, v) = U (θ) + K(v) = U (θ) + v T Iv
2

(3)

Next, we derive the corresponding Hamiltonian function
on SD . The potential energy U (θ̃) = U (θ) remains the
same since the distribution is fully defined in terms of the
original parameter θ, i.e., the first D elements of θ̃. However, the kinetic energy, K(ṽ) := 12 ṽ T ṽ, changes since the
velocity ṽ = (v, vD+1 ) is now sampled from the tangent
space of the sphere, Tθ̃ SD := {ṽ ∈ RD+1 |θ̃T ṽ = 0},
with vD+1 = −θT v/θD+1 . As a result, the Hamiltonian
H ∗ (θ̃, ṽ) is defined on the sphere SD as follows:
H ∗ (θ̃, ṽ) = U (θ̃) + K(ṽ)

(4)

The Hamiltonian function (5) can be used to define
the Hamilton dynamics on the Riemannian manifold
(BD
0 (1), GS ) in terms of (θ, p), or equivalently as the following Lagrangian dynamics in terms of (θ, v) (Lan et al.,
2012):
θ̇
v̇

=
=

1
1
H ∗ (θ̃, ṽ) = U (θ̃) + ṽ T ṽ = U (θ) + v T GS v
2
2

(5)

More details are provided in Appendix A.
−1
Now we can sample
 the velocity v ∼ N (0, GS ) and set
I
ṽ =
v. Alternatively, we can sample ṽ di−θT /θD+1

v
−v T Γv − G−1
S ∇U (θ)

(8)

where Γ are the Christoffel symbols of second kind derived from GS . The Hamiltonian (5) is preserved under
Lagrangian dynamics (8). (See Lan et al., 2012, for more
discussion).
(Byrne & Girolami, 2013) split the Hamiltonian (5) as follows:
1
H ∗ (θ̃, ṽ) = U (θ)/2 + v T GS v + U (θ)/2
2

(9)

However, their approach requires the manifold to be embedded in the Euclidean space. To avoid this assumption,
instead of splitting the Hamilton dynamics, we split the corresponding Lagrangian dynamics (8) as follows:


θ̇ = 0
θ̇ = v
(10)
v̇
= −v T Γv
v̇ = − 12 G−1
∇U
(θ)
S
(See Appendix C for more details.) Note that the first dynamics (on the left) only involves updating velocity ṽ in
the tangent space Tθ̃ SD and has the following solution (see
Appendix C for more details):
θ̃(t) = θ̃(0)
ṽ(t) = ṽ(0) −

D
Viewing {θ, BD
0 (1)} as a coordinate chart of S , this is
equivalent to replacing the Euclidean metric I with the
canonical spherical metric GS = ID + θθT /(1 − kθk22 ).
Therefore, we can write the Hamiltonian function (4) as

(7)

t
2

 

(11)
ID
T
− θ̃(0)θ(0)
∇U (θ(0))
0

where t denotes time.
The second dynamics (on the right) only involves the kinetic energy; hence, it is equivalent to the geodesic flow
on the sphere SD with a great circle (orthodrome or
Riemannian circle) as its analytical solution (see supplementary document at http://www.ics.uci.edu/
˜slan/SphHMC for more details),
ṽ(0)
θ̃(t)=θ̃(0) cos(kṽ(0)k2 t)+kṽ(0)k
sin(kṽ(0)k2 t)
2
(12)
ṽ(t)=−θ̃(0)kṽ(0)k2 sin(kṽ(0)k2 t)+ṽ(0) cos(kṽ(0)k2 t)

Spherical Hamiltonian Monte Carlo for Constrained Target Distributions

Algorithm 1 Spherical HMC

4.1. Norm constraints with q = +∞

(1)

Initialize θ̃ at current θ̃ after transformation
Sample a new momentum value ṽ (1) ∼ N (0, ID+1 )
Set ṽ (1) ← ṽ (1) − θ̃(1) (θ̃(1) )T ṽ (1)
Calculate H(θ̃(1) , ṽ (1) ) = U (θ(1) ) + K(ṽ (1) )
for ` = 1 to L do  

1
ID
− θ̃(`) (θ(`) )T ∇U (θ(`) )
ṽ (`+ 2 ) = ṽ (`) − 2
0

When q = +∞, the distribution is confined to a hypercube.
Note that hypercubes, and in general hyper-rectangles, can
be transformed to the unit hypercube, CD := [−1, 1]D =
{β ∈ RD : kβk∞ ≤ 1}, by proper shifting and scaling
of the original parameters. (Neal, 2010) discusses this kind
of constraints, which could be handled by adding a term
to the energy function such that the energy goes to infinity
(`+ 1 )
1
1
θ̃(`+1) = θ̃(`) cos(kṽ (`+ 2 ) k) + ṽ(`+ 12 ) sin(kṽ (`+ 2 ) k)
for values that violate the constraints. This creates “energy
2 k
kṽ
walls” at boundaries. As a result, the sampler bounces off
1
1
1
ṽ (`+ 2 ) ← −θ̃(`) kṽ (`+ 2 ) k sin(kṽ (`+ 2 ) k)
the energy wall whenever it reaches the boundaries. This
1
(`+ 21 )
k)
+ ṽ (`+ 2 ) cos(kṽ
 

approach, henceforth called Wall HMC, has limited appliID
(`+1)
(`+ 21 ) 
(`+1) (`+1) T
(`+1) cations and tends to be computationally inefficient.
∇U (θ
)
ṽ
= ṽ
−2
− θ̃
(θ
)
0
To use Spherical HMC, the unit hypercube can be transend for
formed to its inscribed unit ball through the following map:
Calculate H(θ̃(L+1) , ṽ (L+1) ) = U (θ(L+1) )+K(ṽ (L+1) )
Calculate the acceptance probability
α = exp{−H(θ̃(L+1) , ṽ (L+1) ) + H(θ̃(1) , ṽ (1) )}
Accept or reject the proposal according to α
(n)
Calculate the corresponding weight |θD+1 |

Note that (11) and (12) are both symplectic. Due to the explicit formula for the geodesic flow on sphere, the second
dynamics in (10) is simulated exactly. Therefore, updating
θ̃ does not involve discretization error so we can use large
step sizes. This could lead to improved computational efficiency. Since this step is in fact a rotation on sphere, we set
the trajectory length to be 2π/D and randomize the number
of leapfrog steps to avoid periodicity. Algorithm 1 shows
the steps for implementing this approach, henceforth called
Spherical HMC.

4. Norm constraints
The unit ball region discussed in the previous section is in
fact a special case of q-norm constraints. In this section we
discuss q-norm constraints in general and show how they
can be transformed to the unit ball so that the Spherical
HMC method can be used. In general, these constraints are
expressed in terms of q-norm of parameters,

 PD
( i=1 |βi |q )1/q , q ∈ (0, +∞)
kβkq =
max1≤i≤D |βi |, q = +∞

(13)

For example, when β are regression parameters, q = 2
corresponds to ridge regression and q = 1 corresponds to
Lasso (Tibshirani, 1996). In what follows, we show how
this type of constraints can be transformed to SD .

TC→B : [−1, 1]D → BD
0 (1),

β 7→ θ = β

kβk∞
(14)
kβk2

Further, as discussed in the previous section, the resulting
unit ball can be mapped to sphere SD through TB→S for
which the Spherical HMC can be used. See Appendix B
for the derivation of the corresponding weights needed for
the change of variable.
4.2. Norm constraints with q ∈ (0, +∞)
A domain constrained by q-norm QD := {x ∈ RD :
kβkq ≤ 1} for q ∈ (0, +∞) can be transformed to the
unit ball BD
0 (1) via the following map:
TQ→B : QD → BD
0 (1),

βi 7→ θi = sgn(βi )|βi |q/2
(15)
As before, the unit ball can be transformed to the sphere
for which we can use the Spherical HMC method. See Appendix B for the derivation of the corresponding weights
required for the change of variable.

5. Experimental results
In this section, we evaluate our proposed methods, Spherical HMC, by comparing its efficiency to that of Random Walk Metropolis (RWM) and Wall HMC using simulated and real data. To this end, we define efficiency
in terms of time-normalized effective sample size (ESS).
Given B MCMC samples for each parameter, ESS = B[1 +
−1
2ΣK
, where ΣK
k=1 γ(k)]
k=1 γ(k) is the sum of K monotone sample autocorrelations (Geyer, 1992). We use the
minimum ESS normalized by the CPU time, s (in seconds), as the overall measure of efficiency: min(ESS)/s.
All computer codes are available online at http://www.
ics.uci.edu/˜slan/SphHMC.

Spherical Hamiltonian Monte Carlo for Constrained Target Distributions

−2

−1

0
β1

1

2

−2

−1

0
β1

1

2

4

4

7 1 10

6

10
0

2

7 1 10

Coefficients

8

5

−20

−20
0

0.2

0.4

0.6

0.8

1

Shrinkage Factor

−30

−30

−30

−2

−2

−20

5

2

−10

0

1 10

Coefficients

2

−10

0

Coefficients

−10

β2
0
−1

0.02

0.08

β2
0
−1

0.04

0.06

10

0.14
0.16

10

0.1

0.12

20

20
4

1

1

20

6

3

3

9

30

Bayesian Lasso
Spherical HMC

30

Bayesian Lasso
Wall HMC

30

2

2

Bayesian Lasso
Gibbs Sampler

0

0.2

0.4

0.6

0.8

Shrinkage Factor

1

0

0.2

0.4

0.6

0.8

1

Shrinkage Factor

Figure 2. Density plots of a truncated bivariate Gaussian using exact density function (left) and MCMC samples from Spherical
HMC (Right).

Figure 3. Bayesian Lasso using three different sampling algorithms: Gibbs sampler (left), Wall HMC (middle) and Spherical
HMC (right).

Table 1. Comparing RWM, Wall HMC, and Spherical HMC in
terms of acceptance probability (AP), seconds (s) per iteration,
and Min(ESS)/s.

For each method, we obtain 10000 MCMC samples after
discarding the initial 1000 samples. We set the tuning parameters of algorithms such that their overall acceptance
rates are within a reasonable range. As shown in Table 1,
Spherical HMC is substantially more efficient than RWM
and Wall HMC. For RWM, proposed states are rejected
about 95% of times due to violation of constraints. On average, Wall HMC bounces off the wall around 7.68 and 31.10
times per iteration for D = 10 and D = 100 respectively.
In contrast, by augmenting the parameter space, Spherical
HMC handles the constraints in an efficient way.

Dim
D=10
D=100

Method
RWM
Wall HMC
Spherical HMC
RWM
Wall HMC
Spherical HMC

AP
0.64
0.93
0.81
0.72
0.94
0.88

s/Iteration
1.6E-04
5.8E-04
9.7E-04
1.3E-03
1.4E-02
1.5E-02

Min(ESS)/s
8.80
426.79
602.78
0.06
14.23
40.12

5.1. Truncated Multivariate Gaussian
For illustration purposes, we first start with a truncated bivariate Gaussian distribution,
 
 

β1
1 .5
∼ N 0,
,
.5 1
β2
0 ≤ β1 ≤ 5,

0 ≤ β2 ≤ 1

The lower and upper limits are l = (0, 0) and u = (5, 1) respectively. The original rectangle domain can be mapped to
the 2-dimensional unit sphere through the following transformation:
T : [0, 5] × [0, 1] → S 2 , β 7→ β 0 = (2β − (u + l))/(u − l)
q

kβ 0 k∞
7→ θ̃ = θ, 1 − kθk22
7→ θ = β 0 0
kβ k2
The left panel of Figure 2 shows the heatmap based on the
exact density function, and the right panel shows the corresponding heatmap based on MCMC samples from Spherical HMC.
To evaluate the efficiency of the above-mentioned methods
(RWM, Wall HMC, and Spherical HMC), we repeat this
experiment for higher dimensions, D = 10, and D = 100.
As before, we set the mean to zero and set the (i, j)-th element of the covariance matrix to Σij = 1/(1 + |i − j|).
Further, we assume 0 ≤ βi ≤ ui , where ui (i.e., the upper
bound) is set to 5 when i = 1; otherwise, it is set to 0.5.

5.2. Bayesian Lasso
In regression analysis, overly complex models tend to overfit the data. Regularized regression models control complexity by imposing a penalty on model parameters. By far,
the most popular model in this group is Lasso (least absolute shrinkage and selection operator) proposed by Tibshirani (Tibshirani, 1996). In this approach, the coefficients
are obtained by minimizing
the residual sum of squares
PD
(RSS) subject to j=1 |βj | ≤ t. Park and Casella (Park
& Casella, 2008) and Hans (Hans, 2009) have proposed a
Bayesian alternative method, called Bayesian Lasso, where
the penalty term is replaced by a prior distribution of the
form P (β) ∝ exp(−λ|βj |), which can be represented as
a scale mixture of normal distributions (West, 1987). This
leads to a hierarchical Bayesian model with full conditional
conjugacy; Therefore, the Gibbs sampler can be used for
inference.
Our proposed method in this paper can directly handle
the constraints in Lasso models. That is, we can conveniently use Gaussian priors for model parameters, β|σ 2 ∼
N (0, σ 2 I), and use Spherical HMC with the transformation discussed in Section 4.2.
We evaluate our method based on the diabetes data set
(N=442, D=10) discussed in (Park & Casella, 2008).
Figure 3 compares coefficient estimates given by the
Gibbs sampler (Park & Casella, 2008), Wall HMC, and
Spherical HMC algorithms as the shrinkage factor s :=

Spherical Hamiltonian Monte Carlo for Constrained Target Distributions
Beysian Bridge
q=0.8

0.3

0.4

0.5
0.6
Shrinkage Factor

0.7

0.8

0.9

1

20

20

4

6
10

5 1
7

1 10 8

Coefficients

0
−10

2

6

10
0

7 1 10

Coefficients

−20

5
0

0.2

0.4

0.6

0.8

5
0

1

Shrinkage Factor

Figure 4. Sampling efficiency of different algorithms for
Bayesian Lasso based on the diabetes dataset.

0.2

0.4

0.6

0.8

1

−30

0.2

−30

0.1

−30

0

−20

−20

200

2

−10

0
−10

Coefficients

Min(ESS)/s
400
600

10

4

800

20

9

3

3

30

30

30

9

Beysian Bridge
q=1.2

9

1000

Beysian Bridge
Lasso (q=1)
Gibbs Sampler
Wall HMC
Spherical HMC

0

Shrinkage Factor

0.2

0.4

0.6

0.8

1

Shrinkage Factor

Figure 5. Bayesian Bridge Regression by Spherical HMC: Lasso
(q=1, left), q=1.2 (middle), and q=0.8 (right).

5.4. Modeling synchrony among multiple neurons
Lasso

OLS

OLS

kβ̂
k1 /kβ̂ k1 changes from 0 to 1. Here, β̂
denotes the estimates obtained by ordinary least squares
(OLS) regression. For the Gibbs sampler, we choose different λ so that the corresponding shrinkage factor s varies
from 0 to 1. For Wall HMC and Spherical HMC, we
fix the number of leapfrog steps to 10 and set the trajectory length such that they both have comparable acceptance
rates around 70%.
Figure 4 compares the sampling efficiency of these three
methods. As we impose tighter constraints (i.e., lower
shrinkage factors s), our method becomes substantially
more efficient than the Gibbs sampler and Wall HMC.
5.3. Bridge regression
The Lasso model discussed in the previous section is in
fact a member of a family of regression models called
Bridge regression (Frank & Friedman, 1993), where the
coefficients are obtained
PDby minimizing the residual sum
of squares subject to j=1 |βj |q ≤ t. For Lasso, q = 1,
which allows the model to force some of the coefficients
to become exactly zero (i.e., become excluded from the
model).
As mentioned earlier, our Spherical HMC method can easily handle this type of constraints through the following
transformation:
D

T :Q

D

→ S , βi 7→

βi0

H(y1 , ..., yn ) = C(F1 (y1 ), ..., Fn (yn )), for all y1 , . . . , yn
Here, C defines the dependence structure between the
marginals. Shahbaba et al. (Shahbaba et al., 2013a) use
a special case of the Farlie-Gumbel-Morgenstern (FGM)
copula family (Farlie, 1960; Gumbel, 1960; Morgenstern,
1956; Nelsen, 1998), for which C has the following form:
n
X

1+

X

βj1 j2 ...jk

k=2 1≤j1 <···<jk ≤n

q



Figure 5 compares the parameter estimates of Bayesian
Lasso to the estimates obtained from two Bridge regression models with q = 1.2 and q = 0.8 for the diabetes
dataset (Park & Casella, 2008) using our Spherical HMC
algorithm. As expected, tighter constraints (e.g., q = 0.8)
would lead to faster shrinkage of regression parameters as
we decrease s.

i=1

l=1

X
1≤j1 <j2 ≤n

1 − kθk22

k
n
Y
Y
(1 − Fjl )
Fi

where Fi = Fi (yi ). Restricting the model to second-order
interactions, we have

H(y1 , . . . , yn ) = 1 +

= βi /t

7→ θi = sgn(βi0 )|βi0 |q/2 , θ 7→ θ̃ = θ,

Shahbaba et al. (Shahbaba et al., 2013a) have recently
proposed a semiparametric Bayesian model to capture dependencies among multiple neurons by detecting their cofiring patterns over time. In this approach, after discretizing
time, there is at most one spike in each interval. The resulting sequence of 1’s (spike) and 0’s (silence) for each neuron
is called a spike train, which is denoted as Y and is modeled using the logistic function of a continuous latent variable with a Gaussian process prior. For n neurons, the joint
probability distribution of spike trains, Y1 , . . . , Yn , is coupled to the marginal distributions using a parametric copula
model. Let H be n-dimensional distribution functions with
marginals F1 , ..., Fn . In general, an n-dimensional copula
is a function with the following form:

βj 1 j 2

2
n
Y
Y
(1 − Fjl )
Fi
l=1

i=1

Here, Fi = P (Yi ≤ yi ) for the ith neuron (i = 1, . . . , n),
where y1 , . . . , yn denote the firing status of n neurons at
time t. βj1 ,j2 captures the relationship between the j1 th and
j2 th neurons, with βj1 ,j2 = 0 interpreted as “no relationship” between the two neurons. To ensure that probability distribution functions
 remain within [0, 1], the following
constraints on all n2 parameters, βj1 j2 , are imposed:
1+

X
1≤j1 <j2 ≤n

βj 1 j 2

2
Y
l=1

jl ≥ 0,

1 , · · · , n ∈ {−1, 1}

Spherical Hamiltonian Monte Carlo for Constrained Target Distributions
Table 2. Comparing RWM, Wall HMC, and Spherical HMC
based on the copula model.
Scenario
I
II

Method
RWM
Wall HMC
Spherical HMC
RWM
Wall HMC
Spherical HMC

AP
0.69
0.67
0.83
0.67
0.75
0.81

s/Iteration
8.2
17.0
17.0
8.1
19.4
18.0

Min(ESS)/s
2.8E-04
7.0E-03
2.0E-02
2.8E-04
1.8E-03
2.2E-02

Acknowledgments
We would like to thank Jeffrey Streets, Max Welling, and
Alexander Ihler for helpful discussion. This work is supported by NSF grant IIS-1216045 and NIH grant R01AI107034.

Appendix
A. From unit ball to sphere

Considering all possible combinations of j1 and j2 in
the above condition, there are
Pn(n − 1) linear inequalities,
which can be expressed as 1≤j1 <j2 ≤n |βj1 j2 | ≤ 1. For
this model, we can use the square root mapping described
in section 4.2 to transform the original domain (q = 1) of
parameters to the unit ball before using Spherical HMC.
We apply our method to a real dataset based on an experiment investigating the role of prefrontal cortical area in
rats with respect to reward-seeking behavior discussed in
(Shahbaba et al., 2013a). Here, we focus on 5 simultaneously recorded neurons under two scenarios: I) rewarded
(pressing a lever by rats delivers 0.1 ml of 15% sucrose solution), and II) non-rewarded (nothing happens after pressing a lever by rats). There are 51 trails for each scenario. The copula model detected significant associations
among three neurons: the first and forth neurons (β1,4 ) under the rewarded scenario, and the third and forth neurons
(β3,4 ) under the non-rewarded scenario. All other parameters were deemed non-significant (based on 95% posterior
probability intervals). As we can see in Table 2, Spherical
HMC is order(s) of magnitudes more efficient than RWM
and Wall HMC.

D
Consider the D-dimensional ball BD
:
0 (1) = {θ ∈ R
D
kθk2 ≤ 1} and the D-dimensional sphere S = {θ̃ =
(θ, θD+1 ) ∈ RD+1 : kθ̃k2 = 1}. Note that {θ, BD
0 (1)}
can be viewed as a coordinate chart for SD . The first fundamental form ds2 (i.e., squared infinitesimal length of a
curve) for SD is explicitly expressed in terms of the differential form dθ and the canonical metric GS as

ds2 = hdθ, dθiGS = dθT GS dθ
which can be obtained as follows (Spivak, 1979):
ds2 =

D+1
X

dθi2 =

i=1

= dθT dθ +

In this paper, we assumed the Euclidean metric I on unit
ball, BD
0 (1). The proposed approach can be extended to
more complex metrics, such as the Fisher information metric GF , in order to exploit the geometric properties of the
parameter space (Girolami & Calderhead, 2011). This way,
the metric for the augmented space could be defined as
2
GF + θθT /θD+1
. Under such a metric however, we might
not be able to find the geodesic flow analytically. This
could undermine the added benefit from using the Fisher
information metric.

dθi2 + (d(θD+1 (θ)))2

i=1
T

(θ dθ)2
2
= dθT [I + θθT /θD+1
]dθ
1 − kθk22

Therefore, the canonical metric GS of SD is
GS = ID +

θθT
2
θD+1

For any vector ṽ = (v, vD+1 ) ∈ Tθ̃ SD = {ṽ ∈ RD+1 :
θ̃T ṽ = 0}, one could view GS as a mean to express the
length of ṽ in v:

6. Discussion
We have introduced a new efficient sampling algorithm for
constrained distributions. Our method first maps the parameter space to the unit ball and then augments the resulting space to a sphere. Further, by using the splitting
strategy, we could improve the computational efficiency of
our algorithm. A dynamical system is then defined on the
sphere to propose new states that are guaranteed to remain
within the boundaries imposed by the constraints.

D
X

v T GS v = kvk22 +

v T θθT v
(−θD+1 vD+1 )2
= kvk22 +
2
2
θD+1
θD+1

2
= kvk22 + vD+1
= kṽk22

The determinant of the canonical metric GS is given by the
matrix determinant lemma,
det GS = det(ID +

θθT
θT θ
1
)=1+ 2
= 2
2
θD+1
θD+1
θD+1

and the inverse of GS is obtained by the ShermanMorrison-Woodbury formula (Golub & Van Loan, 1996)

−1
2
θθT /θD+1
θθT
−1
GS = ID + 2
= ID −
= ID − θθT
2
θD+1
1 + θT θ/θD+1
We now find the Jacobian determinant of TS→B . Using the
volume form (Spivak, 1979), we have
Z
Z
p
f (θ̃)dθ̃S =
f (θ) det GS dθB
SD
+

BD
0 (1)

Spherical Hamiltonian Monte Carlo for Constrained Target Distributions

The
p transformation TB→S : θ 7→ θ̃ = (θ, θD+1 =
1 − kθk22 ) bijectively maps the unit ball BD
0 (1) to the
upper-hemisphere SD
+ . Using the change of variable theorem, we have


Z
Z
 dθ̃ 
 S
f (θ̃)dθ̃S =
f (θ) 
 dθB
 dθB 
SD
BD
0 (1)
+
from which we can obtain the Jacobian determinant of
TB→S as follows:


 dθ̃  p
 S

 = det GS = 1/|θD+1 |
 dθB 
Therefore, the Jacobian determinant of TS→B is |θD+1 |.

B. Transformations between different
constrained domains
Denote the general hyper-rectangle type constrained domain as RD := {β ∈ RD : l ≤ β ≤ u}. For transformations TS→R and TS→Q , we can find the Jacobian determinants as follows. First, we note
TS→R = TC→R ◦ TB→C ◦ TS→B
TS→B : θ̃ 7→ θ
kθk2
kθk∞
u−l 0 u+l
β +
: β0 →
7 β=
2
2

TB→C : θ 7→ β 0 = θ
TC→R

Therefore the Jacobian Determinant of TS→Q is
|dTS→Q | = |dTB→Q | |dTS→B |
!2/q−1

  D Y

D
 dβ   dθB 
2
=
=  T  
|θi |
|θD+1 |
dθ
q
dθ̃S 
i=1

C. Splitting Hamilton dynamics on SD
Splitting the Hamiltonian function and its usefulness in improving HMC is a well-studied topic of research (Leimkuhler & Reich, 2004; Shahbaba et al., 2013b; Byrne & Girolami, 2013). Splitting the Lagrangian function (used in our
approach), on the other hand, has not been discussed in
the literature, to the best of our knowledge. Therefore,
we prove the validity of our splitting method by starting
with the well-understood method of splitting Hamiltonian
(Byrne & Girolami, 2013),
1
H ∗ (θ, p) = U (θ)/2 + pT GS −1 p + U (θ)/2
2
The corresponding systems of differential equations,


θ̇ = GS −1 p
θ̇ = 0
1
ṗ = − 2 ∇U (θ)
ṗ = − 12 pT GS −1 dGS GS −1 p
can be written in terms of Lagrangian dynamics as follows:
in (θ, v) (Lan et al., 2012):


θ̇ = 0
θ̇ = v
1 −1
v̇ = −v T Γv
v̇ = − 2 GS ∇U (θ)

The corresponding Jacobian matrices are
To solve the first dynamics, we note that
!#
"
θT
eTarg max |θ|
dβ 0
kθk2
θT
θ̇D+1 =
− θD+1
θ̇
=0
dTB→C :
=
−
I
+
θ
dθT
kθk∞
kθk22
θarg max |θ|
1 θT
θT v
θ̇ T v+θ T v̇
+
θ̇
=
G−1
v̇
=
−
2
D+1
D+1
S ∇U (θ)
θD+1
θD+1
dβ
u−l
2
θ
D+1
dTC→R :
=
diag(
)
d(β 0 )T
2
Therefore, we have
where earg max |θ| is a vector with (arg max |θ|)-th element
θ̃(t) = θ̃(0)
1 and all others 0. Therefore,
"
#
I
t
|dTS→R | = |dTC→R | |dTB→C | |dTS→B |
ṽ(t) = ṽ(0) −
[I − θ(0)θ(0)T ]∇U (θ)
θ(0)T
−
2
θ
(0)




D+1
D
D Y
 dβ   dβ 0   dθB 
ui − li
 = |θD+1 | kθk2


= 
where
d(β 0 )T   dθT   dθ̃S 
kθkD
2
∞ i=1
#
"


I
I − θ(0)θ(0)T
T
T
[I − θ(0)θ(0) ] =
θ(0)
Next, we note
−θD+1 (0)θ(0)T
− θD+1
(0)
 
I
TS→Q = TB→Q ◦ TS→B : θ̃ 7→ θ 7→ β = sgn(θ)|θ|2/q
=
− θ̃(0)θ(0)T
0
The Jacobian matrix for TB→Q is
dβ
2
= diag(|θ|2/q−1 )
dθT
q

Finally, we note that kθ̃(t)k2 = 1 if kθ̃(0)k2 = 1 and
ṽ(t) ∈ Tθ̃(t) SD if ṽ(0) ∈ Tθ̃(0) SD .

Spherical Hamiltonian Monte Carlo for Constrained Target Distributions

References
Beskos, A., Pinski, F. J., Sanz-Serna, J. M., and Stuart,
A. M. Hybrid Monte-Carlo on Hilbert spaces. Stochastic
Processes and their Applications, 121:2201–2230, 2011.
Brubaker, M. A., Salzmann, M., and Urtasun, R.. A family of mcmc methods on implicitly defined manifolds.
In Lawrence, N. D. and Girolami, M. A. (eds.), Proceedings of the Fifteenth International Conference on
Artificial Intelligence and Statistics (AISTATS-12), volume 22, pp. 161–172, 2012.
Byrne, S. and Girolami, M. Geodesic Monte Carlo on Embedded Manifolds. ArXiv e-prints, January 2013.
Duane, S., Kennedy, A. D., Pendleton, B J., and Roweth,
D. Hybrid Monte Carlo. Physics Letters B, 195(2):216
– 222, 1987.
Farlie, D. J. G. The performance of some correlation coefficients for a general bivariate distribution. Biometrika,
47(3/4), 1960.
Frank, I. E. and Friedman, J. H. A Statistical View of Some
Chemometrics Regression Tools. Technometrics, 35(2):
109–135, 1993.
Geyer, C. J. Practical Markov Chain Monte Carlo. Statistical Science, 7(4):473–483, 1992.
Girolami, M. and Calderhead, B. Riemann manifold
Langevin and Hamiltonian Monte Carlo methods. Journal of the Royal Statistical Society, Series B, (with discussion) 73(2):123–214, 2011.
Golub, G. H. and Van Loan, C. F. Matrix computations
(3rd ed.). Johns Hopkins University Press, Baltimore,
MD, USA, 1996. ISBN 0-8018-5414-8.
Gumbel, E. J. Bivariate exponential distributions. Journal of the American Statistical Association, 55:698–707,
1960.
Hans, C.. Bayesian lasso regression. Biometrika, 96(4):
835–845, 2009.
Hoffman, M. and Gelman, A. The No-U-Turn Sampler:
Adaptively Setting Path Lengths in Hamiltonian Monte
Carlo. arxiv.org/abs/1111.4246, 2011.
Lan, S., Stathopoulos, V., Shahbaba, B., and Girolami, M.
Lagrangian Dynamical Monte Carlo.
arxiv.org/abs/1211.3759, 2012.
Leimkuhler, B. and Reich, S. Simulating Hamiltonian Dynamics. Cambridge University Press, 2004.

Morgenstern, D. Einfache beispiele zweidimensionaler
verteilungen. Mitteilungsblatt für Mathematische Statistik, 8:234–235, 1956.
Neal, P. and Roberts, G. O. Optimal scaling for random
walk metropolis on spherically constrained target densities. Methodology and Computing in Applied Probability, Vol.10(No.2):277–297, June 2008.
Neal, P., Roberts, G. O., and Yuen, W. K. Optimal scaling of random walk metropolis algorithms with discontinuous target densities. Annals of Applied Probability,
Volume 22(Number 5):1880–1927, 2012.
Neal, R. M. MCMC using Hamiltonian dynamics. In
Brooks, S., Gelman, A., Jones, G., and Meng, X. L.
(eds.), Handbook of Markov Chain Monte Carlo. Chapman and Hall/CRC, 2010.
Nelsen, R. B. An Introduction to Copulas (Lecture Notes
in Statistics). Springer, 1 edition, 1998.
Pakman, A. and Paninski, L. Exact Hamiltonian Monte
Carlo for Truncated Multivariate Gaussians. ArXiv eprints, August 2012.
Park, T. and Casella, G.. The bayesian lasso. Journal
of the American Statistical Association, 103(482):681–
686, 2008.
Shahbaba, B., Zhou, B., Ombao, H., Moorman, D., and
Behseta, S. A semiparametric Bayesian model for neural
coding. arXiv:1306.6103, 2013a.
Shahbaba, B., Lan, S., Johnson, W. O., and Neal, R. M.
Split hamiltonian monte carlo. Statistics and Computing, pp. 1–11, 2013b. ISSN 0960-3174. doi: 10.1007/
s11222-012-9373-1.
Sherlock, C. and Roberts, G. O. Optimal scaling of the random walk metropolis on elliptically symmetric unimodal
targets. Bernoulli, Vol.15(No.3):774–798, August 2009.
Spivak, M. A Comprehensive Introduction to Differential
Geometry, volume 1. Publish or Perish, Inc., Houston,
second edition, 1979.
Tibshirani, R. Regression shrinkage and selection via the
lasso. Journal of the Royal Statistical Society, Series B,
58(1):267–288, 1996.
West, M. On scale mixtures of normal distributions.
Biometrika, 74(3):646–648, 1987.

