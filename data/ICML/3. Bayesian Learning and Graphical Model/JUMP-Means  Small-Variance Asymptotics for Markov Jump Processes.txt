JUMP-Means: Small-Variance Asymptotics for
Markov Jump Processes

Jonathan H. Huggins*
Karthik Narasimhan*
Ardavan Saeedi*
Vikash K. Mansinghka
Computer Science and Artificial Intelligence Laboratory, MIT
*These authors contributed equally and are listed alphabetically.

Abstract
Markov jump processes (MJPs) are used to
model a wide range of phenomena from disease progression to RNA path folding. However, maximum likelihood estimation of parametric models leads to degenerate trajectories
and inferential performance is poor in nonparametric models. We take a small-variance asymptotics (SVA) approach to overcome these limitations. We derive the small-variance asymptotics
for parametric and nonparametric MJPs for both
directly observed and hidden state models. In
the parametric case we obtain a novel objective
function which leads to non-degenerate trajectories. To derive the nonparametric version we introduce the gamma-gamma process, a novel extension to the gamma-exponential process. We
propose algorithms for each of these formulations, which we call JUMP-means. Our experiments demonstrate that JUMP-means is competitive with or outperforms widely used MJP inference approaches in terms of both speed and
reconstruction accuracy.

1. Introduction
Markov jump processes (MJPs) are continuous-time,
discrete-state Markov processes in which state durations
are exponentially distributed according to state-specific
rate parameters. A stochastic matrix controls the probability of transitioning between pairs of states. MJPs have been
used to construct probabilistic models either when the state
of a system is observed directly, such as with disease proProceedings of the 32 nd International Conference on Machine
Learning, Lille, France, 2015. JMLR: W&CP volume 37. Copyright 2015 by the author(s).

JHUGGINS @ MIT. EDU
KARTHIKN @ MIT. EDU
ARDAVANS @ MIT. EDU
VKM @ MIT. EDU

gression (Mandel, 2010) and RNA path folding (Hajiaghayi
et al., 2014), or when the state is only observed indirectly,
as in corporate bond rating (Bladt & Sørensen, 2009). For
example, consider the important clinical task of analyzing
physiological signals of a patient in order to detect abnormalities. Such signals include heart rate, blood pressure,
respiration, and blood oxygen level. For an ICU patient,
an abnormal state might be the precursor to a cardiac arrest event while for an epileptic, the state might presage a
seizure (Goldberger et al., 2000). How can the latent state
of the patient be inferred by a Bayesian modeler, so that,
for example, an attending nurse can be notified when a patient enters an abnormal state? MJPs offer one attractive
approach to analyzing such physiological signals.
Applying an MJP model to physiological signals presents
a challenge: the number of states is unknown and must
be inferred using, for example, Bayesian nonparametric
methods. However, efficient inference in nonparametric MJP models is a challenging problem, where existing methods based on particle MCMC scale poorly and
mix slowly (Saeedi & Bouchard-Côté, 2011). Current
optimization-based methods such as expectation maximization (EM) are inapplicable if the state size is countably
infinite; hence, they cannot be applied to Bayesian nonparametric MJP models, as we would like to do for physiological signals.
Furthermore, although MJPs are viewed as more realistic
than their discrete-time counterparts in many fields (Rao &
Teh, 2013), degenerate solutions for the maximum likelihood (ML) trajectories for both directly and indirectly observed cases (Perkins, 2009), and non-existence of the ML
transition matrix (obtained from EM) for some indirectly
observed cases (Bladt & Sørensen, 2009) present inferential challenges. Degenerate ML trajectories occur when
some of the jump times are infinitesimal, which severely
undermines the practicality of such approaches. For instance, a trajectory which predicts a patient’s seizure for an

JUMP-Means: SVA for MJPs

s1

state

t1

s2
t2

s0
t0

⌧1

⌧2

⌧3

⌧4

⌧5 time

x1

x2

x3

x4

x5

Notation
M : number of states
π: initial state distribution
P : state transition matrix, with entries pss0
λs : transition rate for state s
U = (s0 , t0 , s1 , t1 , . . . , sK−1 , tK−1 , sK ): MJP trajectory
S: the states corresponding to U
T : the times corresponding to U
O = {(t̃i , s̃i )}: observation times and states of DOMJP*
τ = (τ1 , . . . , τL ): observation times of HMJP
X = (x1 , . . . , xL ): observations of HMJP
ρsn : probability of observing x` = n when in state s

Figure 1. Left: Illustrative example for an HMJP (Section 3.2) with three hidden states (M = 3) and two possible observation values
(N = 2). The observations X , their times τ , an (arbitrary) sample MJP trajectory U = (s0 , t0 , s1 , t1 , s2 , t2 ). Right: Notation used for
parametric MJPs. *DOMJP = directly observed MJP.

infinitesimal amount of time is of limited use to the medical
staff. Fig. 3 shows an example of the degeneracy problem.
In this paper, we take a small-variance asymptotics (SVA)
approach to develop an optimization-based framework for
efficiently estimating the most probable trajectories (states)
for both parametric and nonparametric MJP-based models. Small-variance asymptotics has recently proven to be
useful in estimating the parameters and inferring the latent
states in rich probabilistic models. SVA extends the wellknown connection between mixtures of Gaussians and kmeans: as the variances of the Gaussians approach zero,
the maximum a posteriori solution to the mixture of Gaussians model degenerates to k-means solution (Kulis & Jordan, 2012). The same idea can be applied to obtain wellmotivated objective functions that correspond to a latent
variable model for which scalable inference via standard
methods like MCMC is challenging. SVA has been applied
to (hierarchical) Dirichlet process mixture models (Kulis
& Jordan, 2012; Jiang et al., 2012), Bayesian nonparametric latent feature models (Broderick et al., 2013), hidden
Markov models (HMMs), and infinite-state HMMs (Roychowdhury et al., 2013).
We apply the SVA approach to both parametric and
Bayesian nonparametric MJP models to obtain what we
call the JUMP-means objective functions. In the parametric case, we derive a novel objective function which does
not suffer from maximum likelihood’s solution degeneracy,
leading to more stable and robust inference procedures in
both the directly observed and hidden state cases. Infinitestate MJPs (iMJPs) are constructed from the hierarchical
gamma-exponential process (HΓEP) (Saeedi & BouchardCôté, 2011). In order to apply SVA to iMJPs, we generalize
the HΓEP to obtain the first deterministic procedure (we
know of) for inference in Bayesian nonparametric MJPs.
We evaluate JUMP-means on several synthetic and realworld datasets in both the parametric and Bayesian non-

parametric cases. JUMP-means performs on par with or
better than existing methods, offering an attractive speedaccuracy tradeoff. We obtain significant improvements in
the non-parametric case, gaining up to a 20% reduction in
mean error on the task of observation reconstruction. In
summary, the JUMP-means approach leads to algorithms
that 1) are applicable to MJPs with Bayesian nonparametric priors; 2) provide non-degenerate solutions for the most
probable trajectories; and 3) are comparable to or outperform other standard methods of inference both in terms of
speed and reconstruction accuracy.

2. Background
2.1. Markov Jump Processes
A Markov jump process (MJP) is defined by (a) a finite (or
countable) state space, which we identify with the integers
[M ] , {1, . . . , M }; (b) an initial state probability distribution π; (c) a (stochastic) state transition matrix P with
pss = 0 for all s ∈ [M ]; and (d) a state dwell-time rate
vector λ , (λ1 , . . . , λM ). The process begins in a state
s0 ∼ π. When the process enters a state s, it remains there
for a dwell time that is exponentially distributed with parameter λs . When the system leaves state s, it transitions
to state s0 6= s with probability pss0 .
A trajectory of the MJP is a sequence of states and a
dwell time for each state, except for the final state: U ,
UT , (s0 , t0 , s1 , t1 , . . . , sK−1 , tK−1 , sK ). Implicitly, K
(and thus U) is a random variable such that tK−1 < T
and the system is in state sK at time T . Let S , ST ,
(s0 , s1 , . . . , sK ) and T , TT , (t0 , t1 , . . . , tK−1 ) be the
sequences of states and times corresponding to U. The
probability of a trajectory is given by
p(U | π, P, λ) = 1[t· ≤ T ]e−λsK (T −t· ) πs0
(1)
QK
−λsk−1 tk−1
× k=1 λsk−1 e
psk−1 sk ,

JUMP-Means: SVA for MJPs

PK−1
where t· ,
k=0 tk and 1[·] is the indicator function.
In many cases when the states are directly observed, the
initial state and the final state are observed, in which case
it is straightforward to obtain a likelihood from (1).
A hidden state MJP (HMJP) is an MJP in which the states
are observed indirectly according to a likelihood model
p(x | s), s ∈ [M ], x ∈ X, where X is some observation
space. The times of the observations τ = (τ1 , . . . , τL )
are chosen independent of U, so the probability of the observations X , (x1 , . . . , xL ) is given by p(X | U, τ ) =
QL
`=1 p(x` | sτ` ), where, with an abuse of notation, we
write sτ for the state of the MJP at time τ .
2.2. Previous Approaches to MJP Inference
There are a number of existing approaches to inference and
learning in MJPs. An expectation-maximization (EM) algorithm can be derived, but it cannot be applied to models with countably infinite states, so it is not suitable for
iMJPs (Lange, 2014) (iMJPs are detailed in Section 4).
Moreover, with discretely observed data, the maximumlikelihood estimate with finite entries for the transition matrix obtained from EM may not exist (Bladt & Sørensen,
2005).
Maximum likelihood inference amounts to finding
maxU ln p(U | π, P, λ), which can be carried out efficiently using dynamic programming (Perkins, 2009).
However, maximum likelihood solutions for the trajectory
are degenerate: only an infinitesimal amount of time is
spent in each state, except for the state visited with the
smallest rate parameter (i.e., longest expected dwell time).
Such a solution is unsatisfying and unintuitive because
the dwell times are far from their expected values. Thus,
maximum likelihood inference produces results that are
unrepresentative of the model behavior.
Markov chain Monte Carlo methods have also been developed, but these can be slow and their convergence is often
difficult to diagnose (Rao & Teh, 2013). Recently, a more
efficient Monte Carlo method was proposed in Hajiaghayi
et al. (2014) which is based on particle MCMC (PMCMC)
methods (Andrieu et al., 2010). This approach addresses
the issue of efficiency, but since it marginalizes over the
jump points, it cannot provide probable trajectories.
2.3. Small-variance Asymptotics
Consider a Bayesian model p(D | Z, θ, σ 2 )p(Z, θ) in which
the likelihood terms contain a variance parameter σ 2 .
Given some data D, a point estimate for the parameters θ and latent variables Z of the model can obtained by maximizing the posterior p(Z, θ | D, σ 2 ) ∝
p(D | Z, θ, σ)p(Z, θ), resulting in a maximum a posteriori
(MAP) estimate. In the SVA approach (Broderick et al.,

2013), the MAP optimization is considered in the limit as
the likelihood variance parameter is taken to zero: σ 2 → 0.
Typically, the small-variance limit leads to a much simpler optimization than the MAP optimization with non-zero
variance. For example, the MAP objective for a Gaussian
mixture model simplifies to the k-means objective.

3. Parametric MJPs
3.1. Directly Observed MJP
Consider the task of inferring likely state/dwell-time sequences given O = {(t̃i , s̃i )}Ii=1 , the times at which the
system was directly observed and the states of the system
at those times. For simplicity we assume that t̃0 = 0 and
that all times are in the interval [0, T ]. Let s(U, t) be the
state of the system following trajectory U at time t. The
likelihood of a sequence is
`(U | O, P, λ) = 1[t· ≤ T ]
×

K
Y

I
Y

1[s(U, t̃i ) = s̃i ]

i=1

(2)

!
λsk−1 e−λsk−1 tk−1 psk−1 sk

e−λsK (T −t· )

k=1

We also place a gamma prior on the rate parameters λ
(detailed below). Instead of relying on MAP estimation,
we apply a small variance asymptotics analysis to obtain
a more stable objective function. Following (Jiang et al.,
2012), we scale the distributions by an inverse variance
parameter β and then maximize the scaled likelihood and
prior in the limit β → ∞ (i.e., as the variance goes to zero).
Scaling the exponential distribution f (t; λ) = λ exp(−λt)
produces the two-parameter family with
ln f (t; λ, β) =


β ln β − ln Γ(β) ln t
+
,
− β λt − ln t − ln λ −
β
β
which is the density of a gamma distribution with shape
parameter β and rate parameter βλ. Hence, the mean of
the scaled distribution is λ1 and its variance is λ21β . Letting
F (t; λ, β) denote the CDF corresponding to f (t; λ, β), we
have 1 − F (t; λ, β) = Γ(β,βλt)
Γ(β) , where Γ(·, ·) is the upper
incomplete gamma function.
The multinomial distribution is scaled by the parameter
β̂ , ξβ. Writing the likelihood with the scaled exponential
families (and dropping indicator variables) yields:
`(U|O, P, λ)


ln Γ(β) − ln Γ(β, βλsK t· )
∝ exp −β
β
+

K−1
X
k=0

ξ ln psk sk+1 + λsk tk − ln λsk tk

(3)


JUMP-Means: SVA for MJPs

+

K−1
X
k=0

β ln β − ln Γ(β) ln tk
−
+
β
β

!)
.

The modified likelihood is for a jump process which is
no longer Markov when β 6= 1. We also place a
Gam(αλ , αλ µλ ) prior on each λi and set αλ = ξλ β. It
can be shown (see the Supplementary Material for details)
that, when β → ∞, the MAP estimation problem becomes
 K−1
K−1
X
X
min ξ
ln psk sk+1 +
(λsk tk − ln λsk tk − 1)

U ,λ,P

k=0

k=0

+ 1[λsK t· ≥ 1](λsK t· − ln λsK t· − 1)

M
X
+ ξλ
(µλ λs − ln λs − 1) .

(4)

s=1

The optimization problem (4) is very natural and offers
far greater stability than maximum likelihood optimization.
As with maximum likelihood, the ln psk sk+1 terms penalize transitions with small probability. The term h(tk ) ,
λsk tk − ln λsk tk − 1 is convex and minimized when tk =
1/λsk , the expected value of the dwell time for state sk .
As tk → 0, h(tk ) approaches ∞, while for tk  1/λsk ,
h(tk ) grows approximately linearly. Thus, times very close
to zero are heavily penalized while times close to the expected dwell time are penalized very little. The term
1[λsK t· ≥ 1](λsK t· − ln λsK t· − 1) penalizes the time
t· spent in state sk so far in the same manner as a regular
dwell time when t· is greater than the expected value of
the dwell-time. However, when t· is less than the expected
value there is no cost, which is quite natural since the system may remain in state sk for longer than t· — i.e., there
should not be a large penalty for t· being less than its expected value. Finally, parameters ξλ and µλ have a very
natural interpretation (cf. (8) below): they correspond to a
priori having ξλ dwell times of length µλ for each state.

3.2. Hidden State MJP
For an HMJP, the likelihood of a valid trajectory is
!
L
Y
p(U | X , τ , P, λ) =
p(x` | sτ` )
`=1

×

K
Y

(5)

!
−λsk−1 tk−1

λsk−1 e

psk−1 sk

e

−λsK (T −t· )

.

k=1

Hence, the only difference between the directly observed
case and the HMJP is the addition of the observation likelihood terms. Because multinomial observations are commonly used in MJP applications, that is the case we consider here. Let N denote the number of possible observations and ρsn be the probability of observing x` = n when
sτ` = s. The observation likelihoods are scaled in the same
manner as the transition probabilities, but with β̂ = ζβ.
Thus, for the HMJP, we obtain:
min

U ,λ,P,ρ

 X
L
K−1
X
ln ρsτ` x` + ξ
ln psk sk+1
ζ
`=1

+

k=0

K−1
X
k=0

(λsk tk − ln λsk tk − 1)

(6)

+ 1[λsK t· ≥ 1](λsK t· − ln λsK t· − 1)

M
X
+ ξλ
(µλ λs − ln λs − 1) .
s=1

3.3. Algorithm
Optimizing the JUMP-means objectives in (4) and (6) is
non-trivial due to the fact that we do not know the number
of jumps in the MJP, and the combinatorial explosion in
the sequences with the number of jump points. The terms
involving the continuous variables tk (dwell times) present
an additional complexity.

Comparison to Maximum Likelihood MJP trajectories
estimated using maximum likelihood (MLE) are usually
trivial, with the system spending almost all its time in a
single state (with the smallest λ), with infinitesimal dwell
times for the other states. This poor behavior of MLE is due
to the fact that the mode of Exp(λ), which is favored by the
MLE, is 0, even though the mean is 1/λ.1 The SVA optimization, on the other hand, does give trajectories that are
representative of the true behavior because the SVA terms
of the form λt − ln(λt) − 1 are optimized at 1/λ (i.e., at the
mean of Exp(λ)). We demonstrate the superior behavior
of the SVA in the concrete example of estimating disease
progression in patients in Section 5.

We therefore resort to an alternating minimization procedure to optimize the JUMP-means objective function, similar in spirit to the one used in Roychowdhury et al. (2013).
In each iteration of the optimization process, we first use
a modified Viterbi algorithm to obtain the most likely state
sequence. Then, we use convex optimization to distribute
the jump points optimally with respect to the values from
λ for the current state sequence.

1
Note that placing priors on the rate parameters, as we do,
does not affect the degeneracy of the ML trajectory.

1. Initialize the state transition matrix P and rate vector λ
with uniform values.

Directly Observed MJP When optimizing (4), there may
be many sequences (O’s) available, representing distinct
realizations of the process. We use the following algorithm
to optimize (4):

JUMP-Means: SVA for MJPs

2. For every observation sequence O, instantiate the jump
points by adding one jump point between every pair of
observations, in addition to the start and end points.
3. For each O, use a modified Viterbi algorithm. to find
the best state sequence to optimize (4), while keeping
the jump points fixed. The modified algorithm includes
the dwell time penalty terms, which are dependent upon
the assignment of states to the time points.

gamma-exponential process (ΓEP). We denote the Moran
gamma process with base measure H and rate parameter
γ by ΓP(H, γ) (Kingman, 1993). The HΓEP generates a
state/dwell-time sequence s0 , t1 , s1 , t2 , s2 , t3 , s3 , . . . (with
s0 assumed known) according to (Saeedi & BouchardCôté, 2011):
µ0 ∼ ΓP(α0 H0 , γ0 ),
i.i.d.

µi | µ0 ∼ ΓP(µ0 , γ),

4. Optimize the dwell times tk with the state sequences of
the trajectories fixed.
5. Optimize P and λ with the other variables fixed. The
optimal values can be obtained in closed form. For example, if there is only a single observation sequence O
with corresponding inferred trajectory S, then
nmj
, m, j ∈ [M ]
pmj = PM
j=1 nmj
P
ξλ + k 1[sk = m]
P
λm =
,
ξλ µλ + k 1[sk = m]tk

(7)
(8)

where nmj denotes to the number of transitions from
state m to state j in S.

6. Repeat steps 3-5 until convergence.

Beam Search Variant We note that the optimization procedure just described is restrictive since the number of
jump points is fixed and the jump points are constrained
by the observation boundaries. To eliminate this, we also
tested a beam search variant of the algorithm to allow for
the creation and removal of jump points, but found it did
not have much impact in our experiments.
Hidden State MJP The algorithm to optimize the hidden
state MJP JUMP-means objective (6) is similar to that for
optimizing (4), but with three modifications. First, in place
of O, we have the indirect observations of the states X .
Second, observation likelihood terms containing ρ are included in the objective minimized by the Viterbi optimization (step 3). Finally, an additional update is performed in
step 5 for each of the observation distributions ρm :
P
1[sτ = m]1[x` = n]
ρmn = ` P `
(9)
` 1[sτ` = m]
for m ∈ [M ] and n ∈ [N ]. If each ρm , (ρm1 , . . . , ρmN )
is initialized to be uniform, then the algorithm converges to
a poor local minimum, so we add a small amount of random
noise to each uniform ρm .

4. Bayesian Nonparametric MJPs
We now consider the Bayesian nonparametric MJP (iMJP)
model. The iMJP is based on the hierarchical gammaexponential process (HΓEP), which is constructed from the

(10)
i = 1, 2, . . . ,

sk | {µi }∞
i=0 , Uk−1 ∼ µ̄sk−1 ,
tk | {µi }∞
i=0 , Uk−1

∼ Exp(kµsk−1 k),

(11)
(12)
(13)

where H0 is the base probability measure, α0 is a concentration parameter, Uk , (s0 , t1 , s1 , t2 , s2 , . . . , tk−1 , sk ),
µ̄i , µi /kµi k, and kµk denotes the total mass of the measure µ. As in the parametric case, we must replace the
exponential distribution in (13) with the scaled exponential distribution. After an appropriate scaling of the rest
of the hyperparameters, we obtain the hierarchical gammagamma process (HΓΓP). The definition and properties of
the HΓΓP are given in the Supplementary Material.
Let M denote the number of used states, Km the number of
transitions out of state m, and µij the mass on the j-th component of the measure µi . For 0 ≤ i ≤ M, 1 ≤ jP≤ M , let
M
π̄ij , µ̄ij and for 0 ≤ i ≤ M , let π̄i,M +1 , 1 − j=1 µ̄ij .
Let t∗m , (t∗m1 , . . . , t∗mKm ) be the waiting times followPKm ∗
ing state m and define t∗m· ,
j=1 tmj . In order to retain the effects of the hyperparameters in the asymptotics,
set α0 = exp(−ξ1 β) and γ0 = κ0 = ξ2 . It can then
be shown that (see the Supplementary Material for details),
when β → ∞, the iMJP MAP estimation problem becomes
min

K,UK ,π̄,ρ

ζ

L
X

ln ρsτ` x` + ξ

`=1

+ ξ1 M +

M
X
m=1

−

K
X

ln π̄sk−1 sk

k=1

ξ2 KL(π̄0 ||π̄m )

(14)

M n
X
PKm
m=1

o
∗
∗
ln
t
−
K
ln
([γ
+
t
]/K
)
.
m
m
m·
mj
j=1

Like its parametric counterpart, the Bayesian nonparametric cost function penalizes dwell durations very close to
zero via the ln t∗mj terms. In addition, there are penalties for the number of states and the state transitions. The
observation likelihood term in (14) favors the creation of
new states to minimize the JUMP-means objective, while
the state penalty ξ1 M and the non-linear penalty term
Km ln ([γ + t∗m· ]/Km ) counteracts the formation of a long
tail of states with very few data points. The γ hyperparameter introduces an additional, nonlinear cost for each additional state — if a state is occupied for Ω(γ) time, then the
γ term for that state does not have much effect on the cost.

JUMP-Means: SVA for MJPs
Table 1. Statistics and Mean observation reconstruction error for the various models on different datasets. Key: BL = Baseline; P = parametric; SVA = JUMP-means; NP = nonparametric; DO = directly observed; H = hidden; MS = multiple sclerosis data set; MIMIC = blood
pressure data set. *Best result obtained by running EM with various number of hidden states (up to 12).

Synthetic 1 (P-DO)
Synthetic 2 (P-H)
MS (P-DO)
MIMIC (NP-H)

Data Set
# Points Held Out
10,000
30 %
10,000
30 %
390
50 %
2,208
25 %

# States
10
5
3
-

The KL divergence terms between π̄0 and π̄m arise from
the hierarchical structure of the prior, biasing the transition
probabilities π̄m to be similar to the prior π̄0 .
4.1. Algorithm
For the iMJP case, we have the extra variables M and
{π̄m }M
m=0 to optimize. In addition, the number of variables
to optimize depends on the number of states in our model.
The major change in the algorithm from the parametric case
is that we must propose and then accept or reject the addition of new states. We propose the following algorithm for
optimizing the iMJP:
(1) Initialize ρ, π̄0 and π̄1 with uniform values and set the
number of states M = 1.
(2) For each observation sequence, apply the Viterbi algorithm and update the times using the new objective
function in (14), analogously to steps (3) and (4) in the
parametric algorithm.
(3) Perform MAP updates for ρ (as in (9)) and π̄:
π̄mj =
π̄0j ∝

ξ

ξnmj + ξ2 π̄0j
,
PM
j=1 nmj + ξ2 π̄0j

M
Y
m=1

1/M

π̄mj ,

j ∈ [M ].

m, j ∈ [M ]

(15)

(16)

(4) For every state pair m, m0 ∈ [M ], form a new state
M + 1 by considering all transitions from m to m0 and
reassigning all observations x` that were assigned to
m0 to the new state. Update π̄ and ρ to estimate the
overall objective function for every new set of M + 1
states formed in this way and accept the state set that
minimizes the objective. If no such set exists, do not
create a new state and revert back to the old π̄ and ρ.
(5) Repeat steps 2-4 until convergence.
Remark. If instead of multinomial observations we have
Gaussian observations, the parameter ρs is replaced with
the mean parameter µs . In this case, we update the mean
for each state using the data points assigned to the state,
similar to the procedure for k-means clustering (see, e.g.,
Jiang et al. (2012); Roychowdhury et al. (2013)).

BL
69.7
51.8
51.2
42.3

EM
40.2
42.9
26.2
25.7*

Mean Error (%)
MCMC SVA
41.9
41.2
74.6
46.5
48.1
25.4
24.3

PMCMC
30.9

5. Experiments
In this section we provide a quantitative analysis of the
JUMP-means algorithm and compare its performance on
synthetic and real datasets with standard inference methods
for MJPs. For evaluation, we consider multiple sequences
of discretely observed data and randomly hold out a subset
of the data. We report reconstruction error for performance
comparison.
5.1. Parametric Models
For the parametric models, we compare JUMP-means to
maximum likelihood estimation of the MJP parameters
learned by EM (Asger & Ledet, 2005), the MCMC method
proposed in Rao & Teh (2013) and a simple baseline where
we ignore the sequential structure of the data. We run three
sets of experiments (2 synthetic, 1 real) for our evaluation.
Synthetic 1: Directly Observed States For evaluating the
model on a directly observed process, we generate 100 different datasets randomly from various MJPs with 10 states.
To generate each dataset, we first generate the rows of
the transition probability matrix and transition rates independently from Dir(1) and Gam(1, 1), respectively. Next,
given the rates and transition probabilities for each dataset,
we sample 500 sequences of length 20. We hold out 30% of
the observations at random for testing reconstruction error.
We run JUMP-means by initializing the algorithm with a
uniform transition matrix P and set the rate vector λ to
be all ones. We run 300 iterations of the algorithm described in Section 3.3; each iteration is one scan through
all the sequences. We set the hyperparameters ξ, ξλ , and µλ
equal to 1, 1, and .5, respectively. For MCMC, we initialize
the jump points using the time points of the observations.
We place independent Dir(1) priors on P and independent
Gam(1, 1) priors on λ. We initialize EM with a uniform P
and an all-ones λ. We run both MCMC and EM for 300 iterations, then reconstruct observations using the Bayes estimator approximated from the 300 posterior samples. For
our baseline we use the most common observation in the
dataset as an estimate of the missing observations.
Table 1 gives the mean reconstruction error across sequences for the various methods. Note that JUMP-means
performs better than MCMC, and is almost on par with EM.

10

20 30
Iteration

40

50

80
MCMC
EM
JUMP-means

70
MCMC
EM
JUMP-means

60

Error (%)

MCMC
EM
JUMP-means

80
75
70
65
60
55
50
45
40
35

Error (%)

80
75
70
65
60
55
50
45
40
35

Error (%)

Error (%)

JUMP-Means: SVA for MJPs

50
40
30

10

20 30
Iteration

40

50

20

10

20 30
Iteration

40

50

60
55
50
45
40
35
30
25
20
0

PMCMC
JUMP-means

10

20 30
Iteration

40

50

Synthetic 2: Hidden States For the hidden state case, we
generate 100 different datasets for MJPs with 5 hidden and
5 observed states, with varying parameters as above. In
each dataset there are 500 sequences of length 20. In addition to parameters in the directly observed case, we generate observation likelihood terms for each state from Dir(1).
We initialize the transition probabilities and the rate vectors
for JUMP-means, MCMC and EM in a fashion similar to
the directly observed case. For the observation likelihood
ρ, we use Dir(1) as a prior for MCMC, uniform distributions for EM initialization and a uniform probability matrix
with a small amount of random noise for JUMP-means initialization. We set ξ, ξλ , µλ as before and ξ to 1.
We run each algorithm for 300 iterations. For JUMPmeans, we use the hidden state MJP algorithm described
in Section 3.3. Table 1 and Fig. 2(b) again demonstrate
that JUMP-means outperforms MCMC by a large margin
and performs comparably to EM. The poor performance
of MCMC is due to slow mixing over the parameters and
state trajectories. The slow mixing is a result of the coupling between the latent states and the observations, which
is induced by the observation likelihood.
Disease Progression in Multiple Sclerosis (MS) Estimating disease progression and change points in patients with
Multiple Sclerosis (MS) is an active research area (see,
e.g., Mandel (2010)). We can cast the progression of the
disease in a single patient as an MJP, with different states
representing the various stages of the disease. Obtaining
the most-likely trajectory for this MJP can aid in understanding the disease progression and enable better care.
For our experiments, we use a real-world dataset collected
from a phase III clinical trial of a drug for MS. This dataset

3

3

2

2

1

1

0

0

1

Blood Pressure (Systolic)

Fig. 2(a) shows the average error across all the datasets for
each method versus number of iterations. In terms of CPU
time, each iteration of JUMP-means (Java), EM (Java), and
MCMC (Python) takes 0.3, 1.61 and 42 seconds, respectively. We also ran experiments with the beam search variant described in Section 3.3; however, we did not obtain
any significant improvement in results.

EDSS

(a)
(b)
(c)
(d)
Figure 2. Mean error vs iterations for (a) Synthetic 1; (b) Synthetic 2; (c) MS; and (d) MIMIC datasets. In each case the JUMP-means
algorithms have better or comparable performance to other standard methods of inference in MJPs. Mean error vs CPU runtime plots
can be found in the Supplementary Material.

0 20 40 60 80 100 120 140
Weeks (JUMP-means)

1

0 20 40 60 80 100 120 140
Weeks (ML)

160
150
140
130
120
110
0

20

40
60
Time (x 300s)

80

100

Figure 3. Top: Latent trajectories inferred by JUMP-means and
ML estimate for a patient in the MS dataset. Bottom: Latent trajectory inferred by JUMP-means for a patient in MIMIC dataset.

tracks the progression of the disease for 72 different patients over three years. We randomly hold out 50% of the
observations and evaluate on the observation reconstruction
task. The observations are values of a disability measure
known as EDSS, recorded at different time points. Initialization and hyperparameters are the same as Synthetic 1.
Table 1 shows that JUMP-means significantly outperforms
MCMC, achieving almost a 50% relative reduction in reconstruction error. JUMP-means again achieves comparable results with EM. Fig. 3 (top panel) provides an example
of the latent trajectories from JUMP-means and maximum
likelihood estimate for a single patient. The MLE trajectory
includes two infinitesimal dwell times, which do not reflect
realistic behavior of the system (since we do not expect a
patient to be in a disease state for an infinitesimal amount
of time). On the other hand, the trajectory produced by
JUMP-means takes into account the dwell times of the various stages of the disease and provides a more reasonable
picture of its progression.

70

70

50

50

30

30

10

10

0.25

0.31

0.37

0.43

Error

0.49

0.55

0.24

105

0.27

0.30

0.33

Error

0.36

0.32
0.30

104

0.28

3

0.26

102

0.24
Error
Total time 0.22

10

0.39

Figure 4. Histograms of error reconstruction for runs with different hyperparameter settings for (a) MS (P-DO, 48 settings), and
(b) MIMIC (NPB-H, 1125 settings) datasets.

5.2. Nonparametric Model
Vital Signs Monitoring (MIMIC) We now consider a version of the problem of understanding physiological signals discussed in the introduction. We use data from the
MIMIC database (Goldberger et al., 2000; Moody & Mark,
1996), which contains recordings of several vital parameters of ICU patients. Specifically, we consider blood pressure readings of 69 ICU patients collected over a 24-hour
period and sub-sample observation sequences of length 32
for each patient, keeping the start and end times fixed.2 For
testing, we randomly hold out ∼25% of the observations.
To initialize JUMP-means, we choose uniform matrices for
ρ, π̄0 and π̄1 and set M = 1. The hyperparameters γ and
ξ1 are set to 5, while ζ, ξ, and ξ2 are set to 0.005. Using a Gaussian likelihood model for the observations, we
run our model for 50 iterations. We compare with particle MCMC (PMCMC) (Andrieu et al., 2010) and EM.
PMCMC is a state-of-the-art inference method for iMJPs
(Saeedi & Bouchard-Côté, 2011), which we run for 300
iterations with 100 particles. For PMCMC, we first categorize the readings into the standard four categories for blood
pressure provided by NIH3 . We run EM with a number of
hidden states from 1 to 12 and report the best performance
among all the results. For initializing the EM, we use the
same setting as the Synthetic 2 case.
For evaluation, we consider the time point of a test observation and categorize the mean of the latent state at this time
point (using the same categories obtained above) to compare against the actual category. Table 1 shows that JUMPmeans significantly outperforms PMCMC and obtains a
21% relative reduction in average error rate. Fig. 2(c)
plots the error against iterations of both algorithms. In
terms of CPU time, each iteration of JUMP-means (Java)
and PMCMC (Java) takes 0.17 and 1.95 seconds, respectively. Compared to EM’s error rate of 25.7%, JUMPmeans reaches a rate of 24.3% without the need to separately train for different number of states. The second-best
2
We use a small dataset for testing since PMCMC cannot easily scale to larger datasets.
3
http://www.nhlbi.nih.gov/health/
health-topics/topics/hbp

101
103

104

105
106
# of data points

Error (%)

90

Time (sec)

Percentage (%)

JUMP-Means: SVA for MJPs
90

0.20

107

Figure 5. Runtime and error of nonparametric JUMP-means algorithm with increasing synthetic data size. The runtime scales
linearly with data size (dashed black line).

result for the EM had an error of 45%, which shows the
importance of model selection when using EM.
Fig. 3 (bottom) provides an example of the latent trajectory
inferred by JUMP-means. The observations are uniquely
colored by the latent state they are assigned. We note that
the model captures different levels of blood pressure readings and provides a non-degenerate latent trajectory.
Hyperparameters A well-known problem when applying
SVA methods is that there are a number of hyperparameters to tune. In our objective functions, some of these hyperparameters (γ, µλ , and ξλ ) have natural interpretations
so prior knowledge and common sense can be used to set
them, but others do not. Fig. 4 shows histograms over the
errors we obtain for runs of JUMP-means on the MS and
MIMIC datasets with different settings. We can see that
a significant fraction of the runs converge to the minimum
error, while some settings — in particular when the hyperparameters were of different orders of magnitude — led to
larger errors. Hence, the sensitivity study indicates the robustness of JUMP-means to the choice of hyperparameters.
Scaling Fig. 5 shows the total runtime and reconstruction
error of the non-parametric JUMP-means algorithm on increasingly large amounts of synthetic data. The algorithm
is able to handle up to a million data points with the runtime scaling linearly with data size. Furthermore, the error
rate decreases significantly as the amount of data increases.
See the Supplementary Material for further details.

6. Conclusion
We have presented JUMP-means, a new approach to inference in MJPs using small-variance asymptotics. We derived novel objective functions for parametric and Bayesian
nonparametric models and proposed efficient algorithms to
optimize them. Our experiments demonstrate that JUMPmeans can be used to obtain high-quality non-degenerate
estimates of the latent trajectories. JUMP-means offers attractive speed-accuracy tradeoffs for both parametric and
nonparametric problems, and achieved state-of-the-art reconstruction accuracy on nonparametric problems.

JUMP-Means: SVA for MJPs

Acknowledgments
Thanks to Monir Hajiaghayi, Matthew Johnson, and Tejas Kulkarni for helpful comments and discussions. JHH
was supported by the U.S. Government under FA9550-11C-0028 and awarded by the DoD, Air Force Office of Scientific Research, National Defense Science and Engineering Graduate (NDSEG) Fellowship, 32 CFR 168a.

References
Andrieu, C., Doucet, A., and Holenstein, R. Particle
Markov chain Monte Carlo methods. Journal of the
Royal Statistical Society: Series B (Statistical Methodology), 72(3):269–342, 2010.
Asger, H. and Ledet, J. J. Statistical inference in evolutionary models of dna sequences via the em algorithm.
Statistical Applications in Genetics and Molecular Biology, 4(1):1–22, 2005.
Bladt, M. and Sørensen, M. Statistical inference for discretely observed markov jump processes. Journal of the
Royal Statistical Society: Series B (Statistical Methodology), 67(3):395–410, 2005.
Bladt, M. and Sørensen, M. Efficient estimation of transition rates between credit ratings from observations at
discrete time points. Quantitative Finance, 9(2):147–
160, 2009.
Broderick, T., Kulis, B., and Jordan, M. I. MAD-Bayes:
MAP-based Asymptotic Derivations from Bayes. In International Conference on Machine Learning, 2013.
Goldberger, A. L., Amaral, L. A. N., Glass, L., Hausdorff,
J. M., Ivanov, P. C., Mark, R. G., Mietus, J. E., Moody,
G. B., Peng, C.-K., and Stanley, H. E. PhysioBank,
PhysioToolkit, and PhysioNet: Components of a new research resource for complex physiologic signals. Circulation, 101(23):e215–e220, 2000.
Hajiaghayi, M., Kirkpatrick, B., Wang, L., and BouchardCôté, A. Efficient Continuous-Time Markov Chain Estimation. In International Conference on Machine Learning, 2014.
Jiang, K., Kulis, B., and Jordan, M. I. Small-variance
asymptotics for exponential family dirichlet process
mixture models. In NIPS, pp. 3167–3175, 2012.
Kingman, J. F. C. Poisson Processes. Oxford Studies in
Probability. Oxford University Press, 1993.
Kulis, B. and Jordan, M. I. Revisiting k-means: New Algorithms via Bayesian Nonparametrics. In International
Conference on Machine Learning, 2012.

Lange, J. Latent Continuous Time Markov Chains for
Partially-Observed Multistate Disease Processes. PhD
thesis, 2014.
Mandel, M. Estimating disease progression using panel
data. Biostatistics, 11(2):304–316, 2010.
Moody, G. and Mark, R. A database to support development and evaluation of intelligent intensive care monitoring. In Computers in Cardiology, 1996, pp. 657–660,
Sept 1996.
Perkins, T. J.
Maximum likelihood trajectories for
continuous-time markov chains. In NIPS, pp. 1437–
1445, 2009.
Rao, V. and Teh, Y. W. Fast MCMC sampling for Markov
jump processes and extensions. The Journal of Machine
Learning Research, 14(1):3295–3320, 2013.
Roychowdhury, A., Jiang, K., and Kulis, B. Small-Variance
Asymptotics for Hidden Markov Models. In Advances in
Neural Information Processing Systems, pp. 2103–2111,
2013.
Saeedi, A. and Bouchard-Côté, A. Priors over recurrent
continuous time processes. In NIPS, volume 24, pp.
2052–2060, 2011.

