Stochastic Dual Coordinate Ascent
with Alternating Direction Method of Multipliers

Taiji Suzuki
S - TAIJI @ IS . TITECH . AC . JP
Department of Mathematical and Computing Sciences, Tokyo Institute of Technology, Tokyo 152-8552, JAPAN

Abstract
We propose a new stochastic dual coordinate ascent technique that can be applied to a wide range
of regularized learning problems. Our method is
based on alternating direction method of multipliers (ADMM) to deal with complex regularization functions such as structured regularizations.
Although the original ADMM is a batch method,
the proposed method offers a stochastic update
rule where each iteration requires only one or few
sample observations. Moreover, our method can
naturally afford mini-batch update and it gives
speed up of convergence. We show that, under
mild assumptions, our method converges exponentially. The numerical experiments show that
our method actually performs efficiently.

1. Introduction
This paper proposes a new stochastic optimization method
that shows exponential convergence and can be applied to
wide range of regularization functions using the techniques
of stochastic dual coordinate ascent with alternating direction method of multipliers. Recently, it is getting more and
more important to develop an efficient optimization method
which can handle large amount of samples. One of the
most successful approaches is a stochastic optimization approach. Indeed, a lot of stochastic methods have been proposed to deal with large amount of samples. Among them,
the (online) stochastic gradient method is the most basic
and successful one. This can be naturally applied to the
regularized learning frame-work. Such a method is called
several different names including online proximal gradient
descent, forward-backward splitting and online mirror descent (Duchi and Singer, 2009). Basically, these methods
are intended to process sequentially coming data. They
update the parameter using one new observation and disProceedings of the 31 st International Conference on Machine
Learning, Beijing, China, 2014. JMLR: W&CP volume 32. Copyright 2014 by the author(s).

card the observed sample. Therefore, they don‚Äôt need large
memory space to store the whole observed
‚àö data. The convergence rate of those methods is O(1/ T ) for general
settings and O(1/T ) for strongly convex losses, which are
minimax optimal (Nemirovskii and Yudin, 1983).
On the other hand, recently it was shown that, if it is allowed to reuse the observed data several times, it is possible to develop a stochastic method with exponential convergence rate for a strongly convex objective (Le Roux et al.,
2013; Shalev-Shwartz and Zhang, 2013c;a). These methods are still stochastic in a sense that one sample or small
mini-batch is randomly picked up to be used for each update. The main difference from the stochastic gradient
method is that these methods are intended to process data
with a fixed number of training samples. stochastic average gradient (SAG) method (Le Roux et al., 2013) utilizes
an averaged gradient to show an exponential convergence.
stochastic dual coordinate ascent (SDCA) method solves
the dual problem using a stochastic coordinate ascent technique (Shalev-Shwartz and Zhang, 2013c;a). These methods have favorable properties of both online-stochastic approach and batch approach. That is, they show fast decrease of the objective function in the early stage of the
optimization as online-stochastic approaches, and shows
exponential convergence after the ‚Äúburn in‚Äù time as batch
approaches. However, these methods have some drawbacks. SAG needs to maintain all gradients computed on
each training sample in memory which amount to dimension times sample size. SDCA method can be applied only
to a simple regularization function for which the dual function is easily computed, thus it is hard to apply the method
to a complex regularization function such as structured regularization.
In this paper, we propose stochastic dual coordinate ascent method for alternating direction method of multipliers (SDCA-ADMM). Our method is similar to SDCA, but
inherits a favorable property of ADMM. By combining
SDCA and ADMM, our method can be applied to a wide
range of regularized learning problems. ADMM is an effective optimization method to solve a composite optimization problem described as minx f (x) + g(y) s.t. Ax +

Stochastic Dual Coordinate Ascent with ADMM

By = 0 (Gabay and Mercier, 1976; Boyd et al., 2010;
Qin and Goldfarb, 2012). This formulation is quite flexible and fit wide range of applications such as structured
regularization, dictionary learning, convex tensor decomposition and so on (Qin and Goldfarb, 2012; Jacob et al.,
2009; Tomioka et al., 2011; Rakotomamonjy, 2013). However, ADMM is a batch optimization method. Our approach transforms ADMM to a stochastic one by utilizing stochastic coordinate ascent technique. Our method,
SDCA-ADMM, does not require large amount of memory because it observes only one or few samples for each
iteration. SDCA-ADMM can be naturally adapted to a
sub-batch situation where a block of few samples is utilized for each iteration. Moreover, it is shown that our
method shows exponential convergence for risk functions
with some strong convexity and smoothness property. The
convergence rate is affected by the size of sub-batch. If
the samples are not strongly correlated, sub-batch gives a
better convergence rate than one-sample update.

The purpose of this paper is to give an efficient stochastic
optimization method to solve this problem (2). For this purpose, we employ the dual formulation. Using the Fenchel‚Äôs
duality theorem, we have the following dual formulation.
Lemma 1.
n

1X
fi (zi‚ä§ w) + œà(B ‚ä§ w)
w‚ààR n
i=1
)
( n

1X ‚àó
‚àó y
| Zx+By = 0 , (3)
f (xi )+œà
=‚àí minn
x‚ààR
n i=1 i
n
d
minp

y‚ààR

where fi‚àó and œà ‚àó are the convex conjugates of fi
and œà respectively (Rockafellar, 1970)1 , and Z =
[z1 , z2 , . . . , zn ] ‚àà Rp√ón . Moreover w‚àó , x‚àó and y ‚àó are optimal solutions of both sides if and only if
zi‚ä§ w‚àó ‚àà ‚àÇfi‚àó (x‚àói ),

1 ‚àó
y ‚àà ‚àÇœà(u)|u=B ‚ä§ w‚àó ,
n

Zx‚àó + By ‚àó = 0.

2. Structured Regularization and its Dual
Formulation
In this section, we give the problem formulation of structured regularization and its dual formulation. The standard
regularized risk minimization is described as follows:
n

minp

w‚ààR

1X
fi (zi‚ä§ w) + œàÃÉ(w),
n i=1

(1)

where z1 , z2 , . . . , zn are vectors in Rp , w is the weight vector that we want to learn, fi is a loss function for the ith sample, and œàÃÉ is the regularization function which is
used to avoid over-fitting. For example, the loss function fi
can be taken as a classification surrogate loss fi (zi‚ä§ w) =
‚Ñì(yi , zi‚ä§ w) where yi is the training label of the i-th sample. With regard to œàÃÉ, we are interested in a sparsity inducing regularization, e.g., ‚Ñì1 -regularization, group lasso
regularization, trace-norm regularization, and so on. Our
motivation in this paper is to deal with a ‚Äúcomplex‚Äù regularization œàÃÉ where it is not easy to directly minimize the
regularization function (more precisely the proximal operation determined by œàÃÉ is not easily computed, see Eq. (5)).
This kind of regularization appears in, for example, structured sparsity such as overlapped group lasso and graph
regularization (Jacob et al., 2009; Signoretto et al., 2010).
In many cases, such a ‚Äúcomplex‚Äù regularization function
can be decomposed into a ‚Äúsimple‚Äù regularization œà and a
linear transformation B, that is, œàÃÉ(w) = œà(B ‚ä§ w) where
B ‚àà Rp√ód . Using this formulation, the optimization problem (Eq. (1)) is equivalent to
n

minp

w‚ààR

1X
fi (zi‚ä§ w) + œà(B ‚ä§ w).
n i=1

(2)

Proof. By Fenchel‚Äôs duality theorem (Corollary 31.2.1 of
Rockafellar (1970)), we have that
Pn
minw‚ààRp n1 i=1 fi (zi‚ä§ w) + œàÃÉ(w)
n P
o
n
= ‚àí minx‚ààRn n1 i=1 fi‚àó (xi ) + œàÃÉ ‚àó (‚àíZx/n) . (4)

Moreover x‚àó , w‚àó are optimal in each side if and only
if zi‚ä§ w‚àó ‚àà ‚àÇfi‚àó (x‚àói ) and ‚àíZx‚àó /n ‚àà ‚àÇ œàÃÉ(w‚àó ) =
B‚àÇœà(u‚àó )|u=B ‚ä§ w‚àó (Corollary 31.3 of Rockafellar (1970)).
Now, Theorem 16.3 of Rockafellar (1970) gives that
œàÃÉ ‚àó (u) = (œà ‚ó¶ B ‚ä§ )‚àó (u) = inf{œà ‚àó (y) | By = u}.

Thus œàÃÉ ‚àó (‚àíZx/n) = inf{œà ‚àó (y/n) | By = ‚àíZx},
and substituting this into the RHS of Eq. (4) we obtain Eq. (3). Now, y ‚àó satisfying Zx‚àó + By ‚àó = 0
is the optimal solution if and only if œà ‚àó (y ‚àó /n) =
œàÃÉ ‚àó (‚àíZx‚àó /n) for the optimal x‚àó . Thus, if (w‚àó , x‚àó , y ‚àó )
is optimal, then we have ‚àíZx‚àó /n ‚àà ‚àÇ œàÃÉ(w‚àó ) and thus
œà ‚àó (y ‚àó /n) = œàÃÉ ‚àó (‚àíZx‚àó /n) = hw‚àó , ‚àíZx‚àó /ni ‚àí œàÃÉ(w‚àó ) =
hB ‚ä§ w‚àó , y ‚àó /ni ‚àí œà(B ‚ä§ w‚àó ) which implies y ‚àó /n ‚àà
‚àÇœà(u)|u=B ‚ä§ w‚àó . Contrary, if y ‚àó /n ‚àà ‚àÇœà(u)|u=B ‚ä§ w‚àó , then
it is obvious that ‚àíZx‚àó /n ‚àà ‚àÇ œàÃÉ(w‚àó ) because Zx‚àó +
By ‚àó = 0. Therefore, we obtain the optimality conditions.
The dual problem is a composite objective function optimization with a linear constraint Zx + By = 0. In the next
section, we give an efficient stochastic method to solve this
dual problem. A nice property of the dual formulation is
that, in many machine learning applications, the dual loss
1
The convex conjugate function f ‚àó of f is defined by
f ‚àó (y) := supx {x‚ä§ y ‚àí f (x)}.

Stochastic Dual Coordinate Ascent with ADMM

function fi‚àó becomes strongly convex. For example, for the
logistic loss fi (x) = log(1+exp(‚àíyi x)), the dual function
is fi‚àó (‚àíu) = yi u log(yi u) + (1 ‚àí yi u) log(1 ‚àí yi u) (yi u ‚àà
[0, 1]) and its modulus of strong convexity is much better
than the primal one. More importantly, each sample (zi , yi )
directly affects only each coordinate xi of dual variable. In
other words, if xi is fixed the i-th sample (zi , yi ) has no
influence to the objective value. This enables us to utilize
the stochastic coordinate ascent technique in the dual problem because update of single coordinate xi requires only
the information of the i-th sample (zi , yi ).
Finally, we give the precise notion of the ‚Äúcomplex‚Äù
and ‚Äúsimple‚Äù regularizations. This notion is defined by
the computational complexity of proximal operation corresponding to the regularization function (Rockafellar,
1970). The proximal operation corresponding to a convex
function œà is defined by


1
2
kq ‚àí uk + œà(u) .
(5)
prox(q|œà) := arg min
2
u
For example, the proximal operation corresponding to
‚Ñì1 -regularization œà(w) = kwk‚Ñì1 is easily computed as
prox(q|œà) = (sign(wi ) max{|wi | ‚àí 1, 0})i which is the
so-called soft-thresholding operation. More generally, the
proximal operation for group lasso regularization with
non-overlapped groups can also be analytically computed.
On the other hand, for overlapped group regularization,
the proximal operation is no longer analytically obtained.
However, by choosing B appropriately, we can split the
overlap and obtain œà for which the proximal operation is
easily computed (see Section 6 for concrete examples).

3. Proposed Method: Stochastic Dual
Coordinate Ascent with ADMM
In this section, we present our proposal, stochastic dual coordinate ascent type ADMM. For‚àöa positive semidefinite
matrix S, we denote by kxkS := x‚ä§ Sx. Zi denotes the
i-th column of Z, which is zi , and Z\i is a matrix obtained
by subtracting i-th column from Z. Similarly, for a vector
x, x\i is a vector obtained by subtracting i-th component
from x.
3.1. One Sample Update of SDCA for ADMM
The basic update rule of our proposed method in the tth step is given as follows: Each update step, choose
i ‚àà {1, . . . , n} uniformly at random, and update as
n
y (t)‚Üê arg min nœà ‚àó (y/n) ‚àí hw(t‚àí1), Zx(t‚àí1) +Byi
y

(t)

o
œÅ
1
+ kZx(t‚àí1) + Byk2 + ky ‚àí y (t‚àí1) k2Q , (6a)
2
2
n

xi ‚Üê arg min fi‚àó (xi ) ‚àí hw(t‚àí1) , Zi xi + By (t) i
xi

œÅ
(t‚àí1)
+ kZi xi + Z\i x\i
+ By (t) k2
2
o
1
(t‚àí1) 2
kGii ,
+ kxi ‚àí xi
2
w(t)‚Üêw(t‚àí1) ‚àí Œ≥œÅ{n(Zx(t) + By (t) )
‚àí (n ‚àí 1)(Zx(t‚àí1) + By (t‚àí1) )},

(6b)

(6c)

where w(t) ‚àà Rp is the primal variable at the t-th step,
Q and G are arbitrary positive semidefinite matrices, and
Œ≥, œÅ > 0 are parameters we give beforehand.
The optimization procedure looks a bit complicated, To
simplify the procedure, we set Q as
Q = œÅ(Œ∑B Id ‚àí B ‚ä§ B)

(7)

where Œ∑B are chosen so that Œ∑B Id ‚âª B ‚ä§ B. Then, by carrying out simple calculations and denoting Œ∑Z,i = Gii /œÅ +
kzi k2 , the update rule of x(t) and y (t) is rewritten as

B‚ä§
y (t)‚Üêprox y (t‚àí1) +
{w(t‚àí1)
œÅŒ∑B

 nœà ‚àó (¬∑/n) 

,
‚àí œÅ(Zx(t‚àí1) + By (t‚àí1) )}
œÅŒ∑B

Z‚ä§
(t)
(t‚àí1)
xi ‚Üêprox xi
+ i {w(t‚àí1)
œÅŒ∑Z,i
 f‚àó 

.
‚àí œÅ(Zx(t‚àí1) + By (t) )}  i
œÅŒ∑Z,i

(8a)

(8b)

Note that the update (8b) of x(t) is just a one dimensional
optimization, thus it is quite easily computed. Moreover,
for some loss functions such as the smoothed hinge loss
used in Section 6, we have an analytic form of the update.
The update rule (8a) of y (t) can be rewritten by the proximal operation corresponding to the primal function œà while
the rule (8a) is given by that corresponding to the dual function œà ‚àó . Indeed, there is a clear relation between primal and
dual (Theorem 31.5 of Rockafellar (1970)):
prox(q|œà) + prox(q|œà ‚àó ) = q.
‚ä§

B
Using this, for q (t) = y (t‚àí1) + œÅŒ∑
{w(t‚àí1) ‚àí œÅ(Zx(t‚àí1) +
B
(t‚àí1)
By
)}, we have that

y (t) ‚Üê q (t) ‚àí prox(q (t) |nœà(œÅŒ∑B ¬∑ )/(œÅŒ∑B )),

(9)

because (cf (¬∑))‚àó (y) = cf ‚àó (y/c) for a convex function f
and c > 0. This is efficiently computed because we assumed the proximal operation corresponding to œà can be
efficiently computed.
During the update, we need Zx(t‚àí1) which seems to require O(n) computation at the first glance. However, it can
(t)
be incrementally updated as Zx(t) = Zx(t‚àí1) + Zi (xi ‚àí

Stochastic Dual Coordinate Ascent with ADMM
(t‚àí1)

xi
). Thus we don‚Äôt need to load all the samples to compute Zx(t‚àí1) at each iteration.
In the above, the update rule of our algorithm is based on
one sample observation. Next, we give a mini-batch extension of the algorithm where more than one samples could
be used for each iteration.
3.2. Mini-Batch Extension
Here, we generalize our method to mini-batch situation
where, at each iteration, we observe a small number of samples {(xi1 , yi1 ), . . . , (xik , yik )} instead of one sample observation. At each iteration, we randomly choose an index
set I ‚äÜ {1, . . . , n} so that each index i is included in I with
probability 1/K; P (i ‚àà I) = 1/K for all i = 1, . . . , n. To
do so, we suggest the following procedure. We split the index set {1, . . . , n} into K groups (I1 , I2 , . . . , IK ) beforehand, and then pick up uniformly k ‚àà {1, . . . , K} and set
I = Ik for each iteration. Each sub-batch Ik can have different cardinality from others, but the probability P (i ‚àà I)
should be uniform for all i = 1, . . . , n. The update rule
using sub-batch is given as follows: Update y (t) as before
(6a), and update x(t) and w(t) by
nX
(t)
xI ‚Üê arg min
fi‚àó (xi ) ‚àí hw(t‚àí1) , ZI xI + By (t) i
xI

i‚ààI

o
œÅ
1
(t‚àí1)
(t‚àí1) 2
+ kZI xI +Z\I x\I +By (t) k2 + kxI ‚àíxI
kGI,I ,
2
2
(10a)

where xI is a vector consisting of components with indexes
i ‚àà I, xI = (xi )i‚ààI , and ZI is a sub-matrix of Z consisting
of columns P
with indexes i ‚àà I, ZI = [Zi1 , . . . , Zi|I| ]. Note
that, since i‚ààI fi‚àó (xi ) is sum of single variable convex
functions fi‚àó (xi ), the proximal operation in Eq. (12) can be
split into the proximal operation with respect to each single
variable xi . This is advantageous for not only the simpleness of the computation but also parallel computation. That
(t‚àí1)
ZI‚ä§
{w(t‚àí1) ‚àí œÅ(Zx(t‚àí1) + By (t) )},
is, for pI = xI
+ œÅŒ∑Z,I
(t)

f‚àó

i
)
the update rule (12) is reduced to xi ‚Üê prox(pi | œÅŒ∑Z,I
for each i ‚àà I, which is easily parallelizable. In summary,
our proposed algorithm is given in Algorithm 1.

Algorithm 1 SDCA-ADMM
Input: œÅ, Œ∑ > 0
Initialize x0 = 0, y0 = 0, w0 = 0 and {I1 , . . . , IK }.
for t = 1 to T do
Choose k ‚àà {1, . . . , K} uniformly at random, set I =
Ik , and observe the training samples {(xi , yi )}i‚ààI .
B‚ä§
Set q (t)= y (t‚àí1)+ œÅŒ∑
{w(t‚àí1)‚àíœÅ(Zx(t‚àí1)+By (t‚àí1) )}.
B
(t)
(t)
(t)
Update y ‚Üê q ‚àí prox(q
|nœà(œÅŒ∑B ¬∑ )/(œÅŒ∑B ))

(t)

Update xI

(t‚àí1)

‚Üê prox xI
+
P
‚àó
f

i‚ààI i
œÅ(Zx(t‚àí1) + By (t) )}  œÅŒ∑
.
Z,I

ZI‚ä§
(t‚àí1)
œÅŒ∑Z,I {w

‚àí

Update w(t) ‚Üê w(t‚àí1) ‚àíŒ≥œÅ{n(Zx(t) +By (t) )‚àí(n‚àí
n/K)(Zx(t‚àí1) + By (t‚àí1) )}.
end for
Output: w(T ) .

w(t) ‚Üê w(t‚àí1) ‚àí Œ≥œÅ{n(Zx(t) + By (t) )

‚àí (n ‚àí n/K)(Zx(t‚àí1) + By (t‚àí1) )}.

(10b)
(t)

Using Q given in Eq. (7), the update rule of y can be
replaced by Eq. (9) as in one-sample update situation. The
update rule of x(t) can also be simplified by choosing G appropriately. Because sub-batches have no overlap between
each other, we can construct a positive semi-definite matrix
G such that the block-diagonal element GI,I has the form
GI,I = œÅ(Œ∑Z,I I|I| ‚àí ZI‚ä§ ZI )

(11)

where Œ∑Z,I is a positive real satisfying Œ∑Z,I ‚â• kZI‚ä§ ZI k.
The reason why we split the index sets into K sets is to
construct this kind of G which ‚Äúdiagonalizes‚Äù the quadratic
function in (10a). The choice of I and G could be replaced with another one for which we could compute the
update efficiently, as long as P (i ‚àà I) is uniform for all
i = 1, . . . , n. Using G given in (11), the update rule (10a)
of x(t) is rewritten as

Z‚ä§
(t)
(t‚àí1)
xI ‚Üê prox xI
+ I {w(t‚àí1)
œÅŒ∑Z,I
P
‚àó
 i‚ààI fi
(t‚àí1)
(t)
, (12)
‚àí œÅ(Zx
+ By )} 
œÅŒ∑Z,I

Finally, we would like to highlight the connection between
our method and the original batch ADMM (Hestenes,
1969; Powell, 1969; Rockafellar, 1976). The batch ADMM
utilizes the following update rule
y
n
y (t) ‚Üê arg min nœà ‚àó
‚àí hw(t‚àí1) , Zx(t‚àí1) + Byi
n
y
o
œÅ
+ kZx(t‚àí1) + Byk2 ,
(13a)
2

P
n
(t‚àí1)
‚àó
, Zx + By (t) i
x(t) ‚Üê arg min
i=1 fi (xi ) ‚àí hw
x

w(t)

	
œÅ
+ kZx + By (t) k2 ,
2
‚Üêw(t‚àí1) ‚àí Œ≥œÅ(Zx(t) + By (t) ).

(13b)
(13c)

One can see that the update rule of our algorithm is reduced
to that of the batch ADMM (13) if we set K = 1 except the
term related to G and Q (the terms 21 k ¬∑ k2Q and 21 k ¬∑ k2GI,I ).
These terms related to G and Q are used also in batch situation to eliminate cross terms in BB ‚ä§ and ZZ ‚ä§ . This
technique is called linearization. The linearization technique makes the update rule simple and parallelizable, and
in some situations makes it possible to obtain an analytic
form of the update.

Stochastic Dual Coordinate Ascent with ADMM

4. Linear Convergence of SDCA-ADMM
In this section, the convergence rate of our proposed algorithm is given. Indeed, the convergence rate is exponential
(R-linear). To show the convergence rate, we assume some
conditions. First, we assume that there exits an unique optimal solution w‚àó and B ‚ä§ is injective (on the other hand,
B is not necessarily injective). Moreover, we assume the
uniqueness of the dual solution x‚àó , but don‚Äôt assume the
uniqueness of y ‚àó . We denote by the set of dual optimum of
y as Y ‚àó and assume that Y ‚àó is compact. Then, by Lemma
1, we have that
zi‚ä§ w‚àó ‚àà ‚àÇfi‚àó (x‚àói ), y ‚àó /n ‚àà ‚àÇœà(u)|u=B ‚ä§ w‚àó .

(14)

By the convex duality arguments, this implies that x‚àói ‚àà
‚àÇfi (u)|u=zi‚ä§ w‚àó , B ‚ä§ w‚àó ‚àà ‚àÇœà ‚àó (u)|u=y‚àó /n .
Moreover, we suppose that each (dual) loss function fi is
locally v-strongly convex and œà, h-smooth around the optimal solution and œà ‚àó is also locally strongly convex in a
weak sense as follows.
Assumption 1. There exits v > 0 such that, ‚àÄxi ‚àà R,
fi‚àó (xi ) ‚àí fi‚àó (x‚àói ) ‚â• hzi‚ä§ w‚àó , xi ‚àí x‚àói i +

vkxi ‚àí x‚àói k2
.
2

There exit h > 0 and vœà > 0 such that, for all y, u and
y ‚àó ‚àà Y ‚àó , there exists yb‚àó ‚àà Y ‚àó (depending on y) and we
have
œà ‚àó (y/n) ‚àí œà ‚àó (b
y ‚àó /n) ‚â• hB ‚ä§ w‚àó , y/n ‚àí yb‚àó /ni
v
+ 2œà kPKer(B) (y/n ‚àí yb‚àó /n)k2 ,
‚ä§

‚àó

‚àó

‚ä§

œà(u) ‚àí œà(B w ) ‚â• hy /n, u ‚àí B w i
+ h2 ku ‚àí B ‚ä§ w‚àó k2 ,

(15)

‚àó

(16)

where PKer(B) is the projection matrix to the kernel of B.
Note that these conditions should be satisfied only around
the optimal solutions (x‚àó , y ‚àó ) and w‚àó . It does not need to
hold for every point, thus is much weaker than the ordinary strong convexity. Moreover, the inequalities need to
be satisfied only for the solution sequence (w(t) , x(t) , y (t) )
of our algorithm. The strong convexity of the dual loss
fi‚àó implies that the primal loss fi is smooth around the
optimal. The condition (15) is satisfied, for example, by
‚Ñì1 -regularization because the dual of ‚Ñì1 -regularization is
an indicator function with a compact support and, outside
the optimal solution set Y ‚àó , the indicator function is lower
bounded by a quadratic function. In addition, the quadratic
term in the right hand side of this condition (15) is restricted on Ker(B). This makes it possible to include several types of regularization functions. Indeed, if B = Ip ,
this condition is always satisfied. The assumption (16) is
the strongest assumption. This is satisfied for elastic-net

regularization. ‚Ñì1 -regularization could satisfy this condition depending on the optimum w‚àó and the solution sequence. If one wants to make this condition always hold,
just adding a small square term, then the condition is satisfied and we obtain an approximated solution which is sufficiently close to the true one within a precision.
Define the primal and dual objectives as
Pn
FP (w) := n1 i=1 fi (zi‚ä§ w) + œà(B ‚ä§ w),
Pn
FD (x, y) := n1 i=1 fi‚àó (xi ) + œà ‚àó ( ny ) ‚àí hw‚àó , Z nx ‚àí B ny i.

Note that, by Eq. (14), FP (w) ‚àí FP (w‚àó ) and FD (x, y) ‚àí
FD (x‚àó , y ‚àó ) are always non-negative. Define the block diagonal matrix H as HI,I = œÅZI‚ä§ ZI + GI,I for all I ‚àà
{I1 , . . . , IK } and Hi,j = 0 for (i, j) ‚àà
/ Ik √ó Ik (‚àÄk). Let
ky ‚àí Y ‚àó kQ := min{ky ‚àí y ‚àó kQ | y ‚àó ‚àà Y ‚àó }. We define
RD (x, y, w) as
RD (x, y, w) := FD (x, y) ‚àí FD (x‚àó , y ‚àó ) +
+

œÅ(1‚àíŒ≥)
2n kZx

+ Byk2 +

1
2n kx

kw ‚àí w‚àó k2
2n2 Œ≥œÅ

‚àí x‚àó k2vIp +H +

ky‚àíY ‚àó k2Q
.
2nK

For a symmetric matrix S, we define œÉmax (S) and œÉmin (S)
as the maximum and minimum singular value respectively.
1
Theorem 2. Suppose that Œ≥ = 4n
, Œ∑Z,I > {1 + 2Œ≥n(1 ‚àí
‚ä§
1/K)}œÉmax (ZI ZI ) for all I ‚àà {I1 , . . . , IK } and B ‚ä§ is
injective. Then, under Assumption 1, the dual objective
function converges R-linearly: We have that, for C1 =
RD (x(0) , y (0) , w(0) ),

¬µ T
C1 ,
E[RD (x(T ) , y (T ) , w(T ) )] ‚â§ 1 ‚àí
K

hœÅœÉmin (B ‚ä§ B)
v
where ¬µ = min 4(v+œÉmax
(H)) , 2 max{1/n,4hœÅ,4hœÉmax(Q) } ,
	
Kvœà /n
KvœÉmin (BB ‚ä§ )
4œÉmax (Q) , 4œÉmax(Q) (œÅœÉmax (Z ‚ä§ Z)+4v) . In particular,

E[kw(T ) ‚àí w‚àó k2 ] ‚â§

¬µ T
nœÅ 
1‚àí
C1 .
2
K

If we further assume œà(B ‚ä§ w) ‚â§ œà(B ‚ä§ w‚àó ) +
hy ‚àó /n, B ‚ä§ (w ‚àí w‚àó )i + l1 kw ‚àí w‚àó k + l2 kw ‚àí w‚àó k2 (‚àÄw),
then this implies that
E[FP (w(T ) ) ‚àí FP (w‚àó )]

 nœÅ 
‚ä§
¬µ T
Z/n)
‚â§ œÉmax (Z
+
l
1
‚àí
C1
2
2v
2
K
r
nœÅ 
¬µ T
1‚àí
C1 .
+ l1
2
K
Since the proof is technical, it is deferred to the supplementary material. This theorem shows that the primal and
dual objective values converge R-linearly. Moreover, the
primal variable w also converges R-linearly to the optimal value. The number K of sub-batches controls the

Stochastic Dual Coordinate Ascent with ADMM

convergence rate. If all samples are nearly orthogonal to
each other, œÉmax (H) is bounded by a constant for all K,
and thus convergence rate gets faster and faster as K decreases (the size of each sub-batch grows up). On the
other hand, if samples are strongly correlated to each other,
œÉmax (H) grows linearly against 1/K and then the convergence rate is not improved by decreasing K. As for
batch settings, the linear convergence of batch ADMM
has been shown by Deng and Yin (2012). However, their
proof can not be directly applied to our stochastic setting.
Our proof requires a technique specialized to stochastic
coordinate ascent technique. We would like to point out
that the exponential convergence is not guaranteed if the
choice of index set I at each update is cyclic. The index I is supposed to be chosen randomly. It is reported
in Shalev-Shwartz and Zhang (2013a) that cyclic choice of
I yields slower convergence. As described in the introduction, the mini-max optimal rate of stochastic optimization
is at least O(1/T ). This corresponds to the convergence
rate of the test loss in machine learning terminology. However, our analysis focuses on the training loss. Thus we can
obtain the linear convergence.
The statement can be described in terms of the number of
iterations required to achieve a precision «´, i.e. smallest T
satisfying E[FP (w(T ) ) ‚àí FP (w‚àó )] ‚â§ «´:
T ‚â§ C ‚Ä≤ K max

 4(v+œÉmax (H))
v

,

2 max{1/(nh),4œÅ,4œÉmax(Q) }
,
œÅœÉmin (B ‚ä§ B)

4œÉmax (Q) 4œÉmax (Q)(œÅœÉmax (Z ‚ä§ Z)+4v) 	
log
Kvœà /n ,
KvœÉmin (BB ‚ä§ )



nC ‚Ä≤‚Ä≤
«´



,

where C ‚Ä≤ and C ‚Ä≤‚Ä≤ are an absolute constant. This says that
dependency of «´ is log-order. An interesting point is that
the influence of h, the modulus of local strong convexity
of œà. Usually the regularization function is made weaker
as the number of samples increases. In that situation, h decreases as n goes up. However, even if we set h = 1/n (and
n
), we still have T = O(K log(n/«´)) instead of
vœà ‚â• K
O(nK log(n/«´)). Thus, the convergence rate is hardly affected by the setting of h. This point is same as the ordinary
SDCA algorithm (Shalev-Shwartz and Zhang, 2013a).

5. Related Works
In this section, we present some related works and discuss
differences from our method.
The most related work is a recent study by
Shalev-Shwartz and Zhang (2013c) in which stochastic
dual coordinate ascent (SDCA) method for a regularized risk minimization is proposed. Their method also
deals with the dual problem (3) with B = Ip in our
setting, and apply a stochastic coordinate ascent technique. This method converges linearly. At each iteration,
the method solves the following one-dimensional opti(t)
mization problem, ‚àÜxi ‚Üê arg min‚àÜxi ‚ààR fi‚àó (‚àÜxi +

(t‚àí1)

1
kzi ‚àÜxi k2 , and updates
) + zi‚ä§ w(t‚àí1) ‚àÜxi + 2n
xi
(t)
(t)
(t‚àí1)
xi
‚Üê ‚àÜxi + xi
and w(t) ‚Üê ‚àÇ œàÃÉ ‚àó (‚àíZx(t) ).
The most important difference from our method is the
computation of ‚àÇœà ‚àó . In a ‚Äúsimple‚Äù regularization function,
it is often easy to compute the (sub-)gradient of œàÃÉ ‚àó .
However, in a ‚Äúcomplex‚Äù regularization such as structured
regularization, the computation is not efficiently carried
out. To overcome this difficulty, our method utilizes a
linearly transformed one œà(B¬∑) = œàÃÉ(¬∑), and split the
optimization with respect to fi‚àó and œà ‚àó by applying
ADMM technique. Thus, our method is applicable to
much more general regularization functions. A mini-batch
extension of SDCA is a recent hot topic (TakaÃÅcÃå et al., 2013;
Shalev-Shwartz and Zhang, 2013b). Our approach realizes
the mini-batch extension using the linearlization technique
in ADMM which is naturally derived in the frame-work of
ADMM. Although the proof technique is quite different,
the convergence analysis of normal mini-batch SDCA
given by Shalev-Shwartz and Zhang (2013b) is parallel to
our theorem.

The second method related to ours is stochastic average gradient (SAG) method (Le Roux et al., 2013). The
method is a modification of stochastic gradient descent
method, but utilizes an averaged gradient. A good point
of their method is that we only need to deal with the primal problem. Thus the computation is easy, and we don‚Äôt
need to look at the convex conjugate function. Moreover,
their method also converges linearly. However, the linear
convergence of SAG is guaranteed for smoothed loss and
regularization functions. Thus non-smooth structured regularization is not included in the scope of the naive SAG procedure. It is conjectured by Schmidt et al. (2013) that SAG
could be combined with proximal gradient frame-work and
even ADMM. Our work gives a particular answer to this
question in the setting of SDCA.
The third method is online version of ADMM. Recently
some online variants of ADMM have been proposed by
Wang and Banerjee (2012); Suzuki (2013); Ouyang et al.
(2013). These methods are effective for complex regularizations as discussed in this paper. Thus they are applicable to wide range of situations. However, those methods are basically online methods, thus they discard the
samples once observed. They are not adapted to a situation where the training samples are observed
‚àö several times.
Therefore, the convergence rate is O(1/ T ) in general and
O(log(T )/T ) for a strongly convex loss (possibly O(1/T )
with some modification). On the other hand, our method
converges linearly.

6. Numerical Experiments
In this section, we give numerical experiments on
artificial and real data to demonstrate the effective-

Stochastic Dual Coordinate Ascent with ADMM

Empirical Risk

Empirical Risk

n = 5120

CPU time (s)

Test Loss

Test Loss

CPU time (s)

CPU time (s)

CPU time (s)
RDA
OPG-ADMM
RDA-ADMM
OL-ADMM
Batch-ADMM
SDCA-ADMM

Classification Error

Then the proximal operation with respect to its dual function is analytically given as follows (see the supplementary
material for the derivation):
Ô£±
Cu‚àíyi
i ‚àí1
Ô£¥
(‚àí1 ‚â§ Cuy
‚â§ 0),
Ô£≤ 1+C
1+C
Cuyi ‚àí1
‚àó
prox(u|fi /C) = ‚àíyi
(‚àí1 > 1+C ),
Ô£¥
Ô£≥
0
(otherwise).

n = 512

Classification Error

ness of our proposed algorithm2 . We compare our
SDCA-ADMM with the existing stochastic optimization methods such as regularized dual averaging (RDA)
(Duchi and Singer, 2009; Xiao, 2009), online ADMM
(OL-ADMM) (Wang and Banerjee, 2012), online proximal
gradient descent ADMM (OPG-ADMM) (Ouyang et al.,
2013; Suzuki, 2013) and RDA-ADMM (Suzuki, 2013).
We also compared our method with batch ADMM (BatchADMM) in the artificial data sets. We used sub-batch with
size 50 for all the methods including ours (|Ik | = 50, but
|IK | could be less than 50). We employed the parameter
settings Œ≥ = 1/n and œÅ = 0.13 . As for Œ∑Z,I and Œ∑B , we
used Œ∑Z,I = 1.1œÉmax (ZI‚ä§ ZI ) and Œ∑B = œÉmax (BB ‚ä§ ) + 1.
All of the experiments are classification problems with
structured sparsity. We employed the smoothed hinge loss:
Ô£±
Ô£¥
(yi u ‚â• 1),
Ô£≤0,
fi (u) = 21 ‚àí yi u,
(yi u < 0),
Ô£¥
Ô£≥1
2
2 (1 ‚àí yi u) , (otherwise).

CPU time (s)

CPU time (s)

Figure 1. Excess empirical risk, exected loss on the test data and
test classification error averaged over 10 independent iteration
against CPU time in artificial data with n = 512, 5120. The error
bar indicates the standard deviation.

6.1. Artificial Data

Here we execute numerical experiments on artificial data
sets. The problem is a classification problem with overlapped group regularization as performed in Suzuki (2013).
We generated n input feature vectors {zi }ni=1 with dimension d = 32 √ó 32 = 1024 where each feature is generated from i.i.d. standard normal distribution. Then the true
weight vector w0 is generated as follows: First we generate
a random matrix which has non-zero elements on its first
column (distributed from i.i.d. standard normal) and zeros
on other columns, and vectorize the matrix to obtain w0 .
The training label yi is given by yi = sign(zi‚ä§ w0 + «´i )
where «´i is distributed from normal distribution with mean
0 and standard deviation 0.1.
The group regularization is given as œàÃÉ(x)
=
P32
P32
P
2
C( i=1 kX:,i k + j=1 kXj,: k + 0.01 √ó i,j Xi,j /2)
where X is the 32 √ó 32 matrix obtained by reshaping x.
The quadratic term is added to make the regularization
function strongly convex4 . Since there exist overlaps
2
All the experiments were carried out on Intel Core i7
2.93GHz with 8GB RAM.
3
In our experiments, œÅ = 0.1 gave nice performances on all
datasets. Too large or too small rho does not give a proper performance, but œÅ = 0.1 gave stable performances in our experiments.
4
Even if there is no quadratic term, our method converged with
almost the same speed.

between groups, the proximal operation can not be
straightforwardly computed (Jacob et al., 2009). To deal
with this regularization function in our frame-work, we
let B ‚ä§ x = [x; x](= [x‚ä§ x‚ä§ ]‚ä§ ), that is B = [Ip Ip ], and
P32
P32
‚Ä≤
œà([x; x‚Ä≤ ]) = C( i=1 kX:,i k + j=1 kXj,:
k). Then we
‚ä§
can see that œàÃÉ(x) = œà(B x) and the proximal operation
with respect to œà is analytically obtained; indeed it is
easily checked that prox([q; q ‚Ä≤ ]|œà) = [STC ‚Ä≤ (Q:,1 /(1 +
0.01C)); . . . ; STC ‚Ä≤ (Q:,32 /(1 + 0.01C)); STC ‚Ä≤ (Q‚Ä≤1,: /(1 +
0.01C)); . . . ; STC ‚Ä≤ (Q‚Ä≤32,: /(1
+
0.01C))]
where
STC (q) = q max(1‚àíC/kqk, 0) and C ‚Ä≤ = C/(1+0.01C).
The original RDA requires a direct computation of the
proximal operation for the overlapped group penalty. To
compute that, we employed the dual formulation proposed
by Yuan et al. (2011).
We independently repeated the experiments 10
times and averaged the excess empirical risk
(FP (w(t) ) ‚àí minw FP (w)), the expected loss on the
test data (E(z,y) [f (y, z ‚ä§ w(t) )]) and the classification error
(E(z,y) [1{y 6= sign(z ‚ä§ w(t) )}). Figure 1 shows these three
values against CPU time with the standard deviation
for
‚àö
n = 512 and n = 5120. We employed C1 = 0.1/ n.
We observe that the excess empirical risk of our method,

Stochastic Dual Coordinate Ascent with ADMM

a9a

Empirical Risk

Empirical Risk

20news

CPU time (s)

CPU time (s)

Test Loss

Test Loss

SDCA-ADMM, actually converges linearly while other
stochastic methods don‚Äôt show linear convergence. Although Batch-ADMM also shows linear convergence and
its convergence speed is comparable to SDCA-ADMM for
small sample situation (n = 512), SDCA-ADMM is much
faster than Batch-ADMM when the number of samples is
large (n = 5120). As for the classification error, existing stochastic methods also show nice performances despite the poor convergence of the empirical risk. On the
other hand, SDCA-ADMM rapidly converges to a stable
state and shows comparable or better classification accuracy than existing methods.
6.2. Real Data

œàÃÉ(w) = C1
+ 0.01 √ó

Pp

i=1 |wi | + C2
Pp
(C1 i=1 |wi |2 +

P

(i,j)‚ààE

C2

P

|wi ‚àí wj |

(i,j)‚ààE

2

|wi ‚àí wj | ).

Now let F be |E|√óp matrix where Fe,i = 1 and Fe,j = ‚àí1,
if (i, j) = e ‚àà E, and Fe,i = 0 otherwise.
Then
Pp
by letting B ‚ä§ = [Ip ; F ] and œà(u) = C1 i=1 |ui | +
P|E|
Pp
P|E|
C2 i=p+1 |ui |+0.01(C1 i=1 |ui |2 +C2 i=p+1 |ui |2 )
for u ‚àà Rp+|E| , we have œàÃÉ(w) = œà(B ‚ä§ w). Note that
the proximal operation with respect to œà is just the softthresholding operation. In our experiments,
we employed
‚àö
C2 = C1 |E|/p and C1 = 0.01/ n.
We computed the empirical risk on the training data, the
averaged loss on the test data, and the test classification
error (Figure 2). We observe that the empirical risk on the
training data of SDCA-ADMM converges much faster than
other methods. Although other methods also performs well
on the test loss and the classification error, SDCA-ADMM
still converges faster than existing methods with respect to
the two quantities measured on the test data.

CPU time (s)
OPG-ADMM
RDA-ADMM
OL-ADMM
SDCA-ADMM

Classification Error

CPU time (s)

Classification Error

Here we execute numerical experiments on real data; ‚Äò20
Newsgroups‚Äô5 and ‚Äòa9a‚Äô6 . ‚Äò20 Newsgroups‚Äô contains 100
dimensional 12,995 training samples and 3,247 test samples. ‚Äòa9a‚Äô contains 123 dimensional 32,561 training samples and 16,281 test samples. We constructed a similarity graph between features using graph Lasso and applied
graph guided regularization as in Ouyang et al. (2013).
That is, we applied graph Lasso to the training samples,
and obtain a sparse inverse variance-covariance matrix FÃÇ .
Based on the similarity matrix FÃÇ , we connect all index pairs
(i, j) with FÃÇi,j 6= 0 on edges. We denote by E the set of
edges. Then we impose the following graph guided regularization:

CPU time (s)

CPU time (s)

Figure 2. Empirical risk, average loss on the test data and test classification error averaged over 5 independent iteration against CPU
time in real data. The error bar indicates the standard deviation.

7. Conclusion
We proposed a new stochastic dual coordinate ascent technique with alternating direction method of multipliers. The
proposed method can be applied to wide range of regularization functions. Moreover, we proposed a mini-batch extension of our method. It is shown that, under some strong
convexity conditions, our method converges exponentially.
According to our analysis, the mini-batch method improves
the convergence rate if the input features don‚Äôt have strong
correlation between each other. The numerical experiments
showed that our method actually converges exponentially,
and the convergence is fast in terms of both empirical and
expected risk.
Future work includes that the determination of Œ∑Z,I . In
Theorem 2, the exponential convergence is guaranteed if
Œ∑Z,I >= {1 + 2Œ≥n(1 ‚àí 1/K)}œÉmax (ZI‚ä§ ZI ). However,
in our preliminary numerical experiments, an aggressive
method like the one suggested in TakaÃÅcÃå et al. (2013) performed effectively in some data sets. Developing more sophisticated determination of Œ∑Z,I (and G) would be a potentially promising future work.

5

Available at http://www.cs.nyu.edu/Àúroweis/data.html. We
converted the four class classification task into binary classification by grouping category 1,2 and category 3,4 respectively.
6
Available
at
‚ÄòLIBSVM
data
sets‚Äô
http://www.csie.ntu.edu.tw/Àúcjlin/libsvmtools/datasets.

Acknowledgement TS was partially supported by
MEXT Kakenhi 25730013, and the Aihara Project, the
FIRST program from JSPS, initiated by CSTP.

Stochastic Dual Coordinate Ascent with ADMM

References
S. Boyd, N. Parikh, E. Chu, B. Peleato, and J. Eckstein.
Distributed optimization and statistical learning via the
alternating direction method of multipliers. Foundations
and Trends in Machine Learning, 3:1‚Äì122, 2010.
W. Deng and W. Yin. On the global and linear convergence of the generalized alternating direction method of
multipliers. Technical report, Rice University CAAM
TR12-14, 2012.
J. Duchi and Y. Singer. Efficient online and batch learning
using forward backward splitting. Journal of Machine
Learning Research, 10:2873‚Äì2908, 2009.
D. Gabay and B. Mercier. A dual algorithm for the solution of nonlinear variational problems via finite-element
approximations. Computers & Mathematics with Applications, 2:17‚Äì40, 1976.
M. Hestenes. Multiplier and gradient methods. Journal of
Optimization Theory & Applications, 4:303‚Äì320, 1969.
L. Jacob, G. Obozinski, and J.-P. Vert. Group lasso with
overlap and graph lasso. In Proceedings of the 26th International Conference on Machine Learning, 2009.
N. Le Roux, M. Schmidt, and F. Bach. A stochastic gradient method with an exponential convergence rate for
strongly-convex optimization with finite training sets. In
Advances in Neural Information Processing Systems 25,
2013.
A. Nemirovskii and D. Yudin. Problem complexity and
method efficiency in optimization. John Wiley, New
York, 1983.
H. Ouyang, N. He, L. Q. Tran, and A. Gray. Stochastic
alternating direction method of multipliers. In Proceedings of the 30th International Conference on Machine
Learning, 2013.
M. Powell. A method for nonlinear constraints in minimization problems. In R. Fletcher, editor, Optimization,
pages 283‚Äì298. Academic Press, London, New York,
1969.
Z. Qin and D. Goldfarb. Structured sparsity via alternating direction methods. Journal of Machine Learning Research, 13:1435‚Äì1468, 2012.
A. Rakotomamonjy. Applying alternating direction method
of multipliers for constrained dictionary learning. Neurocomputing, 106:126‚Äì136, 2013.
R. T. Rockafellar. Convex Analysis. Princeton University
Press, Princeton, 1970.

R. T. Rockafellar. Augmented Lagrangians and applications of the proximal point algorithm in convex programming. Mathematics of Operations Research, 1:97‚Äì116,
1976.
M. Schmidt, N. Le Roux, and F. Bach. Minimizing finite
sums with the stochastic average gradient. Technical report, 2013. arXiv:1309.2388.
S. Shalev-Shwartz and T. Zhang. Stochastic dual coordinate ascent methods for regularized loss minimization. Journal of Machine Learning Research, 14:567‚Äì
599, 2013a.
S. Shalev-Shwartz and T. Zhang. Accelerated mini-batch
stochastic dual coordinate ascent. In Advances in Neural
Information Processing Systems 26, 2013b.
S. Shalev-Shwartz and T. Zhang. Proximal stochastic dual coordinate ascent. Technical report, 2013c.
arXiv:1211.2717.
M. Signoretto, L. D. Lathauwer, and J. Suykens. Nuclear norms for tensors and their use for convex multilinear estimation. Technical Report 10-186, ESAT-SISTA,
K.U.Leuven, 2010.
T. Suzuki. Dual averaging and proximal gradient descent
for online alternating direction multiplier method. In
Proceedings of the 30th International Conference on
Machine Learning, 2013.
M. TakaÃÅcÃå, A. Bijral, P. RichtaÃÅrik, and N. Srebro. Mini-batch
primal and dual methods for SVMs. In Proceedings of
the 30th International Conference on Machine Learning,
2013.
R. Tomioka, T. Suzuki, K. Hayashi, and H. Kashima. Statistical performance of convex tensor decomposition. In
Advances in Neural Information Processing Systems 25,
2011.
H. Wang and A. Banerjee. Online alternating direction
method. In Proceedings of the 29th International Conference on Machine Learning, 2012.
L. Xiao. Dual averaging methods for regularized stochastic
learning and online optimization. In Advances in Neural
Information Processing Systems 23, 2009.
L. Yuan, J. Liu, and J. Ye. Efficient methods for overlapping group lasso. In Advances in Neural Information
Processing Systems 24, 2011.

