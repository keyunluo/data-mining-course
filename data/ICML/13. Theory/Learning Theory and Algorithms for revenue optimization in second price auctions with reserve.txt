Learning Theory and Algorithms for Revenue Optimization
in Second-Price Auctions with Reserve
Mehryar Mohri
Courant Institute and Google Research, 251 Mercer Street, New York, NY 10012
Andres MunÌƒoz Medina
Courant Institute, 251 Mercer Street,New York, NY 10012

Abstract
Second-price auctions with reserve play a critical
role in the revenue of modern search engine and
popular online sites since the revenue of these
companies often directly depends on the outcome
of such auctions. The choice of the reserve price
is the main mechanism through which the auction revenue can be influenced in these electronic
markets. We cast the problem of selecting the
reserve price to optimize revenue as a learning
problem and present a full theoretical analysis
dealing with the complex properties of the corresponding loss function. We further give novel
algorithms for solving this problem and report
the results of several experiments demonstrating
their effectiveness.

1. Introduction
Over the past few years, advertisement has gradually
moved away from the traditional printed promotion to the
more tailored and directed online publicity. The advantages of online advertisement are clear: since most modern
search engine and popular online site companies such as as
Microsoft, Facebook, Google, eBay, or Amazon, may collect information about the usersâ€™ behavior, advertisers can
better target the population sector their brand is intended
for.
More recently, a new method for selling advertisements has
gained momentum. Unlike the standard contracts between
publishers and advertisers where some amount of impressions is required to be fulfilled by the publisher, an Ad
Exchange works in a way similar to a financial exchange
where advertisers bid and compete between each other for
an ad slot. The winner then pays the publisher and his ad is
displayed.
The design of such auctions and their properties are crucial
Proceedings of the 31 st International Conference on Machine
Learning, Beijing, China, 2014. JMLR: W&CP volume 32. Copyright 2014 by the author(s).

MOHRI @ CIMS . NYU . EDU

MUNOZ @ CIMS . NYU . EDU

since they generate a large fraction of the revenue of popular online sites. These questions have motivated extensive research on the topic of auctioning in the last decade
or so, particularly in the theoretical computer science and
economic theory communities. Much of this work has focused on the analysis of mechanism design, either to prove
some useful property of an existing auctioning mechanism,
to analyze its computational efficiency, or to search for
an optimal revenue maximization truthful mechanism (see
(Muthukrishnan, 2009) for a good discussion of key research problems related to Ad Exchange and references to
a fast growing literature therein).
One important problem is that of determining an auction
mechanism that achieves optimal revenue (Muthukrishnan,
2009). In the ideal scenario where the valuation of the
bidders is drawn i.i.d. from a given distribution, this is
known to be achievable (see for example (Myerson, 1981)).
But, even good approximations of such distributions are not
known in practice. Game theoretical approaches to the design of auctions have given a series of interesting results
including (Riley & Samuelson, 1981; Milgrom & Weber,
1982; Myerson, 1981; Nisan et al., 2007), all of them based
on some assumptions about the distribution of the bidders,
e.g., the monotone hazard rate assumption.
The results of the recent publications have nevertheless set
the basis for most Ad Exchanges in practice: the mechanism widely adopted for selling ad slots is that of a Vickrey auction (Vickrey, 1961) or second-price auction with
reserve price r (Easley & Kleinberg, 2010). In such auctions, the winning bidder (if any) pays the maximum of
the second-place bid and the reserve price r. The reserve
price can be set by the publisher or automatically by the exchange. The popularity of these auctions relies on the fact
that they are incentive compatible, i.e., bidders bid exactly
what they are willing to pay. It is clear that the revenue of
the publisher depends greatly on how the reserve price is
set: if set too low, the winner of the auction might end up
paying only a small amount, even if his bid was really high;
on the other hand, if it is set too high, then bidders may not
bid higher than the reserve price and the ad slot will not be
sold.

Learning Theory and Algorithms for Revenue Optimization in Second-Price Auctions with Reserve

We propose a machine learning approach to the problem of
determining the reserve price to optimize revenue in such
auctions. The general idea is to leverage the information
gained from past auctions to predict a beneficial reserve
price. Since every transaction on an Exchange is logged, it
is natural to seek to exploit that data. This could be used to
estimate the probability distribution of the bidders, which
can then be used indirectly to come up with the optimal reserve price (Myerson, 1981; Ostrovsky & Schwarz, 2011).
Instead, we will seek a discriminative method making use
of the loss function related to the problem and taking advantage of existing user features.
Machine learning methods have already been used for the
related problems of designing incentive compatible auction
mechanisms (Balcan et al., 2008; Blum et al., 2004), for
algorithmic bidding (Langford et al., 2010; Amin et al.,
2012), and even for predicting bid landscapes (Cui et al.,
2011). But, to our knowledge, no prior work has used historical data in combination with user features for the sole
purpose of revenue optimization in this context. In fact, the
only publications we are aware of that are directly related to
our objective are (Ostrovsky & Schwarz, 2011) and the interesting work of Cesa-Bianchi et al. (2013) which considers a more general case than (Ostrovsky & Schwarz, 2011).
The scenario studied by Cesa-Bianchi et al. is that of censored information, which motivates their use of a bandit
model to optimize the revenue of the seller. Our analysis
assumes instead access to full information. We argue that
this is a more realistic scenario since most companies do in
fact have access to the full historical data.
The learning scenario we consider is more general since it
includes the use of features, as is standard in supervised
learning. Since user information is sent to advertisers and
bids are made based on this information, it is only natural
to include user features in our learning solution. A special case of our analysis coincides with the no-feature scenario considered by Cesa-Bianchi et al. (2013), assuming
full information. But, our results further extend those of
this paper even in that scenario. In particular, we present an
O(m log m) algorithm for solving a key optimization problem used as a subroutine by the authors, for which they do
not seem to give an algorithm. We also do not require an
i.i.d. assumption about the bidders, although this is needed
in (Cesa-Bianchi et al., 2013) only for the bandit approach.
The theoretical and algorithmic analysis of this learning
problem raises several non-trivial technical issues. This is
because, unlike some common problems in machine learning, here, the use of a convex surrogate loss cannot be successful. Instead, we must derive an alternative non-convex
surrogate requiring novel theoretical guarantees (Section 3)
and a new algorithmic solution (Section 4). We present a
detailed analysis of possible surrogate losses and select a
continuous loss that we prove to be calibrated and for which

we give generalization bounds. This leads to an optimization problem cast as a DC-programming problem whose
solutions are examined in detail: we first present an efficient combinatorial algorithm for solving that optimization
in the no-feature case, next we combine that solution with
the DC algorithm (DCA) (Tao & An, 1998) to solve the
general case. Section 5 reports the results of our experiments with synthetic data in both the no-feature case and
the general case. We first introduce the problem of selecting the reserve price to optimize revenue and cast it as a
learning problem (Section 2).

2. Reserve price selection problem
As already discussed, the choice of the reserve price r is the
main mechanism through which a seller can influence the
auction revenue. To specify the results of a second-price
auction we need only the vector of first and second highest
bids which we denote by b = (b(1) , b(2) ) âˆˆ B âŠ‚ R2+ . For
a given reserve price r and bid pair b, the revenue of an
auction is given by
Revenue(r, b) = b(2) 1r<b(2) + r1b(2) â‰¤râ‰¤b(1) .

(1)

The simplest setup is one where there are no features associated with the auction. In that case, the objective is to
select r to optimize the expected revenue, which can be expressed as follows (see Appendix A.1):
Z âˆž
E[Revenue(r, b)] = P[b(2) > t]dt + r P[b(1) â‰¥ r]. (2)
b

r

A similar derivation is given by Cesa-Bianchi et al. (2013).
In fact, this expression is precisely the one optimized by
these authors. If we now associate with each auction a feature vector x âˆˆ X , the so-called public information, and
set the reserve price to h(x), where h : X â†’ R+ is our
reserve price hypothesis function, the problem can be formulated as that of selecting out of some hypothesis set H a
hypothesis h with large expected revenue:
E

(x,b)âˆ¼D

[Revenue(h(x), b)],

(3)

where D is the unknown distribution according to which
the pairs (x, b) are drawn. Instead of the revenue, we
will consider a loss function L defined for all (r, b) by
L(r, b) = âˆ’Revenue(r, b), and will seek a hypothesis h
with small expected loss L(h) := E(x,b)âˆ¼D [L(h(x), b)].
As in standard supervised learning scenarios, we assume
access to a training sample S = ((x1 , b1 ), . . . , (xm , bm ))
of size m â‰¥ 1 drawn i.i.d. according
to D and denote by
Pm
1
L(h(x
LbS (h) the empirical loss m
i , bi ). In the next
i=1
sections, we present a detailed study of this learning problem.

Learning Theory and Algorithms for Revenue Optimization in Second-Price Auctions with Reserve
b2

1
0

0.1

b2

1

Real Loss
Convex Surrogate

0
0

1

2

3

4

5

6

7

0
0

-1

-1

-2

-2

-3

-3

-4

-4

1

2

3

4

5

6

âˆ’0.18

Real Loss
Î³âˆ’Loss

âˆ’0.2
âˆ’0.22

7

âˆ’0.24
âˆ’0.1

âˆ’0.26
âˆ’0.28

-5

âˆ’0.2

-5

b1

(a)

b1

3. Learning guarantees
To derive generalization bounds for the learning problem
formulated in the previous section, we need to analyze the
complexity of the family of functions LH mapping X Ã—
B to R defined by LH = {(x, b) 7â†’ L(h(x), b) : h âˆˆ
H}. The loss function L is neither Lipschitz continuous
nor convex (see Figure 1). To analyze its complexity, we
decompose L as a sum of two loss functions l1 and l2 with
more convenient properties. We have L = l1 + l2 with l1
and l2 defined for all (x, b) âˆˆ X Ã— B by
l1 (r, b) = âˆ’b
l2 (r, b) = b

(1)

1r<b(2) âˆ’ r1b(2) â‰¤râ‰¤b(1) âˆ’ b

0.2

0.4
0.6
Reserve Price

0.8

0

0.2

(a)

(b)

Figure 1. (a) Plot of the loss function r 7â†’ L(r, b) for fixed values
of b(1) and b(2) ; (b) piecewise linear convex surrogate loss.

(2)

âˆ’0.3
âˆ’0.32

âˆ’0.3
0

(1)

1r>b(1)

1r>b(1) .

Note that for a fixed b, the function r 7â†’ l1 (r, b) is 1Lipschitz since the slope of the lines defining the function
is at most 1. We will consider the corresponding family
of loss functions: l1H = {(x, b) 7â†’ l1 (h(x), b) : h âˆˆ
H} and l2H = {(x, b) 7â†’ l2 (h(x), b) : h âˆˆ H} and
use the notions of pseudo-dimension as well as empirical and average Rademacher complexity. The pseudodimension is a standard complexity measure (Pollard,
1984) extending the notion of VC-dimension to real-valued
functions (see also (Mohri et al., 2012)). For a family of functions G and finite sample S = (z1 , . . . , zm )
of size m, the empirical
 Rademacher
 is dePmcomplexity
1
b S (G) = EÏƒ sup
fined by R
Ïƒ
g(z
)
i , where
gâˆˆG m
i=1 i
Ïƒ = (Ïƒ1 , . . . , Ïƒm )> , with Ïƒi s independent uniform random variables taking values in {âˆ’1, +1}. The Rademacher
b S (G)].
complexity of G is defined as Rm (G) = ESâˆ¼Dm [R
Theorem 1. Let M = supbâˆˆB b(1) and let H be a hypothesis set with pseudo-dimension d = Pdim(H). Then, for
any Î´ > 0, with probability at least 1 âˆ’ Î´ over the choice
of a sample S of size m, the following inequality holds for
all h âˆˆ H:
s
r
em
2d
log
log 1Î´
d
+M
.
L(h) â‰¤ LbS (h)+2Rm (H)+2M
m
2m
Proof. By a standard property of the Rademacher complexity, since L = l1 + l2 , the following inequality holds:
Rm (LH ) â‰¤ Rm (l1H )+Rm (l2H ). Thus, in view of Propositions 9 and 10, the Rademacher complexity of LH can be

0.4
0.6
Reserve Price

0.8

(b)

Pm
Figure 2. Comparison of the sum of real losses
i=1 L(Â·, bi )
for m = 500 versus two different surrogates. (a) Sum of convex surrogate losses: the minimizer significantly differs from that
of
the sum of the original losses. (b) The surrogate loss sum
Pm
i=1 LÎ³ (Â·, bi ) for Î³ = .02

bounded via
r
Rm (LH ) â‰¤ Rm (H) + M

2d log
m

em
d

.

The result then follows by the application of a standard Rademacher complexity bound (Koltchinskii &
Panchenko, 2002).
This learning bound invites us to consider an algorithm
seeking h âˆˆ H to minimize the empirical loss LbS (h), while
controlling the complexity (Rademacher complexity and
pseudo-dimension) of the hypothesis set H. However, as in
the familiar case of binary classification, in general, minimizing this empirical loss is a computationally hard problem. Thus, in the next section, we study the question of
using a surrogate loss instead of the original loss L.
3.1. Surrogate loss
As pointed out earlier, the loss function L does not admit
some common useful properties: for any fixed b, L(Â·, b)
is not differentiable at two points, is not convex, and is
not Lipschitz, in fact it is discontinuous. For any fixed b,
L(Â·, b) is quasi-convex, a property that is often desirable
since there exist several solutions for quasi-convex optimization problems. However, in general,
a sum of quasiPm
convex functions, such as the sum i=1 L(Â·, bi ) appearing
in the definition of the empirical loss, is not quasi-convex
and a fortiori not convex.1 In fact, in general, such a sum
may admit exponentially many local minima. This leads us
to seek a surrogate loss function with more favorable optimization properties.
A standard method in machine learning consists of replacing the loss function L with a convex upper bound (Bartlett
et al., 2006). A natural candidate in our case is the piecewise linear convex function shown in Figure 1(b). However, while this convex loss function is convenient for optimization, it is not calibrated and does not provide a useful
1
It is known that under some separability condition if a finite
sum of quasi-convex functions on an open convex set is quasiconvex then all but perhaps one of them is convex (Debreu &
Koopmans, 1982).

Learning Theory and Algorithms for Revenue Optimization in Second-Price Auctions with Reserve

surrogate. The calibration problem is illustrated by Figure 2(a) in dimension
Pmone, where the true objective function
to be minimized i=1 L(r, bi ) is compared with the sum
of the surrogate losses. The next theorem shows that this
problem affects in fact any non-constant convex surrogate.
e : R Ã— R+ â†’ R deIt is expressed in terms of the loss L
e
fined by L(r, b) = âˆ’r1râ‰¤b , which coincides with L when
the second bid is 0.
Theorem 2 (convex surrogates). There exists no nonconstant function Lc : R Ã— R+ â†’ R convex with respect to
its first argument and satisfying the following conditions:
â€¢ for any b0 âˆˆ R+ , limbâ†’bâˆ’ Lc (b0 , b) = Lc (b0 , b0 ).
0

â€¢ for any distribution D on R+ , there exists a none b)] such
negative minimizer râˆ— âˆˆ argminr Ebâˆ¼D [L(r,
âˆ—
that minr Ebâˆ¼D Lc (r, b) = Ebâˆ¼D Lc (r , b).
This theorem, proven in Appendix A.4, leads us to consider alternative non-convex loss functions. Perhaps, the
most natural surrogate loss is then L0Î³ , an upper bound on
L defined for all Î³ > 0 by:
L0Î³ (r, b) = âˆ’b(2) 1râ‰¤b(2) âˆ’ r1

b(2) <râ‰¤

+

1 âˆ’ Î³
Î³

âˆ¨


b(2)
(râˆ’b(1) )1
(2)
âˆ’b

b(1)

(1âˆ’Î³)b(1)

(1âˆ’Î³)b(1)





b2 (1 âˆ’ Î³)b1
1

0

0
0

1

2

3

4

5

0

-1

-1

-2

-2

-3

-3

-4

-4

1

2

3

b1

(a)

4

5

b1

(b)

Figure 3. Comparison of the true loss L with (a) the surrogate loss
L0Î³ ; (b) the surrogate loss LÎ³ , for Î³ = 0.1.

around the minimal value, the loss function LÎ³ leads to
more informative solutions in this problem. We further analyze the difference of the expectations of L and LÎ³ and
show that LÎ³ is calibrated. We will use for any h âˆˆ H, the
notation LÎ³ (h) := E(x,b)âˆ¼D [LÎ³ (h(x), b)].
Theorem 3. Let H be a closed, convex subset of a linear
space of functions containing 0. Denote by hâˆ—Î³ the solution
of minhâˆˆH LÎ³ (h). If supbâˆˆB b(1) = M < âˆž, then
L(hâˆ—Î³ ) âˆ’ LÎ³ (hâˆ—Î³ ) â‰¤ Î³M.

âˆ¨b(2)

âˆ¨b(2) )<râ‰¤b(1)

(1 + Î³)b1

b2

1

,

where câˆ¨d = max(c, d). The plot of this function is shown
in Figure 3(a). The max terms ensure that the function is
well defined if (1 âˆ’ Î³)b(1) < b(2) . However, this turns
out to be also a poor choice because L0Î³ is a loose upper
bound of L in the most critical region, that is around the
minimum of the loss L. Thus, instead, we will consider,
for any Î³ > 0, the loss function LÎ³ defined as follows:
LÎ³ (r, b) = âˆ’b(2) 1râ‰¤b(2) âˆ’ r1b(2) <râ‰¤b(1) +
1
(r âˆ’ (1 + Î³)b(1) )1b(1) <râ‰¤(1+Î³)b(1) , (4)
Î³
and shown in Figure 3(b).2 A comparison between the
sum of L-losses and the sum of LÎ³ -losses is shown in Figure 2(b). Observe that the fit is considerably better than
when using a piecewise linear convex surrogate loss. A
possible concern associated with the loss function LÎ³ is
that it is a lower bound for L. One might think then that
minimizing it would not lead to an informative solution.
However, we argue that this problem arises significantly
with upper bounding losses such as the convex surrogate,
which we showed not to lead to a useful minimizer, or
L0Î³ , which is a poor approximation of L near its minimum.
By matching the original loss L in the region of interest,

The following sets, which will be used in our proof, form a
partition of X Ã— B
I1 = {(x, b)|hâˆ—Î³ (x) â‰¤ b(2) }
I2 = {(x, b)|hâˆ—Î³ (x) âˆˆ (b(2) , b(1) ]}
I3 = {(x, b)|hâˆ—Î³ (x) âˆˆ (b(1) , (1 + Î³)b(1) ]}
I4 = {(x, b)|hâˆ—Î³ (x) > (1 + Î³)b(1) }
This sets represent the different regions where LÎ³ is defined. In each region the function is affine. We will now
state a technical lemma that will help us prove Theorem 3.
The proof of this lemma is given in Appendix A.4.
Lemma 4. Under the conditions of Theorem 3,
h
i
h
i 1
E hâˆ—Î³ (x)1I3 (x) .
E hâˆ—Î³ (x)1I2 (x) â‰¥
x,b
Î³ x,b
Proof. Of Theorem 3. We can express the difference as
h
i
E L(hâˆ—Î³ (x), b) âˆ’ LÎ³ (hâˆ—Î³ (x), b)
(5)
x,b

=

4
X
k=1

h
i
E (L(hâˆ—Î³ (x), b) âˆ’ LÎ³ (hâˆ—Î³ (x), b))1Ik (x)

x,b

h

i
= E (L(hâˆ—Î³ (x), b) âˆ’ LÎ³ (hâˆ—Î³ (x), b))1I3 (x)
x,b
h1
i
= E
((1 + Î³)b(1) âˆ’ hâˆ—Î³ (x))1I3 (x)) .
x,b Î³

(6)

2

Technically, the theoretical and algorithmic results we
present for LÎ³ could be developed in a somewhat similar way
for L0Î³ .

Furthermore, for (x, b) âˆˆ I3 , we know that b(1) < hâˆ—Î³ (x).
Thus, we can bound (6) by Ex,b [hâˆ—Î³ (x)1I3 (x)], which, by

Learning Theory and Algorithms for Revenue Optimization in Second-Price Auctions with Reserve

h

Lemma 4, is less than Î³ Ex,b hâˆ—Î³ (x)1I2 (x) . Thus, we can
write
h
i
h
i
E L(hâˆ—Î³ (x), b) âˆ’ E LÎ³ (hâˆ—Î³ (x), b)
x,b
x,b
h
i
h
i
â‰¤ Î³ E hâˆ—Î³ (x)1I2 (x) â‰¤ Î³ E b(1) 1I2 (x) â‰¤ Î³M,
x,b

x,b

(2)

Vi (nk+1 , bi ) = âˆ’ai nk+1
b(2)

(2)

bi
nk

(1 + Î·)b(1)

(1)

bi

(1)

(1 + Î·)bi

nk+1

âˆ’a(1)

a(3) r âˆ’ a(4)
âˆ’a(2) r
(2)

since hâˆ—Î³ (x) â‰¤ b(1) for (x, b) âˆˆ I2 .

Vi (nk , bi ) = âˆ’ai nk
b(1)

Notice that, since L â‰¥ LÎ³ for all Î³ â‰¥ 0, it follows easily
from the proposition that LÎ³ (hâˆ—Î³ ) â†’ L(hâˆ— ). Indeed, if hâˆ—
is the best hypothesis in class for the real loss, then the
following inequalities are straightforward:

(a)

(b)

Figure 4. (a) Prototypical v-function. (b) Illustration of the fact
that the definition of Vi (r, bi ) does not change on an interval
[nk , nk+1 ].

0 â‰¤ LÎ³ (hâˆ— ) âˆ’ LÎ³ (hâˆ—Î³ ) â‰¤ L(hâˆ— ) âˆ’ LÎ³ (hâˆ—Î³ )
â‰¤ L(hâˆ—Î³ ) âˆ’ LÎ³ (hâˆ—Î³ ) â‰¤ Î³M
The 1/Î³-Lipschitzness of LÎ³ can be used to prove the following generalization bound (see Appendix A.5).
Theorem 5. Fix Î³ âˆˆ (0, 1] and let S denotes a sample
of size m. Then, for any Î´ > 0, with probability at least
1 âˆ’ Î´ over the choice of the sample S, for all h âˆˆ H, the
following holds:
s
log 1Î´
2
.
(7)
LÎ³ (h) â‰¤ LbÎ³ (h) + Rm (H) + M
Î³
2m
The theorem can be used to derive a learning bound that
holds uniformly for all Î³ âˆˆp(0, 1], at the price of an additional term of the form O( log log(1/Î³)/m). These results are reminiscent of the standard margin bounds with
Î³ playing the role of a margin. The situation here is however somewhat different. Our learning bounds suggest, for
a fixed Î³ âˆˆ (0, 1], to seek a hypothesis h minimizing the
empirical loss LbÎ³ (h) while controlling a complexity term
upper bounding Rm (H), which in the case of a family of
linear hypotheses could be khk2K for some PSD kernel K.
Since the bound can hold uniformly for all Î³, we can use it
to select Î³ out of a finite set of possible grid search values.
Alternatively, Î³ can be set via cross-validation.

4. Algorithms
In this section we present algorithms for solving the optimization problem for selecting the reserve price. We start
with the no-feature case and then treat the general case.
4.1. No feature case
We present a general algorithm to optimize sums of functions similar to LÎ³ or L in the one-dimensional case.
Definition 6. We will say that function V : R Ã— B â†’ R is
a v-function if it admits the following form:
V (r, b) = âˆ’a(1) 1râ‰¤b(2) âˆ’ a(2) r1b(2) <râ‰¤b(1) +
(a(3) r âˆ’ a(4) )1b(1) <r<(1+Î·)b(1) ,

with a(1) > 0 and Î· > 0 constants and a(1) , a(2) , a(3) , a(4)
defined by a(1) = Î·a(3) b(2) , a(2) = Î·a(3) , and a(4) =
a(3) (1 + Î·)b(1) .
Figure 4(a) illustrates this family of loss functions. A vfunction is a generalization of LÎ³ and L. Indeed, any vfunction V satisfies V (r, b) â‰¤ 0 and attains its minimum
at b(1) . Finally, as can be seen straightforwardly from Figure 3, LÎ³ is a v-function for any Î³ â‰¥ 0. We consider
the following general problem of minimizing a sum of vfunctions:
min F (r) :=
râ‰¥0

m
X

Vi (r, bi ).

(8)

i=1

Observe that this is not a trivial problem since, for any fixed
bi , Vi (Â·, bi ) is non-convex and that, in general, a sum of m
such functions may admit many local minima. The following proposition shows that the minimum is attained at one
of the highest bids, which matches the intuition.
Proposition 7. Problem (8) admits a solution râˆ— that sat(1)
isfies râˆ— = bi for some i âˆˆ [1, m].
The problem can thus be reduced to examining the value
(1)
of the function for the m arguments bi , i âˆˆ [1, m]. This
yields a straightforward method for solving the optimiza(1)
tion which consists of computing F (bi ) for all i and
taking the minimum. But, since the computation of each
(1)
F (bi ) takes O(m), the overall computational cost is in
O(m2 ), which can be prohibitive for even moderately large
values of m.
Instead, we have devised a more efficient combinatorial algorithm that can be used to solve the problem in
O(m log m) time. The algorithm consists of first sorting all boundary points, that is the points in N =
S (1) (2)
(1)
i {bi , bi , (1 + Î·)bi } associated with the functions
Vi (Â·, bi ), i âˆˆ [1, m]. We then show that for the ordered
sequence (n1 , . . . , n3m ), F (nk+1 ) can be computed from
F (nk ) in constant time, using the fact that the definition

Learning Theory and Algorithms for Revenue Optimization in Second-Price Auctions with Reserve

of Vi (Â·, bi ) can only change at boundary points (see Figure 4(b)). A more detailed description and the proof of the
correctness of the algorithm are given in the Appendix B.
Furthermore, the algorithm can be straightforwardly extended to solve the minimization of F over a set of r-values
bounded by Î›, that is {r : 0 â‰¤ r â‰¤ Î›}. Indeed, we then
(1)
only need to compute F (bi ) for i âˆˆ [1, m] such that
(1)
bi < Î› and of course also F (Î›), thus the computational
complexity in that regularized case remains O(m log m).
4.2. General case
We first consider the case of a hypothesis set H of linear
functions x 7â†’ w Â· x with bounded norm, kwk â‰¤ Î›, for
some Î› â‰¥ 0. This can be immediately generalized to the
case where a positive definite kernel is used.
The results of Theorem 5 suggest seeking, for a fixed
Î³ â‰¥ 0, the vector w solution
Pm of the following optimization problem: minkwkâ‰¤Î› i=1 LÎ³ (w Â· xi , bi ). Replacing
the original loss L with LÎ³ helped us remove the discontinuity of the loss. But, we still face an optimization problem based on a sum of non-convex functions. This problem can be formulated as a DC-programming (difference
of convex functions programming) problem. Indeed, LÎ³
can be decomposed as follows for all (r, b) âˆˆ X Ã— B:
LÎ³ (r, b) = u(r, b) âˆ’ v(r, b), with the convex functions
u and v defined by
u(r, b) = âˆ’r1r<b(1) +

râˆ’(1+Î³)b(1)
1râ‰¥b(1)
Î³

v(r, b) = (âˆ’r + b(2) )1r<b(2) +

râˆ’(1+Î³)b(1)
1r>b(1) .
Î³

Using the decomposition LÎ³ = u âˆ’ v, our optimization
problem can be formulated as follows:
min U (w) âˆ’ V (w)

wâˆˆRN

subject to kwk â‰¤ Î›,

(9)

Pm
where
i=1 u(w Â· xi , bi ) and V (w) =
Pm U (w) =
i=1 v(w Â· xi , bi ), which shows that it can be formulated as a DC-programming problem. The global minimum
of the optimization problem (9) can be found using a cutting plane method (Horst & Thoai, 1999), but that method
only converges in the limit and does not admit known algorithmic convergence guarantees.3 There exists also a
branch-and-bound algorithm with exponential convergence
for DC-programming (Horst & Thoai, 1999) for finding
the global minimum. Nevertheless, in (Tao & An, 1997),
it is pointed out that this type of combinatorial algorithms
fail to solve real-world DC-programs in high dimensions.
In fact, our implementation of this algorithm shows that
the convergence of the algorithm in practice is extremely
slow for even moderately high-dimensional problems. Another attractive solution for finding the global solution of
3

Some claims of (Horst & Thoai, 1999), e.g., Proposition 4.4
used in support of the cutting plane algorithm, are incorrect (Tuy,
2002).

a DC-programming problem over a polyhedral convex set
is the combinatorial solution of Hoang Tuy (Tuy, 1964).
However, casting our problem as an instance of that problem requires explicitly specifying the slope and offsets for
the piecewise linear function corresponding to a sum of LÎ³
losses, which admits an exponential cost in time and space.
An alternative consists of using the DC algorithm, a primaldual sub-differential method of Dinh Tao and Hoai An (Tao
& An, 1998), (see also (Tao & An, 1997) for a good survey). This algorithm is applicable when u and v are proper
lower semi-continuous convex functions as in our case.
When v is differentiable, the DC algorithm coincides with
the CCCP algorithm of Yuille and Rangarajan (Yuille &
Rangarajan, 2003), which has been used in several contexts in machine learning and analyzed by (Sriperumbudur
& Lanckriet, 2012).
The general proof of convergence of the DC algorithm was
given by (Tao & An, 1998). In some special cases, the DC
algorithm can be used to find the global minimum of the
problem as in the trust region problem (Tao & An, 1998),
but, in general, the DC algorithm or its special case CCCP
are only guaranteed to converge to a critical point (Tao &
An, 1998; Sriperumbudur & Lanckriet, 2012). Nevertheless, the number of iterations of the DC algorithm is relatively small. Its convergence has been shown to be in fact
linear for DC-programming problems such as ours (Yen
et al., 2012). The algorithm we are proposing goes one
step further than that of (Tao & An, 1998): we use DCA
to find a local minimum but then restart our algorithm with
a new seed that is guaranteed to reduce the objective function. Unfortunately, we are not in the same regime as in
the trust region problem of Dinh Tao and Hoai An (Tao &
An, 1998) where the number of local minima is linear in
the size of the input. Indeed, here the number of local minima can be exponential in the number of dimensions of the
feature space and it is not clear to us how the combinatorial
structure of the problem could help us rule out some local
minima faster and make the optimization more tractable.
In the following, we describe more in detail the solution
we propose for solving the DC-programming problem (9).
The functions v and V are not differentiable in our context
but they admit a sub-gradient at all points. We will denote
by Î´V (w) an arbitrary element of the sub-gradient âˆ‚V (w),
which coincides with âˆ‡V (w) at points w where V is differentiable. The DC algorithm then coincides with CCCP,
modulo the replacement of the gradient of V by Î´V (w). It
consists of starting with a weight vector w0 â‰¤ Î› and of
iteratively solving a sequence of convex optimization problems obtained by replacing V with its linear approximation giving wt as a function of wtâˆ’1 , for t = 1, . . . , T :
wt âˆˆ argminkwkâ‰¤Î› U (w) âˆ’ Î´V (wtâˆ’1 ) Â· w. This problem

Learning Theory and Algorithms for Revenue Optimization in Second-Price Auctions with Reserve
120

DC Algorithm
w â† w0
. initialization
for t â‰¥ 1 do
wt â† DCA(w) . DCA algorithm
w â† O PTIMIZE(objective, fixed direction wt /kwt k)
end for

NaÃ¯ve
Sorting

100

Time(s)

80
60
40
20
0

Figure 5. Pseudocode of our DC-programming algorithm.

can be rewritten in our context as the following:
min

kwkâ‰¤Î›,s

m
X

si âˆ’ Î´V (wtâˆ’1 ) Â· w

10

(10)

i=1

The problem is equivalent to a QP (quadraticprogramming) problem since the quadratic constraint
can be replaced by a term of the form Î»kwk2 in the objective and thus can be tackled using any standard QP solver.
We propose an algorithm that iterates along different local
minima, but with the guarantee of reducing the function at
every change of local minimum. The algorithm is simple
and is based on the observation that the function LÎ³ is
positive homogeneous. Indeed, for any Î· > 0 and (r, b),
LÎ³ (Î·r, Î·b) = âˆ’Î·b(2) 1Î·r<Î·b(2) âˆ’ Î·r1Î·b(2) â‰¤Î·râ‰¤Î·b(1)
Î·r âˆ’ (1 + Î³)Î·b(1)
1Î·b(1) <Î·r<Î·(1+Î³)b(1) = Î·LÎ³ (r, b).
Î³

Minimizing the objective function of (9) in a fixed direction u, kuk
Pm = 1, can be reformulated as follows:
min0â‰¤Î·â‰¤Î›
i=1 LÎ³ (Î·u Â· xi , bi ). Since for u Â· xi â‰¤ 0
(2)
the function Î· 7â†’ LÎ³ (Î·u Â· xi , bi ) is constant equal to âˆ’bi
the problem is equivalent to solving
X
min
LÎ³ (Î·u Â· xi , bi ).
0â‰¤Î·â‰¤Î›

7
8
9
Number of bids (3n)

Figure 6. Running-time of our combinatorial algorithm (sorting)
compared to the naÄ±Ìˆve algorithm in log-scale.

i
h
1
(1) 
.
subject to (si â‰¥ âˆ’w Â· xi )âˆ§ si â‰¥ w Â· xi âˆ’(1 + Î³)bi
Î³

+

6

uÂ·xi >0

Furthermore, since LÎ³ is positive homogeneous, for all
i âˆˆ [1, m] with u Â· xi > 0, LÎ³ (Î·u Â· xi , bi ) = (u Â·
xi )LÎ³ (Î·, bi /(u Â· xi )). But Î· 7â†’ (u Â· xi )LÎ³ (Î·, bi /(u Â· xi ))
is a v-function and thus the problem can efficiently optimized using the combinatorial algorithm for the no-feature
case (Section 4.1). This leads to the optimization algorithm
described in Figure 5. The last step of each iteration of our
algorithm can be viewed as a line search and this is in fact
the step that reduces the objective function the most in practice. This is because we are then precisely minimizing the
objective function even though this is for some fixed direction. Since in general this line search does not find a local
minimum (we are likely to decrease the objective value in
other directions that are not the one in which the line search
was performed) running DCA helps us find a better direction for the next iteration of the line search.

5. Experiments
Here, we report the results of some preliminary experiments demonstrating the benefits of our algorithm. All
our experiments were carried out using synthetic data.
While experiments with data from online auctions have
been reported in the literature (Cui et al., 2011), due to
confidentiality reasons, the corresponding data is not available to the public. There are other sources of auction data
(http://modelingonlineauctions.com/datasets),
however, these data sets do not include features. To the
best of our knowledge, there is no publicly available data
set for online auctions including features that could be
readily used with our algorithm.
We first tested the speed of our combinatorial algorithm
in the simple no-feature case. Figure 6 shows the computational time of that algorithm for finding the optimal solution compared to the naÄ±Ìˆve approach of evaluating the
loss at each point on a 4-Core 2.6 GHz AMD processor
with 7GB of RAM. The time our algorithm took to solve
the problem with 50,000 points was less than a second,
whereas the naÄ±Ìˆve approach required more than 2 minutes
to find the solution. This shows the potential for scalability of our algorithm. Running our algorithm to solve the
problem using 200,000 points required 1.87 seconds.
Our experiments were set up as follows. We sampled
vectors xi in R200 from a standard Gaussian distribution.
A labeling vector w âˆˆ R200 , also sampled from a standard Gaussian, was used to generate the bid vectors bi =
(|w Â· xi |, 12 |w Â· xi |). Absolute values were used to make the
dependency between features and bids non-linear.
We are not aware of any published learning algorithm using features to tackle the same problem. In the absence
of a baseline, we instead compared the performance of our
algorithm with some potential alternatives. One possible
algorithm consists of the regularized minimization of the
convex surrogate loss LÎ± of Figure 1(b) parametrized by
Î± âˆˆ [0, 1] and defined by
âˆ’r
if r < b(1) + Î±(b(2) âˆ’ b(1) )
LÎ± (r, b) =  (1âˆ’Î±)b(1) +Î±b(2) 
(r âˆ’ b(1) )
otherwise.
Î±(b(1) âˆ’b(2) )
(

Learning Theory and Algorithms for Revenue Optimization in Second-Price Auctions with Reserve
(a)

40

(b)
50

DC
Convex
S
Improvement %

Improvement %

50

30
20
10

DC
Convex
Ridge

Table 1. Comparison of the performance for different noise settings. The results reported are percentages of revenue gained over
using no feature using our algorithm (DC) or the regularized minimization based on a convex surrogate loss LÎ± (C ONV).

0

0
200

400

800 1600 3200 6400

âˆ’50
200

400

800

1600

3200

6400

Figure 7. Comparison of the performance of our algorithm (DC)
with that of other reserve price optimization techniques: (a) regularized minimization of a convex surrogate loss (C ONVEX); (b)
ridge regression (R IDGE). The results are reported as percentages
of revenue improvement over the no-feature method. The error
bars are not indicated since they are too tiny to be discernible at
the scale of the plot.

A second alternative consists of using ridge regression to
estimate the first bid and use its prediction as the reserve
price. A third algorithm consists of minimizing the loss
while ignoringPthe feature vectors xi , i.e., solving the probn
lem minrâ‰¤Î› i=1 L(r, bi ). It is worth mentioning that
this third approach is very similar to what advertisement
exchanges currently use to suggest reserve prices to publishers. By Equation (1), this is equivalent to estimating the
empirical distribution of bids and optimizing the expected
revenue with respect to this empirical distribution as in (Ostrovsky & Schwarz, 2011) and (Cesa-Bianchi et al., 2013).
For all our experiments, the parameters Î›, Î³ and Î± were
tuned via 10-fold cross-validation. The test set was a collection of 20,000 examples drawn from the same distribution. The experiment was repeated 20 times. Figure 7
shows the mean revenue increase obtained for each algorithm over the method using no feature. Since our DCprogramming algorithm can converge to a local minimum,
the choice of a good starting vector is crucial. For our experiments, it was selected via cross-validation from random starts. Another starting point considered
the crossPin
n
validation was the solution to minkwkâ‰¤Î› i=1 LÎ± (w Â·
xi , bi ).
Figure 7 shows the results of our experiments. The performance gain achieved by our algorithm is substantial and
clearly superior to that of a regularized minimization of a
convex surrogate loss or the no-feature algorithm, which
is the current state-of-the-art. Since the square loss used
in ridge regression is not calibrated with respect to L (it
is symmetric around b(1) whereas L is not), we could not
expect a high performance using that algorithm. As can
be seen from Figure 7, its performance is in fact the worst
among the four algorithms tested.
Finally, to test the performance of our algorithm in the presence of noise, we sampled the feature vectors xi and w as

Ïƒ
0.5
1.0
1.5
2.0
DC
33.59 Â± .65 26.43Â± .56 18.38 Â± .57 10.68 Â±.65
C ONV 1.13 Â± .16 -.08 Â± .13 -1.95 Â± .07 -3.54 Â± .07

before but generated bids as follows:
(1)

bi

(2)

bi


= max (|w Â· xi | + Ïƒ)+ , (0.5|w Â· xi | + Ïƒ)+

= min (|w Â· xi | + Ïƒ)+ , (0.5|w Â· xi | + Ïƒ)+ ,

where z+ := max(z, 0),  âˆ¼ N (0, 1) is a Gaussian random variable, and Ïƒ takes values in the set {.5, 1, 1.5, 2}.
We trained our algorithm on a sample of 8,000 points and
tested it on a sample of same size, and measured its performance as a function of the noise added to the bids. Table 5 shows the mean revenue improvement achieved over
the no-feature algorithm using our algorithm and the regularized minimization of a convex surrogate loss which was
the only competitive algorithm in the previous experiment.
Of course, as expected from all learning algorithm, the
performance deteriorates as the noise parameter increases.
But, while the performance of our algorithm becomes
smaller it remains non negligible for even relatively high
values of Ïƒ. In contrast, we observe that the performance
of the surrogate convex loss minimization algorithm decreases rapidly under an even moderate amount of noise.
This is likely to be related to the lack of calibration of convex surrogate. Note that this algorithm is even quickly outperformed by the straightforward no-feature approach in
the presence of noise.

6. Conclusion
We presented a comprehensive theoretical and algorithmic
analysis of the learning problem of revenue optimization in
second-price auctions with reserve. The specific properties
of the loss function for this problem required a new analysis
and new learning guarantees. The algorithmic solutions we
presented are practically applicable to revenue optimization
problems for this type of auctions in most realistic settings.
Our experimental results further demonstrate their effectiveness. Much of the analysis and algorithms presented, in
particular our study of calibration questions, can also be of
interest in other learning problems.

Acknowledgements
We thank Afshin Rostamizadeh and Umar Syed for several
discussions about the topic of this work and ICML reviewers for useful comments. This work was partly funded by
the NSF award IIS-1117591.

Learning Theory and Algorithms for Revenue Optimization in Second-Price Auctions with Reserve

References
Amin, Kareem, Kearns, Michael, Key, Peter, and
Schwaighofer, Anton. Budget optimization for sponsored search: Censored learning in MDPs. In UAI, pp.
54â€“63, 2012.
Balcan, Maria-Florina, Blum, Avrim, Hartline, Jason D.,
and Mansour, Yishay. Reducing mechanism design to
algorithm design via machine learning. J. Comput. Syst.
Sci., 74(8):1245â€“1270, 2008.
Bartlett, Peter L, Jordan, Michael I, and McAuliffe, Jon D.
Convexity, classification, and risk bounds. Journal
of the American Statistical Association, 101(473):138â€“
156, 2006.
Blum, Avrim, Kumar, Vijay, Rudra, Atri, and Wu, Felix.
Online learning in online auctions. Theor. Comput. Sci.,
324(2-3):137â€“146, 2004.
Cesa-Bianchi, NicoloÌ€, Gentile, Claudio, and Mansour,
Yishay. Regret minimization for reserve prices in
second-price auctions. In SODA, pp. 1190â€“1204, 2013.
Cui, Ying, Zhang, Ruofei, Li, Wei, and Mao, Jianchang.
Bid landscape forecasting in online ad exchange marketplace. In KDD, pp. 265â€“273, 2011.
Debreu, Gerard and Koopmans, Tjalling C. Additively
decomposed quasiconvex functions. Mathematical Programming, 24, 1982.
Easley, David A. and Kleinberg, Jon M. Networks, Crowds,
and Markets - Reasoning About a Highly Connected
World. Cambridge University Press, 2010.
Horst, R and Thoai, Nguyen V. DC programming:
overview. Journal of Optimization Theory and Applications, 103(1):1â€“43, 1999.
Koltchinskii, V. and Panchenko, D. Empirical margin distributions and bounding the generalization error of combined classifiers. Ann. Statist., 30(1):1â€“50, 2002.
Langford, John, Li, Lihong, Vorobeychik, Yevgeniy, and
Wortman, Jennifer. Maintaining equilibria during exploration in sponsored search auctions. Algorithmica, 58
(4):990â€“1021, 2010.

Mohri, Mehryar, Rostamizadeh, Afshin, and Talwalkar,
Ameet. Foundations of machine learning. MIT Press,
Cambridge, MA, 2012.
Muthukrishnan, S. Ad exchanges: Research issues. Internet and network economics, pp. 1â€“12, 2009.
Myerson, R.B. Optimal auction design. Mathematics of
operations research, 6(1):58â€“73, 1981.
Nisan, Noam, Roughgarden, Tim, Tardos, EÌva, and Vazirani, Vijay V. (eds.). Algorithmic game theory. Cambridge University Press, Cambridge, 2007.
Ostrovsky, Michael and Schwarz, Michael. Reserve prices
in internet advertising auctions: a field experiment. In
ACM Conference on Electronic Commerce, pp. 59â€“60,
2011.
Pollard, David. Convergence of stochastic processes.
Springer Series in Statistics. Springer-Verlag, New York,
1984.
Riley, J.G. and Samuelson, W.F. Optimal auctions. The
American Economic Review, pp. 381â€“392, 1981.
Sriperumbudur, Bharath K. and Lanckriet, Gert R. G. A
proof of convergence of the concave-convex procedure
using Zangwillâ€™s theory. Neural Computation, 24(6):
1391â€“1407, 2012.
Tao, Pham Dinh and An, Le Thi Hoai. Convex analysis
approach to DC programming: theory, algorithms and
applications. Acta Mathematica Vietnamica, 22(1):289â€“
355, 1997.
Tao, Pham Dinh and An, Le Thi Hoai. A DC optimization
algorithm for solving the trust-region subproblem. SIAM
Journal on Optimization, 8(2):476â€“505, 1998.
Tuy, Hoang. Concave programming under linear constraints. Translated Soviet Mathematics, 5:1437â€“1440,
1964.
Tuy, Hoang. Counter-examples to some results on D.C.
optimization. Technical report, Institute of Mathematics,
Hanoi, Vietnam, 2002.
Vickrey, William. Counterspeculation, auctions, and competitive sealed tenders. The Journal of finance, 16(1):
8â€“37, 1961.

Ledoux, Michel and Talagrand, Michel. Probability in Banach spaces. Classics in Mathematics. Springer-Verlag,
Berlin, 2011. Isoperimetry and processes, Reprint of the
1991 edition.

Yen, Ian E.H., Peng, Nanyun, Wang, Po-Wei, and Lin,
Shou-De. On convergence rate of concave-convex procedure. In Proceedings of the NIPS 2012 Optimization
Workshop, 2012.

Milgrom, P.R. and Weber, R.J. A theory of auctions and
competitive bidding. Econometrica: Journal of the
Econometric Society, pp. 1089â€“1122, 1982.

Yuille, Alan L. and Rangarajan, Anand. The concaveconvex procedure. Neural Computation, 15(4):915â€“936,
2003.

